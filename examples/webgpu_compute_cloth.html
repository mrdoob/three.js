<!doctype html>
<html lang="en">
	<head>
		<title>three.js webgpu - compute cloth</title>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
		/>
		<link type="text/css" rel="stylesheet" href="example.css" />
	</head>
	<body>
		<div id="info">
			<a
				href="https://threejs.org/"
				target="_blank"
				rel="noopener"
				class="logo-link"
			></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener"
					>three.js</a
				><span>Compute Cloth</span>
			</div>

			<small
				>Simple cloth simulation with a verlet system running in compute
				shaders.</small
			>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three/webgpu';

			import { Inspector } from 'three/addons/inspector/Inspector.js';
			import { texture } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';
			import { ClothSimulator } from 'three/addons/misc/ClothSimulator.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			let renderer,
				scene,
				camera,
				controls,
				textureLoader,
				cloth;

			const timer = new THREE.Timer();
			timer.connect( document );

			// TODO: Fix example with WebGL backend

			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );

				throw new Error( 'No WebGPU support' );

			}

			init();

			async function init() {

				renderer = new THREE.WebGPURenderer( {
					antialias: true,
					requiredLimits: { maxStorageBuffersInVertexStage: 1 },
				} );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera(
					50,
					window.innerWidth / window.innerHeight,
					0.01,
					10,
				);
				camera.position.set( 1, - 0.4, 1 );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 3;
				controls.target.set( 0, - 0.3, 0 );
				controls.update();

				const hdrLoader = new UltraHDRLoader().setPath(
					'textures/equirectangular/',
				);

				const hdrTexture = await hdrLoader.loadAsync(
					'royal_esplanade_2k.hdr.jpg',
				);
				hdrTexture.mapping = THREE.EquirectangularReflectionMapping;
				scene.background = hdrTexture;
				scene.backgroundBlurriness = 0.5;
				scene.environment = hdrTexture;
				scene.environmentIntensity = 0.1;

				textureLoader = new THREE.TextureLoader();

				const floorColor = await textureLoader.loadAsync(
					'textures/floors/FloorsCheckerboard_S_Diffuse.jpg',
				);
				floorColor.wrapS = THREE.RepeatWrapping;
				floorColor.wrapT = THREE.RepeatWrapping;
				floorColor.colorSpace = THREE.SRGBColorSpace;
				floorColor.repeat.set( 15, 15 );

				const floorMesh = new THREE.Mesh(
					new THREE.PlaneGeometry( 10, 10 ),
					new THREE.MeshPhysicalNodeMaterial( {
						map: floorColor,
					} ),
				);
				floorMesh.rotateX( - Math.PI / 2 );
				floorMesh.position.set( 0, - 1, 0 );
				floorMesh.receiveShadow = true;
				scene.add( floorMesh );

				const light = new THREE.DirectionalLight( 0xffffff, 3 );
				const shadowSize = 1;
				light.castShadow = true;
				light.shadow.camera.far = 10;
				light.shadow.bias = - 0.002;
				light.shadow.camera.top = - shadowSize;
				light.shadow.camera.bottom = shadowSize;
				light.shadow.camera.left = - shadowSize;
				light.shadow.camera.right = shadowSize;
				light.position.set( 2, 3, 1 );
				scene.add( light );

				setupCloth();
				loadDudeHead();

				window.addEventListener( 'resize', onWindowResize );

				renderer.setAnimationLoop( render );

			}

			function loadDudeHead() {

				const mapHeight = new THREE.TextureLoader().load(
					'models/gltf/LeePerrySmith/Infinite-Level_02_Disp_NoSmoothUV-4096.jpg',
				);

				const material = new THREE.MeshPhongMaterial( {
					color: 0x9c6e49,
					specular: 0x666666,
					shininess: 25,
					bumpMap: mapHeight,
					bumpScale: 10,
				} );

				const loader = new GLTFLoader();
				loader.load(
					'models/gltf/LeePerrySmith/LeePerrySmith.glb',
					function ( gltf ) {

						const head = gltf.scene.children[ 0 ];
						head.material = material;
						head.scale.setScalar( 0.1 );
						head.position.set( 0, - 0.5, 0 );
						head.receiveShadow = true;
						head.castShadow = true;
						scene.add( head );
			
					},
				);

			}

			function setupCloth() {

				cloth = new ClothSimulator( renderer, {
					segmentsX: 30,
					segmentsY: 30,
					width: 1,
					height: 1.5,
					numSphereColliders: 2, //<-- how many "sphere colliders" will interact with the cloth
					sphereRadius: 0.23,
					stiffness: 0.3,
					wind: 0.7,
					color: 0xff0000,
				} );
				scene.add( cloth.mesh );

				cloth.mesh.castShadow = true;
				cloth.mesh.receiveShadow = true;
				cloth.mesh.frustumCulled = false;

				//
				// positionthe colliders in such a way that contain the mesh.
				//
				cloth.setSphereCollider( 0, new THREE.Vector3( 0, - 0.3, 0 ) );
				cloth.setSphereCollider( 1, new THREE.Vector3( 0, - 0.45, 0.056 ), 0.2 );

				const material = cloth.mesh.material;
				material.colorNode = texture(
					textureLoader.load( 'textures/roughness_map.jpg' ),
				);

				const spheres = cloth.createSphereVisualizers();
				spheres.forEach( sphere => {

					scene.add( sphere );
					sphere.visible = false;
			
	} );

				const gui = renderer.inspector.createParameters( 'Cloth Simulator' );
				gui.add( cloth.options, 'wind', 0, 10, 0.1 ).onChange( value=>cloth.setWind( value ) );
				gui.add( cloth.options, 'stiffness', 0, 1, 0.01 ).onChange( value=>cloth.setStiffness( value ) );
				gui.add( cloth.options, 'dampening', 0, 1, 0.01 ).onChange( value=>cloth.setDampening( value ) );
				gui.add( { helpers: true }, 'helpers' ).onChange( ( value ) => {
			
					cloth.setSphereEnabled( 0, value );
					cloth.setSphereEnabled( 1, value );
			
	} ).name( 'Enable Colliders' );

				gui.add( { seeColliders: false }, 'seeColliders' ).onChange( ( value ) => {
			
					spheres.forEach( sphere => {

						sphere.visible = value;
			
		} );
			
	} ).name( 'See Colliders' );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;

				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			async function render() {

				timer.update();

				const deltaTime = Math.min( timer.getDelta(), 1 / 60 ); // don't advance the time too far, for example when the window is out of focus

				cloth.mesh.position.z = Math.cos( timer.getElapsed() * 1.2 );
				cloth.mesh.rotateY( deltaTime );
				cloth.update( deltaTime );

				renderer.render( scene, camera );
			
			}
		</script>
	</body>
</html>
