<!DOCTYPE html>
<!--
	ProjectEchelon
    	Modifications suggested by stackoverflow user vals
	Text scrambler designed by jnrbsn: https://github.com/jnrbsn/rubiks-cube-scrambler
    	Three.js version: r68 -->

<html lang="en">
    <head>
        <meta charset="utf-8" />
		<style>
			#txtbttcontainer
			{
				position: absolute;
				top: 100px;
				left: 900px;
				z-index: 10;
				display: inline;
			}
			
			#orientationBtns
			{
				position: absolute;
				top: 500px;
				left: 100px;
				z-index: 10;
				display: inline;
			}
			
			.axesButtons
			{
				display: block;
			}
			
			#main 
			{
				position: absolute;
				top: 0px;
				left: 500px;
				padding: 30px;
				max-width: 300px;
				z-index: 10;
			}

			#scramble 
			{
				font-family: Menlo,Monaco,Consolas,"Courier New",monospace;
				font-size: 20px;
				line-height: 20px;
				margin-bottom: 20px;
			}

			#btn-refresh 
			{
				background-color: #428bca;
				border: 1px solid #357ebd;
				border-radius: 5px;
				color: #fff;
				cursor: pointer;
				display: inline-block;
				font-family: Menlo,Monaco,Consolas,"Courier New",monospace;
				font-size: 15px;
				line-height: 10px;
				margin: 0;
				outline: none;
				padding: 20px 0;
				width: 100px;
				position: relative;
				left: 300px;
			}
		</style>
		<title>Animated Rubik's Cube Scrambler</title>
    </head>
    <body>
		<div id="container"></div>
		
		<div id="orientationBtns">
			<input type="button" onclick="rotateX()" value="Rotate Along X" class="axesButtons"></input>
			<input type="button" onclick="rotateY()" value="Rotate Along Y" class="axesButtons"></input>
			<input type="button" onclick="rotateZ()" value="Rotate Along Z" class="axesButtons"></input>
		</div>
		<div id="main">
			<div id="scramble"></div>
			<button id="btn-refresh">SCRAMBLE</button>
		</div>
    </body>
    <script src="../build/three.min.js"></script>
    <script src="../examples/js/libs/stats.min.js"></script>
	<script src="../examples/js/Detector.js"></script>
    <script src="../examples/js/controls/OrbitControls.js"></script>
	<script src="../src/extras/SceneUtils.js"></script>
	<script src="../examples/js/rubiksCube/cubies.js"></script>
    <script src="../examples/js/rubiksCube/faceRotations.js"></script>
	<script src="../examples/js/rubiksCube/scrambleEngine.js"></script>
    <script>
        //Global variables
		window.onload = function()
		{
			init();
			addToDOM();
			fillScene();
			animate();
		}
		
        var renderer, scene;
        var camera, cameraControls;
        var clock = new THREE.Clock();
        var activeCount = 0;
        var stats;

        var cubies = [];
        var active = [];
        var planes = [];
        var objects = [];

        var pivot;
		
        //Scene initialisation code:
        function init()
        {
            var canvasWidth = window.innerWidth;
            var canvasHeight = window.innerHeight;
            var aspectRatio = canvasWidth / canvasHeight;

            //Renderer:
			renderer = Detector.webgl? new THREE.WebGLRenderer({ antialias: true }): errorMessage();
            renderer.gammaInput = true;
            renderer.gammaOutput = true;
            renderer.setClearColor(0xFFFFFF);
            renderer.setSize(canvasWidth, canvasHeight);

            //Camera:
            camera = new THREE.PerspectiveCamera(45, aspectRatio, 0.1, 20000);
            camera.position.set(400, 800, 800);

            //CameraControls:
            cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
			
            //onWindowResize
			window.addEventListener("resize", onWindowResize, false);
	
			//scramble
			document.getElementById("btn-refresh").addEventListener("click", displayScramble);
        }


		function errorMessage()
		{
			alert("Snap! It seems WebGL is either not supported or your GPU is blacklisted! Switching to Canvas Renderer... Will get slow!");
			return new THREE.CanvasRenderer();
		}
		
        function fillScene()
        {
            scene = new THREE.Scene();
            createLights();

            cubies = new createCubies();

            pivot = new THREE.Object3D();
            scene.add(pivot);

            //Add cubies (Child cubes) to scene
            for (var i = 0; i < cubies.length; i++)
                scene.add(cubies[i]);
        }

		var obj;
        function createLights()
        {
            //Lights
            var ambientLight = new THREE.AmbientLight(0x333333);
			scene.add(ambientLight);
			
            obj = new THREE.Object3D();
			var spotlight = new THREE.SpotLight(0xFFFFFF, 0.99225);
			spotlight.position.set(100,100,100);
			spotlight.angle = 60 * Math.PI / 180;
			spotlight.exponent = 100;
			spotlight.target.position.set(0,0,0);
			
			var spotlight2 = new THREE.SpotLight(0xFFFFFF, 0.99225);
			spotlight.position.set(100,100,250);
			spotlight.angle = 60 * Math.PI / 180;
			spotlight.exponent = 100;
			spotlight.target.position.set(0,0,0);
			

			obj.add(spotlight);
			obj.add(spotlight2);
			scene.add(obj);
        }

        //Find cubies' position in world coordinates
        function pos(object)
        {
            scene.updateMatrixWorld(true);
            var position = new THREE.Vector3();
            position.setFromMatrixPosition(object.matrixWorld);
            return position;
        }

        function onWindowResize(event)
        {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }

        function addToDOM()
        {
            var container = document.getElementById("container");
            container.appendChild(renderer.domElement);

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
			stats.domElement.style.left = '10px'; 
            container.appendChild(stats.domElement);
        }
		
        function animate()
        {
            window.requestAnimationFrame(animate);
            render();
        }
		
        function detachAndReset()
        {
            for (var i = 0; i < active.length; i++)
                THREE.SceneUtils.detach(active[i], pivot, scene);

            active.length = 0;
            activeCount = 0;

            attachedR = false;
            attachedU = false;
            attachedF = false;

            attachedR_P = false;
            attachedU_P = false;
            attachedF_P = false;

            attachedL = false;
            attachedD = false;
            attachedB = false;

            attachedL_P = false;
            attachedD_P = false;
            attachedB_P = false;

            attachedM = false;
            attachedM_P = false;
			attachedS = false;
			attachedS_P = false;
			attachedE = false;
			attachedE_P = false;
			
			attachedX = false;
			attachedY = false;
			attachedZ = false;
			
			attachedX_P = false;
			attachedY_P = false;
			attachedZ_P = false;
			
			attachedr = false;
			attachedr_P = false;
			attachedu = false;
			attachedu_P = false;
			attachedf = false;
			attachedf_P = false;
			
			attachedb = false;
			attachedb_P = false;
			attachedl = false;
			attachedl_P = false;
			attachedd = false;
			attachedd_P = false;
			
            pivot.rotation.x = 0;
            pivot.rotation.y = 0;
            pivot.rotation.z = 0;

        }

        function render()
        {

            var delta = clock.getDelta();
            cameraControls.update(delta);
            stats.update();
			

			obj.position.copy(camera.position);
            var endAnimation = false;
            //Math.PI / 2 == 1.580000000000001
            //Rotate Right face of cube
            if (attachedR === true)
            {
                pivot.rotation.x -= 0.091;
				 
                if (pivot.rotation.x <= -Math.PI / 2.0)
                {
                    pivot.rotation.x = -Math.PI / 2.0;
                    endAnimation = true;
                }
            }

            //Math.PI / 2 == 1.580000000000001
            //Rotate Upper face of cube
            if (attachedU === true)
            {
                pivot.rotation.y -= 0.091;
				
                if (pivot.rotation.y <= -Math.PI / 2.0)
                {
                    pivot.rotation.y = -Math.PI / 2.0;
					endAnimation = true;
                }
            }

            //Rotate Front Face of cube
            if (attachedF === true)
            {
                pivot.rotation.z -= 0.091;
				
                if (pivot.rotation.z <= -Math.PI / 2.0)
                {
                    pivot.rotation.z = -Math.PI / 2.0;
					endAnimation = true;
                }
            }

            //Rotate Right_Prime face of cube primen
            if (attachedR_P === true)
            {
                pivot.rotation.x += 0.091;
				
                if (pivot.rotation.x >= Math.PI / 2.0)
                {
                    pivot.rotation.x = Math.PI / 2.0;
                    endAnimation = true;
                }
            }

            //Math.PI / 2 == 1.580000000000001
            //Rotate Upper_Prime face of cube
            if (attachedU_P === true)
            {
                pivot.rotation.y += 0.091;
				
                if (pivot.rotation.y >= Math.PI / 2.0)
                {
                    pivot.rotation.y = Math.PI / 2.0;
                    endAnimation = true;
                }
            }

            //Rotate Front_Prime Face of cube
            if (attachedF_P === true)
            {
                pivot.rotation.z += 0.091;
				
                if (pivot.rotation.z >= Math.PI / 2.0)
                {
                    pivot.rotation.z = Math.PI / 2.0;
                    endAnimation = true;
                }
            }

            //Rotate Left Face of cube
            if (attachedL === true)
            {
                pivot.rotation.x += 0.091;
				
                if (pivot.rotation.x >= Math.PI / 2.0)
                {
                    pivot.rotation.x = Math.PI / 2.0;
                    endAnimation = true;
                }
            }

            //Rotate Down Face of cube
            if (attachedD === true)
            {
                pivot.rotation.y += 0.091;
				
                if (pivot.rotation.y >= Math.PI / 2.0)
                {
                    pivot.rotation.y = Math.PI / 2.0;
                    endAnimation = true;
                }
            }

            //Rotate Back face of cube
            if (attachedB === true)
            {
                pivot.rotation.z += 0.091;
                if (pivot.rotation.z >= Math.PI / 2.0)
                {
                    pivot.rotation.z = Math.PI / 2.0;
                    endAnimation = true;
                }
            }

            //LDB_Prime
            if (attachedL_P === true)
            {
                pivot.rotation.x -= 0.091;
				 
                if (pivot.rotation.x <= -Math.PI / 2.0)
                {
                    pivot.rotation.x = -Math.PI / 2.0;
                    endAnimation = true;
                }
            }

            //Rotate Down Face of cube
            if (attachedD_P === true)
            {
                pivot.rotation.y -= 0.091;
			
                if (pivot.rotation.y <= -Math.PI / 2.0)
                {
                    pivot.rotation.y = -Math.PI / 2.0;
                    endAnimation = true;
                }
            }

            //Rotate Back face of cube
            if (attachedB_P === true)
            {
                pivot.rotation.z -= 0.091;
				
                if (pivot.rotation.z <= -Math.PI / 2.0)
                {
                    pivot.rotation.z = -Math.PI / 2.0;
                    endAnimation = true;
                }
            }

            //Rotate Middle Face of cube
            if (attachedM === true)
            {
                pivot.rotation.x -= 0.091;
				
                if (pivot.rotation.x <= -Math.PI / 2.0)
                {
                    pivot.rotation.x = -Math.PI / 2.0;
                    endAnimation = true;
                }
            }

            //Rotate Middle face prime of cube
            if (attachedM_P === true)
            {
                pivot.rotation.x += 0.091;
				
                if (pivot.rotation.x >= Math.PI / 2.0)
                {
                    pivot.rotation.x = Math.PI / 2.0;
                    endAnimation = true;
                }
            }

			if (attachedX === true)
            {
                pivot.rotation.x -= 0.091;
                if (pivot.rotation.x <= -Math.PI / 2.0)
                {
                    pivot.rotation.x = -Math.PI / 2.0;
                    endAnimation = true;
                }
            }
			
			if (attachedY === true)
            {
                pivot.rotation.y -= 0.091;
                if (pivot.rotation.y <= -Math.PI / 2.0)
                {
                    pivot.rotation.y = -Math.PI / 2.0;
                    endAnimation = true;
                }
            }
			
			if (attachedZ === true)
            {
                pivot.rotation.z -= 0.091;
                if (pivot.rotation.z <= -Math.PI / 2.0)
                {
                    pivot.rotation.z = -Math.PI / 2.0;
                    endAnimation = true;
                }
            }
			
			if (attachedX_P === true)
            {
                pivot.rotation.x += 0.091;
                if (pivot.rotation.x >= Math.PI / 2.0)
                {
                    pivot.rotation.x = Math.PI / 2.0;
                    endAnimation = true;
                }
            }
			
			if (attachedY_P === true)
            {
                pivot.rotation.y += 0.091;
                if (pivot.rotation.y >= Math.PI / 2.0)
                {
                    pivot.rotation.y = Math.PI / 2.0;
                    endAnimation = true;
                }
            }
			
			if (attachedZ_P === true)
            {
                pivot.rotation.z += 0.091;
                if (pivot.rotation.z >= Math.PI / 2.0)
                {
                    pivot.rotation.z = Math.PI / 2.0;
                    endAnimation = true;
                }
            }
			
            renderer.render(scene, camera);
            if (endAnimation)
                detachAndReset();

        }
        </script>
</html>
