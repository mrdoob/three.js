<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Three.js WebGPU - Procedural Wood Materials</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<meta name="author" content="Logan Seeley"/>
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>

			body {
				color:white;
			}

			#info a {
				color:#1cdfe2;
			}

		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgpu - tsl procedural wood materials<br/>
			by Logan Seeley, based on <a href="https://www.youtube.com/watch?v=n7e0vxgBS8A">Lance Phan's Blender tutorial</a>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three';
			import * as TSL from 'three/tsl';
			import Stats from 'three/addons/libs/stats.module.js';
			import WebGPU from 'three/addons/capabilities/WebGPU.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
			import { FontLoader } from 'three/addons/loaders/FontLoader.js';
			import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
			import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
			import { WoodNodeMaterial, WoodGenuses, Finishes } from 'three/addons/materials/ProceduralWood.js';

			let scene, base, camera, renderer, controls, stats, font, blockGeometry;

			// Helper function to get grid position
			function getGridPosition( woodIndex, finishIndex ) {

				return {
					x: 0,
					y: ( finishIndex - Finishes.length / 2 ) * 1.0,
					z: ( woodIndex - WoodGenuses.length / 2 + 0.45 ) * 1.0
				};

			}

			// Helper function to create the grid plane
			function createGridPlane() {

				const material = new THREE.MeshBasicNodeMaterial();

				const gridXZ = TSL.Fn( ( [ gridSize = TSL.float( 1.0 ), dotWidth = TSL.float( 0.1 ), lineWidth = TSL.float( 0.02 ) ] ) => {

					const coord = TSL.positionWorld.xz.div( gridSize );
					const grid = TSL.fract( coord );

					// Screen-space derivative for automatic antialiasing
					const fw = TSL.fwidth( coord );
					const smoothing = TSL.max( fw.x, fw.y ).mul( 0.5 );

					// Create squares at cell centers
					const squareDist = TSL.max( TSL.abs( grid.x.sub( 0.5 ) ), TSL.abs( grid.y.sub( 0.5 ) ) );
					const dots = TSL.smoothstep( dotWidth.add( smoothing ), dotWidth.sub( smoothing ), squareDist );

					// Create grid lines
					const lineX = TSL.smoothstep( lineWidth.add( smoothing ), lineWidth.sub( smoothing ), TSL.abs( grid.x.sub( 0.5 ) ) );
					const lineZ = TSL.smoothstep( lineWidth.add( smoothing ), lineWidth.sub( smoothing ), TSL.abs( grid.y.sub( 0.5 ) ) );
					const lines = TSL.max( lineX, lineZ );

					return TSL.max( dots, lines );

				} );

				const radialGradient = TSL.Fn( ( [ radius = TSL.float( 10.0 ), falloff = TSL.float( 1.0 ) ] ) => {

					return TSL.smoothstep( radius, radius.sub( falloff ), TSL.length( TSL.positionWorld ) );

				} );

				// Create grid pattern
				const gridPattern = gridXZ( 1.0, 0.03, 0.005 );
				const baseColor = TSL.vec4( 1.0, 1.0, 1.0, 0.0 );
				const gridColor = TSL.vec4( 0.5, 0.5, 0.5, 1.0 );

				// Mix base color with grid lines
				material.colorNode = gridPattern.mix( baseColor, gridColor ).mul( radialGradient( 30.0, 20.0 ) );
				material.transparent = true;

				const plane = new THREE.Mesh( new THREE.CircleGeometry( 40 ), material );
				plane.rotation.x = - Math.PI / 2;
				plane.renderOrder = - 1;

				return plane;

			}

			// Helper function to create and position labels
			function createLabel( text, font, material, position ) {

				const txt_geo = new TextGeometry( text, {
					font: font,
					size: 0.1,
					depth: 0.001,
					curveSegments: 12,
					bevelEnabled: false
				} );

				txt_geo.computeBoundingBox();
				const offx = - 0.5 * ( txt_geo.boundingBox.max.x - txt_geo.boundingBox.min.x );
				const offy = - 0.5 * ( txt_geo.boundingBox.max.y - txt_geo.boundingBox.min.y );
				const offz = - 0.5 * ( txt_geo.boundingBox.max.z - txt_geo.boundingBox.min.z );
				txt_geo.translate( offx, offy, offz );

				const label = new THREE.Group();
				const mesh = new THREE.Mesh( txt_geo );
				label.add( mesh );

				// Apply default rotation for labels
				label.rotateY( - Math.PI / 2 );

				label.children[ 0 ].material = material;
				label.position.copy( position );
				base.add( label );
			
			}

			async function init() {

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );
			

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.set( - 0.1, 5, 0.548 );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( 1.0 ); // important for performance
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 1.0;
				renderer.setAnimationLoop( render );
				document.body.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 0, 0.548 );

				stats = new Stats();
				document.body.appendChild( stats.dom );
			
				font = await new FontLoader().loadAsync( './fonts/helvetiker_regular.typeface.json' );

				// Create shared block geometry
				blockGeometry = new RoundedBoxGeometry( 0.125, 0.9, 0.9, 10, 0.02 );

				base = new THREE.Group();
				base.rotation.set( 0, 0, - Math.PI / 2 );
				base.position.set( 0, 0, 0.548 );
				scene.add( base );

				const text_mat = new THREE.MeshStandardMaterial();
				text_mat.colorNode = TSL.color( '#000000' );

				// Create finish labels (using negative wood index for left column)
				for ( let y = 0; y < Finishes.length; y ++ ) {

					createLabel( Finishes[ y ], font, text_mat, getGridPosition( - 1, y ) );

				}

				// Create and add the grid plane
				const plane = createGridPlane();
				scene.add( plane );

				await new HDRLoader()
					.setPath( 'textures/equirectangular/' )
					.loadAsync( 'san_giuseppe_bridge_2k.hdr' ).then( ( texture ) => {

						texture.mapping = THREE.EquirectangularReflectionMapping;

						scene.environment = texture;
						scene.environmentIntensity = 2;

					} );

				// Create wood labels (using negative finish index for top row)
				for ( let x = 0; x < WoodGenuses.length; x ++ ) {

					createLabel( WoodGenuses[ x ], font, text_mat, getGridPosition( x, - 1 ) );

				}

				// Create wood blocks
				for ( let x = 0; x < WoodGenuses.length; x ++ ) {

					for ( let y = 0; y < Finishes.length; y ++ ) {

						const material = WoodNodeMaterial.fromPreset( WoodGenuses[ x ], Finishes[ y ] );
						const cube = new THREE.Mesh( blockGeometry, material );
						cube.position.copy( getGridPosition( x, y ) );
						base.add( cube );

						await new Promise( resolve => setTimeout( resolve, 0 ) );

					}

				}

				 add_custom_wood( text_mat );

			}

			function render() {

				controls.update();
				stats.update();

				renderer.render( scene, camera );
			
			}

			window.addEventListener( 'resize', () => {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			} );

			if ( WebGPU.isAvailable() ) {

				init();
			
			} else {

				document.body.appendChild( WebGPU.getErrorMessage() );

			}



			function add_custom_wood( text_mat ) {

				// Add "Custom" label (positioned at the end of the grid)
				createLabel( 'custom', font, text_mat, getGridPosition( Math.round( WoodGenuses.length / 2 - 1 ), 5 ) );

				// Create custom wood material with unique parameters
				const customMaterial = new WoodNodeMaterial( {
					centerSize: 1.8,
					largeWarpScale: 0.5,
					ringCount: 45,
					ringBias: 0.15,
					barkThickness: 0.8,
					splotchScale: 2.5,
					splotchIntensity: 1.8,
					cellScale: 1200,
					cellSize: 0.05,
					darkGrainColor: new THREE.Color( '#0a0a0a' ),
					lightGrainColor: new THREE.Color( '#8b4513' ),
					clearcoat: 1,
					clearcoatRoughness: 0.2
				} );

				const cube = new THREE.Mesh( blockGeometry, customMaterial );
				cube.position.copy( getGridPosition( Math.round( WoodGenuses.length / 2 ), 5 ) );

				base.add( cube );

			}

		</script>
	</body>
</html>
