<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - shared skeleton</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				display:block;
			}
			#info a {
				color: #046;
				font-weight: bold;
			}
			#explanation {
				position: absolute;
				bottom: 1rem;
				width: 20rem;
				left: 1rem;
				padding: 0.5rem;
				z-index: 1;
				background: rgba(0,0,0,0.8);
			}
		</style>
	</head>

	<body>
		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - Shared Skeleton<br />
			Character and animation from <a href="https://www.mixamo.com/" target="_blank" rel="noopener">Mixamo</a><br /><br />
		</div>

		<div id="explanation">
			Multiple instances of SkinnedMesh all controlled by a single Skeleton. Use the controls to compare performance with a multi skeleton approach. You may need to increase the rows before the performance gains are noticeable.
		</div>

		<script src="../build/three.js"></script>

		<script src="js/libs/inflate.min.js"></script>
		<script src="js/loaders/FBXLoader.js"></script>
		<script src="js/utils/SkeletonUtils.js"></script>

		<script src="js/controls/OrbitControls.js"></script>

		<script src="js/WebGL.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<script>
			if ( WEBGL.isWebGLAvailable() === false ) {

				document.body.appendChild( WEBGL.getWebGLErrorMessage() );

			}

			const numCols = 9;
			const rowSize = 150;
			const rowOffset = ( numCols - 1 ) * ( rowSize / 2 );

			let container, stats, controls;
			let camera, scene, renderer, light;
			let danceGroup, danceAnimation;
			let sharedDanceAction;

			let loadedObject, sharedModel;

			const clock = new THREE.Clock();

			// Simple material to use instead of the model default
			const normalMat = new THREE.MeshNormalMaterial({ 
				skinning: true
			});

			// Shared objects for the shared skeleton technique
			let sharedMixer;
			let sharedSkeleton;

			// Array of animation mixers for non-sharing technique
			let mixers;

			// Dat GUI
			const gui = new dat.GUI();

			const GuiOptions = function () {

				this.numRows = 1;
				this.isSkeletonShared = true;

			};

			const guiOptions = new GuiOptions();

			const createDancers = ( numRows ) => {

				// Clear all dancers and create new empty group
				if ( danceGroup ) scene.remove( danceGroup );
				danceGroup = new THREE.Group();
				scene.add( danceGroup );

				// Clear animation mixers
				mixers = [];

				if ( guiOptions.isSkeletonShared ) {

					// Same number of models sharing one skeleton and animation mixer
					for ( let z = 0; z < numRows; z ++ ) {

						for ( let x = 0; x < numCols; x ++ ) {

							const group = new THREE.Group();
							const meshGroup = new THREE.Group();

							const mainMesh = sharedModel.clone();

							// It's important to pass in the matrixWorld for each mesh here as the skeleton is shared
							mainMesh.bind( sharedSkeleton, meshGroup.matrixWorld );  

							// Because we're sharing a skeleton that isn't sharing world space
							// with the mesh, we need to set bindMode to detached
							mainMesh.bindMode = 'detached';

							meshGroup.add( mainMesh );

							meshGroup.position.x = x * rowSize - rowOffset;
							meshGroup.position.z = - z * rowSize;

							group.add( meshGroup );
							danceGroup.add( group );

						}

					}

				} else {

					// Multiple models with their own skeletons and animation mixers
					for ( let z = 0; z < numRows; z ++ ) {

						for ( let x = 0; x < numCols; x ++ ) {

							const clonedObject = THREE.SkeletonUtils.clone( loadedObject );
							danceGroup.add( clonedObject );

							clonedObject.position.x = x * rowSize - rowOffset;
							clonedObject.position.z = - z * rowSize;

							const mixer = new THREE.AnimationMixer( clonedObject );
							const action = mixer.clipAction( danceAnimation );

							action.play();

							mixers.push( mixer );

						}

					}

				}

			};

			const onModelLoad = object => {

				loadedObject = object;
				danceAnimation = loadedObject.animations[ 0 ];
				const jointsModel = loadedObject.getObjectByName('Alpha_Joints');
				const mainModel = loadedObject.getObjectByName('Alpha_Surface')

				// Setting the material for the main model to something less GPU intensive
				// and also removing the "joints" part of the model as this just complicates the demo
				mainModel.material = normalMat
				loadedObject.remove(jointsModel)

				// Cloning the model so it doesn't clash with the other non-shared skeleton mode
				const sharedObject = THREE.SkeletonUtils.clone( loadedObject );

				// Setting objects that are all used by the shared skeleton models
				sharedModel = sharedObject.getObjectByName( 'Alpha_Surface' );
				const sharedParentBone = sharedObject.getObjectByName( 'mixamorigHips' );
				sharedMixer = new THREE.AnimationMixer( sharedObject );
				sharedSkeleton = sharedModel.skeleton;
				sharedDanceAction = sharedMixer.clipAction( danceAnimation );
				sharedDanceAction.play();

				// The bones need to be in the scene for the animation to work
				scene.add( sharedParentBone );

				// Once model is loded we can set the gui up
				guiSetup();

				// Initiate first set of dancers
				createDancers( guiOptions.numRows );

			};

			const init = () => {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 0, 500, 1000 );

				controls = new THREE.OrbitControls( camera, container );
				controls.target.set( 0, 300, 0 );
				controls.update();

				scene = new THREE.Scene();

				const grid = new THREE.GridHelper( 10000, 50, 0xffffff, 0xffffff );
				scene.add( grid );

				// model could be in any format (e.g. glTF)
				const loader = new THREE.FBXLoader();
				loader.load( 'models/fbx/Samba Dancing.fbx', onModelLoad );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

				// stats
				stats = new Stats();
				container.appendChild( stats.dom );

			};

			const onWindowResize = () => {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			};

			const showDancers = num => {

				const meshes = isSkeletonShared ? sharedSkelMeshes : multiSkelMeshes;
				meshes.forEach( ( mesh, index ) => {

					if ( index < num ) {

						mesh.visible = true;

					} else {

						mesh.visible = false;

					}

				} );

			};

			const guiSetup = () => {

				const numRowsControl = gui.add( guiOptions, 'numRows' ).min( 1 ).max( 50 ).step( 1 );

				numRowsControl.onChange( numRows => {

					createDancers( numRows );

				} );

				const skelControl = gui.add( guiOptions, 'isSkeletonShared' );
				skelControl.onChange( () => {

					createDancers( guiOptions.numRows );

				} );

			};

			const animate = () => {

				requestAnimationFrame( animate );

				const delta = clock.getDelta();

				if ( sharedMixer ) sharedMixer.update( delta );

				if ( mixers ) {

					mixers.forEach( mixer => {

						mixer.update( delta );

					} );

				}

				renderer.render( scene, camera );

				stats.update();

			};

			init();
			animate();

		</script>

	</body>
</html>
