<!--
	@author munrocket / https://twitter.com/munrocket_twit
	Uses modified formulas from paper by Marco Abrate and Fabrizio Pollastri
	Inspired by Callum Prentice page thumbnails
-->

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js examples</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="preload" href="./screenshots/all_in_one.jpg">
		<link type="text/css" rel="stylesheet" href="./main.css">
		<style>
			body {
				background-color: #FFF;
			}
			@font-face {
				font-family: 'Roboto Mono';
				src: local('Roboto Mono'), local('RobotoMono-Regular'), url('../files/RobotoMono-Regular.woff2') format('woff2');
				font-style: normal;
				font-weight: 400;
			}
			#tooltip {
				position: fixed;
				display: none;
				padding: 0px 10px 2px 10px;
				border-radius: 16px;
				background-color: #049EF4;
				color: #fff;
				font-family: 'Roboto Mono', monospace;
				font-size: 14px;
				text-align: center;
				pointer-events: none;
				z-index: 5;
			}
		</style>
	</head>

	<body>

		<div id="tooltip"></div>
		<canvas id="canvas"></canvas>

		<script src="files.js"></script>

		<script type="module">

			import * as THREE from '../build/three.module.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { SpiralSphereGeometry } from './jsm/geometries/SpiralSphereGeometry.js';

			var canvas, camera, material, scene, renderer, controls;
			var sphere, outline, examples, radius, turns, zoomSpeed;
			var mouseMove, mouseMove0, mouseDown, idMove, idDown, isSwipe, tooltip, tooltipWaiting;

			init();

			function init() {

				examples = [];
				Object.keys( files ).forEach( key => {
					files[ key ].forEach( name => examples.push( name ) );
				});

				var tileRatio = 800 / 600;
				turns = Math.PI / Math.sqrt( 4 * Math.PI / examples.length / tileRatio );
				radius = 1;
				var gap = 0.05;
				var subGrid = 10;

				var texSize = Math.ceil( Math.sqrt( examples.length ) );
				var uvZoom = 0.01;
				var uvZoom2 = 0.065;
				zoomSpeed = 0.25;

				mouseMove = new THREE.Vector2();
				mouseMove0 = new THREE.Vector2();
				mouseDown = new THREE.Vector2();
				tooltip = document.getElementById( 'tooltip' );
				canvas = document.getElementById( 'canvas' );

				// scene

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xFFFFFF );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
				camera.position.set( 0, 1.5, 1 );
				camera.matrixWorldNeedsUpdate = true;
				if ( camera.aspect < 1 ) {

					var pos = camera.position.divideScalar( camera.aspect );
					camera.position.set( pos.x, pos.y, pos.z );

				}

				sphere = new SpiralSphereGeometry( radius, turns, gap, gap, subGrid, subGrid, examples.length );
				sphere.setAttribute( 'zoom', new THREE.BufferAttribute( new Float32Array( sphere.attributes.id.count ), 1 ) );
				sphere.setAttribute( 'uv2', sphere.attributes.uv.clone() );
				sphere.computeVertexNormals();
				computeTileUVs( sphere, texSize, sphere.attributes.uv, uvZoom );
				computeTileUVs( sphere, texSize, sphere.attributes.uv2, uvZoom2 );

				material = new THREE.MeshBasicMaterial( { color: 0xA1A1A1 } );
				var loader = new THREE.TextureLoader();
				loader.load( './screenshots/all_in_one.jpg', function( map ) {

					material.color = null;
					material.map = map;
					material.needsUpdate = true;

					loader.load( './screenshots/all_in_one_full.jpg', function( map ) {

						map.generateMipmaps = false;
						map.minFilter = THREE.LinearFilter;
						map.magFilter = THREE.LinearFilter;
						material.map = map;
						material.needsUpdate = true;

					} );

				} );
				material.onBeforeCompile = function ( shader ) {

					shader.vertexShader = [
						'attribute float zoom;',
						'attribute vec2 uv2;',
						shader.vertexShader
					].join( '\n' );
					shader.vertexShader = shader.vertexShader.replace( '#include <uv_vertex>', [
						'#ifdef USE_UV',
						'  vUv = mix( uv, uv2, zoom );',
						'#endif'
					].join( '\n' ) );

				};

				scene.add( new THREE.Mesh( sphere, material ) );

				var thikness = 0.12 * gap * Math.sqrt( window.devicePixelRatio || 1 );
				var geometry = new THREE.RingBufferGeometry( 1 + thikness, 1 + 2 * thikness, 100 );
				var matLine = new THREE.MeshBasicMaterial( { color: 0x049EF4 } );
				outline = new THREE.Mesh( geometry, matLine );

				scene.add( outline );

				// controls

				controls = new OrbitControls( camera, canvas );
				controls.enableDamping = true;
				controls.dampingFactor = 0.04;
				controls.screenSpacePanning = false;
				controls.enablePan = false;
				controls.minDistance = 1.05;
				controls.maxDistance = 10;

				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true, canvas: canvas } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				animate();

				// events

				canvas.addEventListener( 'touchstart', onMouseDown, false );
				canvas.addEventListener( 'touchmove', onMouseMove, false );
				canvas.addEventListener( 'touchend', onMouseUp, false );
				window.addEventListener( 'resize', onWindowResize, false );
				canvas.addEventListener( 'mousedown', onMouseDown, false );
				canvas.addEventListener( 'mousemove', onMouseMove, false );
				canvas.addEventListener( 'mouseup', onMouseUp, false );

			}

			function computeTileUVs( sphere, texSize, aUv, uvZoom ) {

				for ( var i = 0; i < sphere.attributes.id.count; i ++ ) {

					var id = sphere.attributes.id.array[ i ];
					var j = Math.floor( id / texSize );
					var q = ( 1 - 2 * uvZoom ) / texSize;
					var u0 = ( id + uvZoom ) / texSize - j;
					var v0 = 1. - ( j + 1. - uvZoom ) / texSize;

					aUv.array[ 2 * i ] *= q;
					aUv.array[ 2 * i ] += u0;
					aUv.array[ 2 * i + 1 ] *= q;
					aUv.array[ 2 * i + 1 ] += v0;

				}

			}

			function analyticRaycaster( mouse ) {

				var ray = new THREE.Ray();
				ray.origin.setFromMatrixPosition( camera.matrixWorld );
				var x = 2 * mouse.x / window.innerWidth - 1;
				var y = - 2 * mouse.y / window.innerHeight + 1;
				ray.direction.set( x, y, 0.5 ).unproject( camera ).sub( ray.origin ).normalize();

				var a = ray.direction.dot( ray.direction );
				var b = 2 * ray.origin.dot( ray.direction );
				var c = ray.origin.dot( ray.origin ) - radius * radius;
				var D = b * b - 4 * a * c;
				if ( D < 0 ) return ( - 1 );

				var p = new THREE.Vector3();
				var s = ( - b - Math.sqrt( D ) ) / ( 2 * a );
				ray.at( s, p );

				p = new THREE.Spherical().setFromVector3( p );
				p.phi = Math.PI / 2 - p.phi;
				p.theta = ( Math.PI / 2 - p.theta ) % ( 2 * Math.PI );

				var t = p.theta / 2 / turns + Math.PI / turns *
						Math.floor( ( turns * ( Math.PI - 2 * p.phi ) - p.theta ) / ( 2 * Math.PI ) ) - Math.PI / 2;
				return 1 + Math.floor( ( examples.length - 2 ) * ( Math.cos( Math.PI / 2 / turns ) -
						Math.cos( t + ( turns + 1 ) * Math.PI / 2 / turns ) ) / ( 2 * Math.cos( Math.PI / 2 / turns ) ) );

			}

			function savePosition( mouse, e, touches ) {

				mouse.x = ( touches ) ? touches[ 0 ].pageX : e.clientX;
				mouse.y = ( touches ) ? touches[ 0 ].pageY : e.clientY;

			}

			function onMouseDown( e ) {

				onMouseMove( e );
				idDown = idMove;
				isSwipe = false;

			}

			function onMouseMove( e ) {

				e.preventDefault();
				savePosition( mouseMove, e, e.changedTouches );

				idMove = analyticRaycaster( mouseMove );
				canvas.style.cursor = ( idMove < 0 ) ? 'auto' : 'pointer';
				var multitouch = e.touches && e.touches.length > 1;
				isSwipe = ( mouseMove.distanceTo( mouseDown ) > 4 || multitouch );

				if ( mouseMove0.distanceTo( mouseMove ) > 4 ) {

					tooltip.style.display = 'none';
					clearTimeout( tooltipWaiting );
					tooltipWaiting = null;

				}
				if ( ! tooltipWaiting ) {

					tooltipWaiting = setTimeout( function ( ) {

						if ( idMove >= 0 ) {

							tooltip.innerHTML = examples[ idMove ];
							tooltip.style.display = 'block';
							var dy = ( e.touches ) ? - 2 * tooltip.clientHeight : tooltip.clientHeight;
							tooltip.style.left = ( mouseMove.x - ( tooltip.clientWidth - 10 ) / 2 ) + 'px';
							tooltip.style.top = ( mouseMove.y + dy ) + 'px';

						}
						tooltipWaiting = null;

					}, 500 );

				}
				mouseMove0.copy( mouseMove );

			}

			function onMouseUp( e ) {

				savePosition( mouseMove, e, e.changedTouches );
				if ( idMove >= 0 && ! isSwipe ) {

					window.location.href = './' + examples[ idMove ] + '.html';

				}
				tooltip.style.display = 'none';
				clearTimeout( tooltipWaiting );
				tooltipWaiting = null;

			}

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

			}

			function animate( now ) {

				controls.update();
				controls.rotateSpeed = 0.4 * ( camera.position.length() - 0.4 );

				var k = 1 / Math.sqrt( 1 - 1 / camera.position.lengthSq() );
				outline.scale.copy( new THREE.Vector3( k, k, 1 ) );
				outline.lookAt( camera.position );

				for ( var i = 0, attr = sphere.attributes; i < attr.id.count; i ++ ) {

					var dz = ( idMove === attr.id.array[ i ] ) ? zoomSpeed : - zoomSpeed;
					attr.zoom.array[ i ] = Math.max( 0, Math.min( 1, attr.zoom.array[ i ] + dz ) );
					attr.zoom.needsUpdate = true;

				}

				renderer.render( scene, camera );
				requestAnimationFrame( animate );

			}

		</script>

	</body>
</html>
