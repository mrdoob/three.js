<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - per vertex ao</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				color: #000;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				display: block;
			}
			#info a {
				color: #046;
				font-weight: bold;
			}
		</style>
	</head>

	<body>
		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - per vertex ambient occlusion:
			<a href="https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter14.html" target="_blank" rel="noopener">article</a><br>
			<div id="performance"></div>
		</div>

		<script src="../build/three.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<script src="js/controls/OrbitControls.js"></script>

		<script src="js/loaders/GLTFLoader.js"></script>

		<script src="js/WebGL.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>

			if ( WEBGL.isWebGLAvailable() === false ) {

				document.body.appendChild( WEBGL.getWebGLErrorMessage() );

			}

			var container, stats, controls;
			var camera, scene, renderer, model, materials, envMap, shadowLight;

			// 1x256 B/W gradient
			var aoMap = new THREE.TextureLoader().load( 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAABCAYAAAAxWXB3AAAAIElEQVQ4T2NkYGD4z8TExAACo/RoOIymg5GTDxgZGRkA/oMD/vOwS0YAAAAASUVORK5CYII=' );

			init();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 120 );
				camera.position.set( - 1.8, 0.9, 2.7 );

				controls = new THREE.OrbitControls( camera, container );
				controls.target.set( 0, - 0.2, - 0.2 );
				controls.update();

				var path = 'textures/cube/skyboxsun25deg/';
				var format = '.jpg';
				envMap = new THREE.CubeTextureLoader().load( [
					path + 'px' + format, path + 'nx' + format,
					path + 'py' + format, path + 'ny' + format,
					path + 'pz' + format, path + 'nz' + format
				] );

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0xd7cbb1, 1, 80 );
				scene.background = envMap;

				var ground = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 200, 200 ),
					new THREE.ShadowMaterial( { color: 0x000000, opacity: 0.15 }
					) );
				ground.rotation.x = - Math.PI / 2;
				ground.position.y -= 0.9;
				ground.receiveShadow = true;
				scene.add( ground );

				var grid = new THREE.GridHelper( 200, 20, 0x000000, 0x000000 );
				grid.material.opacity = 0.2;
				grid.position.y -= 0.9;
				grid.material.transparent = true;
				scene.add( grid );

				var hemiLight = new THREE.HemisphereLight( 0x7c849b, 0xd7cbb1, 0.1 );
				hemiLight.position.set( 0, 1, 0 );
				scene.add( hemiLight );

				shadowLight = new THREE.DirectionalLight( 0xffffee, 0.1 );
				shadowLight.position.set( - 1.5, 1.25, - 1.5 );
				shadowLight.castShadow = true;
				shadowLight.shadow.width = 1024;
				shadowLight.shadow.height = 1024;
				shadowLight.shadow.camera.top = 1;
				shadowLight.shadow.camera.bottom = - 1;
				shadowLight.shadow.camera.left = - 1.25;
				shadowLight.shadow.camera.right = 0.9;
				shadowLight.shadow.camera.near = 1.25;
				shadowLight.shadow.camera.far = 5.5;
				shadowLight.shadow.bias = 0.001;

				scene.add( shadowLight );

				var loader = new THREE.GLTFLoader();
				loader.load( './models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf', function ( gltf ) {

					model = gltf.scene.getObjectByName( 'node_damagedHelmet_-6514' );
					scene.add( model );

					model.castShadow = true;
					model.receiveShadow = true;

					initMaterials( model.material );
					model.material = materials[ 0 ];

					var time = performance.now();
					calculateAreas( model.geometry );
					var time2 = performance.now();

					var areaTime = Math.floor( time2 - time );
					ambientOcclusion( model.geometry );
					var occlusionTime = Math.floor( performance.now() - time2 );

					var totalTime = Math.floor( performance.now() - time );

					var numVertices = model.geometry.attributes.position.count;
					document.querySelector( '#performance' ).innerHTML = 'Calculation Time (' + numVertices + ' vertices): Surface element areas: ' + areaTime + 'ms. Ambient Occlusion: ' + occlusionTime + 'ms. Total: ' + totalTime + 'ms.';

				} );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.gammaOutput = true;
				renderer.gammaFactor = 2.2;
				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

				stats = new Stats();
				container.appendChild( stats.dom );

				buildGUI();

				renderer.setAnimationLoop( function () {

					renderer.render( scene, camera );
					stats.update();

				} );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function initMaterials( originalMaterial ) {

				originalMaterial.envMap = envMap;
				originalMaterial.aoMap = aoMap;

				materials = [
					new THREE.MeshBasicMaterial( { aoMap: aoMap } ),
					originalMaterial,
				];

			}

			function buildGUI() {

				var gui = new dat.GUI( { width: 300 } );
				gui.open();

				var params = {
					intensity: 1,
					material: 0,
				};

				var controls = gui.addFolder( 'Controls' );
				controls.open();



				controls.add( params, 'intensity', 0, 1 ).name( 'AO intensity' ).onChange( function ( value ) {

					materials.forEach( function ( material ) {

						material.aoMapIntensity = value;

					} );

				} );

				controls.add( params, 'material', {

					'AO': 0,
					'Standard + AO': 1

				} ).name( 'Material' ).onChange( function () {

					var num = parseInt( params.material );

					// enable envMap by default for original material
					if ( num === 3 ) {

						materials[ num ].envMap = envMap;
						params.envMap = true;

					} else {

						params.envMap = ( materials[ num ].envMap === null ) ? false : true;

					}
					model.material = materials[ num ];
					model.material.needsUpdate = true;

				} );

			}

			function getAllIndexes( arr, val ) {

				var indices = [];
				for ( var i = 0; i < arr.length; i ++ ) {

					if ( arr[ i ] === val ) indices.push( i );

				}

				return indices;

			}

			// amount of occlusion from emitter surface to reciever surface
			function solidAngle( v, d2, receiverNormal, emitterNormal, emitterArea ) {

				var dotR = THREE.Math.clamp( receiverNormal.dot( v ), 0, 1 );
				var dotE = THREE.Math.clamp( emitterNormal.dot( v.negate() ), 0, 1 );

				return emitterArea * dotE * dotR / ( d2 + emitterArea / Math.PI ) / Math.PI;

			}

			// calculate the area of a disk around each vertex as the weighted sum of the area
			// of each polygon it is a member of.
			// Note:  the method used here requires indexed geometry.
			function calculateAreas( geometry ) {

				var edge1 = new THREE.Vector3();
				var edge2 = new THREE.Vector3();

				var positions = geometry.attributes.position.array;
				var indices = geometry.index.array;

				var encounteredIndices = [];

				var areas = [];

				// for each vertex, the area is calculated as the weighted sum of the area of each face it is a member of
				indices.forEach( function ( pIndex ) {

					if ( encounteredIndices[ pIndex ] === 'x' ) return;
					encounteredIndices[ pIndex ] = 'x'; // mark an 'x' for each index we have processed

					// find all faces the vertex is a member of
					var allIndices = getAllIndexes( indices, pIndex );

					areas[ pIndex ] = 0;
					allIndices.forEach( function ( j ) {

						var edge1Index;
						var edge2Index;

						if ( j % 3 === 0 ) { // j is first index in face

							edge1Index = indices[ j + 1 ];
							edge2Index = indices[ j + 2 ];

						} else if ( j % 3 === 1 ) { // j is second index in face

							edge1Index = indices[ j - 1 ];
							edge2Index = indices[ j + 1 ];

						} else { // j is last index in face

							edge1Index = indices[ j - 1 ];
							edge2Index = indices[ j - 2 ];

						}

						edge1.set(
							positions[ pIndex * 3 ] - positions[ edge1Index * 3 ],
							positions[ pIndex * 3 + 1 ] - positions[ edge1Index * 3 + 1 ],
							positions[ pIndex * 3 + 2 ] - positions[ edge1Index * 3 + 2 ]
						);

						edge2.set(
							positions[ pIndex * 3 ] - positions[ edge2Index * 3 ],
							positions[ pIndex * 3 + 1 ] - positions[ edge2Index * 3 + 1 ],
							positions[ pIndex * 3 + 2 ] - positions[ edge2Index * 3 + 2 ]
						);

						areas[ pIndex ] += 0.5 * edge1.cross( edge2 ).length();

					} );

					areas[ pIndex ] /= 3;

				} );

				geometry.addAttribute( 'area', new THREE.Float32BufferAttribute( areas, 1 ) );

			}

			function ambientOcclusion( geometry ) {

				var ao = [];

				var positions = geometry.attributes.position.array;
				var normals = geometry.attributes.normal.array;
				var bentNormals = normals.slice();
				var areas = geometry.attributes.area.array;

				var receiver = new THREE.Vector3();
				var receiverNormal = new THREE.Vector3();

				var emitter = new THREE.Vector3();
				var emitterNormal = new THREE.Vector3();

				var bentNormal = new THREE.Vector3();

				var v = new THREE.Vector3();

				function computeVertexOcclusion() {

					var value = 0;

					for ( var j = 0; j < positions.length; j += 3 ) {

						var emitterArea = areas[ j / 3 ];

						emitter.fromArray( positions, j );
						emitterNormal.fromArray( normals, j );

						v.subVectors( emitter, receiver );

						var d2 = v.dot( v ) + 1e-16;

						if ( d2 < 4 * emitterArea ) {

							v.multiplyScalar( 1 / Math.sqrt( d2 ) ); // normalise

							value += solidAngle( v, d2, receiverNormal, emitterNormal, emitterArea );

							bentNormal.sub( v.multiplyScalar( value ) );

						}

					}

					bentNormal.normalize();
					return THREE.Math.clamp( 1 - value, 0, 1 );

				}

				// loop over each vertex
				for ( var i = 0; i < positions.length; i += 3 ) {

					receiver.fromArray( positions, i );
					receiverNormal.fromArray( normals, i );

					if ( bentNormals[ i ] ) receiverNormal.fromArray( bentNormals, i );
					else bentNormal.copy( receiverNormal ); // initialise

					// initialise to 1
					if ( ! ao[ i / 3 ] ) ao[ i / 3 ] = 1;

					var value = computeVertexOcclusion( i );

					bentNormal.toArray( bentNormals, i );

					ao[ i / 3 ] *= value;

				}

				// ignoring bent normals for now since with a single pass they don't improve appearance of the current model
				// geometry.attributes.normal.set( bentNormals );

				var uv2Data = new Float32Array( ao.length * 2 );

				for ( var i = 0; i < ao.length; i ++ ) {

					uv2Data[ i * 2 ] = uv2Data[ i * 2 + 1 ] = ao[ i ];

				}

				geometry.addAttribute( 'uv2', new THREE.BufferAttribute( uv2Data, 2 ) );

			}

		</script>

	</body>
</html>
