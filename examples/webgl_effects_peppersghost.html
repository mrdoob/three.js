<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - effects - peppers ghost</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

			<div id="info">
				<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - <a href="https://en.wikipedia.org/wiki/Pepper%27s_ghost">peppers ghost effect</a> demo <br />
				<a href="http://www.instructables.com/id/Reflective-Prism/?ALLSTEPS" target="_blank" rel="noopener">how to build the reflective prism</a>
			</div>

		<script src="../build/three.js"></script>
		<script src="js/effects/PeppersGhostEffect.js"></script>
		<script src="js/WebGL.js"></script>

		<script>

				if ( WEBGL.isWebGLAvailable() === false ) {

					document.body.appendChild( WEBGL.getWebGLErrorMessage() );

				}

				var container;

				var camera, scene, renderer, effect;
				var group;

				init();
				animate();

				function init() {

					container = document.createElement( 'div' );
					document.body.appendChild( container );

					camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 100000 );

					scene = new THREE.Scene();

					group = new THREE.Group();
					scene.add( group );

					// Cube

					var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
					geometry = geometry.toNonIndexed(); // ensure unique vertices for each triangle

					var position = geometry.attributes.position;
					var colors = [];
					var color = new THREE.Color();

					// generate for each side of the cube a different color

					for ( var i = 0; i < position.count; i += 6 ) {

						color.setHex( Math.random() * 0xffffff );

						// first face

						colors.push( color.r, color.g, color.b );
						colors.push( color.r, color.g, color.b );
						colors.push( color.r, color.g, color.b );

						// second face

						colors.push( color.r, color.g, color.b );
						colors.push( color.r, color.g, color.b );
						colors.push( color.r, color.g, color.b );

					}

					geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

					var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } );

					for ( var i = 0; i < 10; i ++ ) {

						var cube = new THREE.Mesh( geometry, material );
						cube.position.x = Math.random() * 2 - 1;
						cube.position.y = Math.random() * 2 - 1;
						cube.position.z = Math.random() * 2 - 1;
						cube.scale.multiplyScalar( Math.random() + 0.5 );
						group.add( cube );

					}

					renderer = new THREE.WebGLRenderer();
					renderer.setPixelRatio( window.devicePixelRatio );
					container.appendChild( renderer.domElement );

					effect = new THREE.PeppersGhostEffect( renderer );
					effect.setSize( window.innerWidth, window.innerHeight );
					effect.cameraDistance = 5;

					window.addEventListener( 'resize', onWindowResize, false );

				}

				function onWindowResize() {

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					effect.setSize( window.innerWidth, window.innerHeight );

				}

				function animate() {

					requestAnimationFrame( animate );

					group.rotation.y += 0.01;

					effect.render( scene, camera );

				}

		</script>

	</body>
</html>
