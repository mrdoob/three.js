<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Three.js WebGPU - Procedural Wood Materials</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <meta name="author" content="Logan Seeley"/>

        <link type="text/css" rel="stylesheet" href="main.css">
        <style>
            body {color:white;}
            #info a {
                color:#1cdfe2;
            }
            </style>
    </head>
    <body>
        <div id="info">
            <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgpu - procedural wood materials<br/>Scene by Logan Seeley, Blender tutorial by Lance Phan
        </div>

        <script type="importmap">
            {
                "imports": {
                    "three": "../build/three.webgpu.js",
                    "three/webgpu": "../build/three.webgpu.js",
                    "three/tsl": "../build/three.tsl.js",
                    "three/addons/": "./jsm/"
                }
            }
        </script>

        <script type="module">
            import * as THREE from "three";
            import * as TSL from "three/tsl";
            import Stats from "three/addons/libs/stats.module.js";
            import { OrbitControls } from "three/addons/controls/OrbitControls.js";
            import { HDRLoader } from "three/addons/loaders/HDRLoader.js";
            import { FontLoader } from "three/addons/loaders/FontLoader.js";
            import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
            import { RoundedBoxGeometry } from "three/addons/geometries/RoundedBoxGeometry.js";
            import { GenerateWoodMaterial, GetWoodPreset, WoodTypes, FinishTypes } from "three/addons/materials/ProceduralWood.js";

            let scene, camera, renderer, controls, canvas, stats, font;

            async function init() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color("#333333");

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(-6, 0, 0);

                renderer = new THREE.WebGPURenderer({ antialias: true });
                renderer.setPixelRatio(1.0); // important for performance
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.toneMapping = THREE.NeutralToneMapping;
                renderer.toneMappingExposure = 1;
                document.body.appendChild(renderer.domElement);

                canvas = document.querySelector("canvas");
                controls = new OrbitControls(camera, canvas);
                controls.target.set(0, 0, 0);

                stats = new Stats();
                document.body.appendChild(stats.dom);

                const hdr_loader = new HDRLoader();
                
                const directional_light = new THREE.DirectionalLight(0xfdfdfd, 3);
                directional_light.position.set(-1, 0, 0);
                scene.add(directional_light);
                
                font = await new FontLoader().loadAsync("./fonts/helvetiker_regular.typeface.json");

                const text_mat = new THREE.MeshStandardMaterial();
                text_mat.colorNode = TSL.color("#fdfdfd");  

                new HDRLoader().load("./textures/equirectangular/royal_esplanade_1k.hdr", async (env_map) =>
                {
                    env_map.mapping = THREE.EquirectangularReflectionMapping;

                    scene.background = env_map;
                    scene.environment = env_map;
                    scene.environmentIntensity = 1;

                    for (let x = 0; x < WoodTypes.length; x++)
                    {
                        await add_wood(x, text_mat);
                    }
                });

                for (let y = 0; y < FinishTypes.length; y++) {
                    const txt_geo = new TextGeometry(FinishTypes[y], {
                        font: font,
                        size: 0.1,
                        depth: 0.001,
                        curveSegments: 12,
                        bevelEnabled: false
                    });
                    
                    txt_geo.computeBoundingBox();
                    const offx = -0.5 * (txt_geo.boundingBox.max.x - txt_geo.boundingBox.min.x);
                    const offy = -0.5 * (txt_geo.boundingBox.max.y - txt_geo.boundingBox.min.y);
                    const offz = -0.5 * (txt_geo.boundingBox.max.z - txt_geo.boundingBox.min.z);
                    txt_geo.translate(offx, offy, offz);

                    const txt = new THREE.Mesh(txt_geo, text_mat);
                    txt.position.set(0, y - FinishTypes.length/2, -WoodTypes.length/2 + 0.45 - 1);
                    txt.rotateY(-Math.PI/2);
                    scene.add(txt);
                }

                renderer.setAnimationLoop(render);
            }

            function render() {
                controls.update();
                stats.update();
                renderer.renderAsync(scene, camera);
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            if (navigator.gpu)
            {
                init();
            }
            else
            {
                document.body.innerHTML = '<div id="info">WebGPU is not supported in this browser.</div>';
            }

            async function add_wood(x, text_mat)
            {
                const txt_geo = new TextGeometry(WoodTypes[x],
                {
                    font: font,
                    size: 0.1,
                    depth: 0.001,
                    curveSegments: 12,
                    bevelEnabled: false
                });
                
                txt_geo.computeBoundingBox();
                const offx = -0.5 * (txt_geo.boundingBox.max.x - txt_geo.boundingBox.min.x);
                const offy = -0.5 * (txt_geo.boundingBox.max.y - txt_geo.boundingBox.min.y);
                const offz = -0.5 * (txt_geo.boundingBox.max.z - txt_geo.boundingBox.min.z);
                txt_geo.translate(offx, offy, offz);

                const txt = new THREE.Mesh(txt_geo, text_mat);
                txt.position.set(0, FinishTypes.length/2 - 0.25, x - WoodTypes.length/2 + 0.45);
                txt.rotateY(-Math.PI/2);
                scene.add(txt);

                for (let y = 0; y < FinishTypes.length; y++)
                {
                    const geometry = new RoundedBoxGeometry(0.125, 0.9, 0.9, 10, 0.02);
                    const position =
                    {
                        x: 0,
                        y: y - FinishTypes.length/2,
                        z: x - WoodTypes.length/2 + 0.45
                    };
                    
                    const cube = new THREE.Mesh(geometry, GenerateWoodMaterial(GetWoodPreset(WoodTypes[x], FinishTypes[y])));
                    cube.position.set(position.x, position.y, position.z);
                    scene.add(cube);
                }
            }
        </script>
    </body>
</html>