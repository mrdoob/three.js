<html lang="en">
	<head>
		<title>three.js webgpu - compute reduction</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			<br /> This example demonstrates the performance of various simple parallel reduction kernels.
			<br /> Reference implementations are translated from the CUDA code present in the following books/repos:
			<br /> <a href="https://www.cambridge.org/core/books/programming-in-parallel-with-cuda/C43652A69033C25AD6933368CDBE084C"><i>Programming in Parallel with CUDA</i></a> by <a href="https://people.bss.phy.cam.ac.uk/~rea1/">Richard Ansorge</a>
			<br />
			<div id="left_side_display" style="position: absolute;top: 150px;left: 0;padding: 10px;background: rgba( 0, 0, 0, 0.5 );color: #fff;font-family: monospace;font-size: 12px;line-height: 1.5;pointer-events: none;text-align: left;"></div>
			<div id="right_side_display" style="position: absolute;top: 150px;right: 0;padding: 10px;background: rgba( 0, 0, 0, 0.5 );color: #fff;font-family: monospace;font-size: 12px;line-height: 1.5;pointer-events: none;text-align: left;"></div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { instancedArray, Loop, If, vec3, nativeSelect, arrayLength, int, atomicStore, subgroupAdd, select, uvec4, atomicAdd, dot, uniform, uv, uint, float, Fn, vec2, invocationLocalIndex, invocationSubgroupIndex, uvec2, floor, instanceIndex, workgroupId, workgroupBarrier, workgroupArray, subgroupIndex, subgroupShuffleDown, subgroupSize, countTrailingZeros } from 'three/tsl';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			const timestamps = {
				left_side_display: document.getElementById( 'left_side_display' ),
				right_side_display: document.getElementById( 'right_side_display' )
			};

			// Total number of elements and the dimensions of the display grid.
			const size = 262144;
			const gridDim = Math.sqrt( size );
			let maxWorkgroupSize = 64;

			// Algorithm speed increase as you iterate through algorithms array
			const algorithms = [
				'Reduce 0 (N/2)',
				'Reduce 1 (Naive Accumulate)',
				'Reduce 2 (Workgroup Reduction)',
				'Reduce 3 (Simple Shuffle)',
				'Incorrect Baseline',
			];

			const displayModes = [ 'Entire Grid', 'Logarithmic' ];

			const unifiedEffectController = {
				// Number of elements in the grid
				gridElementWidth: uniform( gridDim ),
				gridElementHeight: uniform( gridDim ),
				// Number of elements in the grid being displayed
				gridDisplayWidth: uniform( gridDim ),
				gridDisplayHeight: uniform( gridDim ),
				'Display Mode': 'Logarithmic',
				loggedBuffer: 'Data Buffer',
			};
			

			const leftEffectController = {
				algo: 'Reduce 0 (N/2)',
				highlight: uniform( 0 ),
				currentAlgo: uniform( 0 ),
				state: 'Run Algo',
				numThreadsDispatched: uniform( size / 2 ),
			};

			const leftMaterial = null;

			const rightEffectController = {
				algo: 'Reduce 0 (N/2)',
				currentAlgo: uniform( 0 ),
				highlight: uniform( 0 ),
				state: 'Run Algo',
				numThreadsDispatched: uniform( size / 2 )
			};

			const rightMaterial = null;
			
			// https://medium.com/@rimikadhara/7-step-optimization-of-parallel-reduction-with-cuda-33a3b2feafd8
			// https://superjomn.github.io/posts/reduce-cuda/

			const gui = new GUI();

			gui.add( leftEffectController, 'algo', algorithms ).onChange( () => {

				leftEffectController.currentAlgo.value = algorithms.findIndex( val => val === leftEffectController.algo );
			

			} );

			gui.add( rightEffectController, 'algo', algorithms ).onChange( () => {

				rightEffectController.currentAlgo.value = algorithms.findIndex( val => val === rightEffectController.algo );

			} );

			gui.add( unifiedEffectController, 'Display Mode', displayModes ).onChange( () => {

				switch ( unifiedEffectController[ 'Display Mode' ] ) {

					case 'Entire Grid': {

						unifiedEffectController.gridDisplayWidth.value = gridDim;
						unifiedEffectController.gridDisplayHeight.value = gridDim;

						break;

					}

					case 'Workgroup 0': {

						unifiedEffectController.gridDisplayWidth.value = Math.sqrt( maxWorkgroupSize );
						unifiedEffectController.gridDisplayHeight.value = Math.sqrt( maxWorkgroupSize );

						break;

			
					}

				}
			
			} );

			const stateLeftController = gui.add( leftEffectController, 'state' ).name( 'Left Display State' );
			stateLeftController.domElement.style.pointerEvents = 'none';
			const stateRightController = gui.add( rightEffectController, 'state' ).name( 'Right Display State' );
			stateRightController.domElement.style.pointerEvents = 'none';
			const leftCPUArray = null;
			const rightCPUArray = null;

			const debugFolder = gui.addFolder( 'Debug' );
			debugFolder.add( unifiedEffectController, 'loggedBuffer', [ 'Data Buffer', 'Workgroup Sums Buffer', 'Accumulation Buffer' ] ).name( 'Logged Buffer' );

			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );

				throw new Error( 'No WebGPU support' );

			}

			const serialAlgorithm = ( arr ) => {

				const t0 = performance.now();
			
				for ( let i = 0; i < size - 1; i ++ ) {

					arr[ i + 1 ] += i;

				}

				const t1 = performance.now();

				return ( t1 - t0 ).toFixed( 2 );

			};

			const serialAlgorithmNativeReduce = ( arr ) => {

				const t0 = performance.now();
			
				arr.reduce( ( acc, val ) => acc + val, 0 );

				const t1 = performance.now();

				return ( t1 - t0 ).toFixed( 2 );

			
			};

			init();

			init( false );

			async function init( leftSideDisplay = true ) {

				const effectController = leftSideDisplay ? leftEffectController : rightEffectController;

				const aspect = ( window.innerWidth / 2 ) / window.innerHeight;
				const camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				const scene = new THREE.Scene();

				const array = new Uint32Array( Array.from( { length: size }, ( _, i ) => {

					return i + 1;

				} ) );

			


				const currentStorage = instancedArray( array, 'uint', size ).setPBO( true ).label( `Current_${leftSideDisplay ? 'Left' : 'Right'}` );
				const workgroupSums = instancedArray( new Uint32Array( 256 ), 'uint', 256 ).setPBO( true ).label( `WorkgroupSums_${leftSideDisplay ? 'Left' : 'Right'}` );
				const atomicAccumulator = instancedArray( new Uint32Array( 1 ), 'uint' ).setPBO( true ).toAtomic();

				const buffers = {
					'Data Buffer': currentStorage,
					'Workgroup Sums Buffer': workgroupSums,
					'Accumulation Buffer': atomicAccumulator,
				};
				// Result array for future two buffer/ping-pong buffer approach
				// const resultStorage = instancedArray( new Uint32Array( size ), 'uint' ).setPBO( true ).label( 'Result' );

				const logFunctionName = `Log ${leftSideDisplay ? 'Left' : 'Right'} Side`;
				const functionObj = {};
				functionObj[ logFunctionName ] = async() => {

					const selectedBuffer = buffers[ unifiedEffectController.loggedBuffer ];
					console.log( new Uint32Array( await renderer.getArrayBufferAsync( selectedBuffer.value ) ) );

				};

				debugFolder.add( functionObj, `Log ${leftSideDisplay ? 'Left' : 'Right'} Side` );

				const computeResetBufferFn = Fn( () => {

					currentStorage.element( instanceIndex ).assign( 1 );
			
				} );

				const computeResetWorkgroupSumsFn = Fn( () => {

					workgroupSums.element( instanceIndex ).assign( 0 );
					atomicStore( atomicAccumulator.element( 0 ), 0 );

				} );

				// Re-initialize compute buffer
				const computeResetBuffer = computeResetBufferFn().compute( size );
				const computeResetWorkgroupSums = computeResetWorkgroupSumsFn().compute( 256 );

				const renderer = new THREE.WebGPURenderer( { antialias: false, trackTimestamp: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth / 2, window.innerHeight );

				await renderer.computeAsync( computeResetBuffer );

				if ( renderer.backend.device !== null ) {

					maxWorkgroupSize = renderer.backend.device.limits.maxComputeWorkgroupSizeX;

				}

				// Create and store dispatches of reduction of certain size. Map each set of dispatches to algorithm name.

				const computeReduce0Fn = Fn( () => {

					const { numThreadsDispatched } = effectController;

					currentStorage.element( instanceIndex ).addAssign( currentStorage.element( instanceIndex.add( numThreadsDispatched ) ) );

				} )();

				const reduce0Calls = [];

				for ( let i = size / 2; i >= 1; i /= 2 ) {

					const reduce0 = computeReduce0Fn.compute( i, [ maxWorkgroupSize ] );
					reduce0Calls.push( reduce0 );

				}

				// Thanks to Sam0oneau of Graphics Programming Discord for the explanation.
				// (Graphics Programming Discord Message Link): https://discord.com/channels/318590007881236480/374061825454768129/1391248956171882597

				const createReduce1Fn = ( dispatch, numElements ) => {

					const fnDef = Fn( () => {

						//const dispatchSize = uint( dispatch ).toVar( 'dispatchSize' );
						const tSum = uint( 0 ).toVar();
						const k = instanceIndex.toVar( 'k' );

						Loop( k.lessThan( uint( numElements ) ), ( ) => {

							tSum.addAssign( currentStorage.element( k ) );
							k.addAssign( uint( dispatch ) );

						} );

						currentStorage.element( instanceIndex ).assign( tSum );


					} )();

					return fnDef;
			
				};

				/* Reduce 1 Example (Assume Workgroup Size 256, numElements: 262144) -> Initial currentBuffer State: | 1, 1, 1, 1, ... |
				 *
				 * KERNEL 1:
				 * Executes 256 threads by 256 workgroups. Each thread loops 4 times and accesses elements
				 * at the indices below.
				 *          Thread 1                        Thread 2                         Thread 3
				 * | 0, 65536, ..., n * 65536 | 1, 65537, .... (n * 65536) + 1 | 1, 65538, .... (n * 65536) + 2 | etc
				 * Buffer Values: | 4, 4, 4, 4, ...|
				 *
				 * KERNEL 2:
				 * Executes 256 threads by one workgroup. Each thread loops 1024 times
				 *          Thread 1                     Thread 2                     Thread 3
				 * | 0, 256, ...., n * 256    | 1, 257, ... (n * 256) + 1 | 2, 258, ... (n * 256) + 3 | etc
				 * Buffer Values: | 1024, 1024, 1024, 1024, ... |
				 *
				 * KERNEL 3:
				 * Executes 1 thread by one workgroup. Single thread loops 256 times
				 *          Thread 1
				 * | 0, 1, 2, 3, 4, 5, 6 ... etc|
				 * Buffer Values: [262144, 1024, 1024]
				 */

				const reduce1Calls = [
					// Accumulation
					createReduce1Fn( maxWorkgroupSize * maxWorkgroupSize, size ).compute( maxWorkgroupSize * maxWorkgroupSize, [ maxWorkgroupSize ] ),
					// 1 Block accumulation
					createReduce1Fn( maxWorkgroupSize, maxWorkgroupSize * maxWorkgroupSize ).compute( maxWorkgroupSize, [ maxWorkgroupSize ] ),
					// Final result
					createReduce1Fn( 1, maxWorkgroupSize ).compute( 1, [ 1 ] ),
				];

				const pow2Ceil = Fn( ( [ x ] ) => {

					If( x.equal( uint( 0 ) ), () => {

						return uint( 1 );

					} );

					const val = x.sub( 1 ).toVar( 'val' );
					val.assign( val.bitOr( val.shiftRight( 1 ) ) );
					val.assign( val.bitOr( val.shiftRight( 2 ) ) );
					val.assign( val.bitOr( val.shiftRight( 4 ) ) );
					val.assign( val.bitOr( val.shiftRight( 8 ) ) );
					val.assign( val.bitOr( val.shiftRight( 16 ) ) );
					return val.add( 1 );

				} ).setLayout( {
					name: 'pow2Ceil',
					type: 'uint',
					inputs: [
						{ name: 'x', type: 'uint' }
					]
				} );

				// For non power of 2 # of workgroups
				const createReduce2Fn = ( workgroupSize, dispatch, numElements ) => {

					const fnDef = Fn( () => {

						const tSum = workgroupArray( 'uint', workgroupSize );

						const k = instanceIndex.toVar( 'k' );
						tSum.element( invocationLocalIndex ).assign( uint( 0 ) );

						Loop( k.lessThan( uint( numElements ) ), () => {

							tSum.element( invocationLocalIndex ).addAssign( currentStorage.element( k ) );

							k.addAssign( uint( dispatch ) );

						} );

						workgroupBarrier();

						// Reset the loop condition (account for numWorkgroups % 2 != 0)
						k.assign( pow2Ceil( uint( workgroupSize ) ).div( 2 ) );

						Loop( k.greaterThan( 0 ), () => {

							If( invocationLocalIndex.lessThan( k ).and( invocationLocalIndex.add( k ).lessThan( workgroupSize ) ), () => {

								tSum.element( invocationLocalIndex ).addAssign( tSum.element( invocationLocalIndex.add( k ) ) );

							} );
							workgroupBarrier();
							k.divAssign( 2 );

						} );

						If( invocationLocalIndex.equal( uint( 0 ) ), () => {

							currentStorage.element( workgroupId.x ).assign( tSum.element( uint( 0 ) ) );

						} );

					} )();

					return fnDef;

				};

				const reduce2Calls = [

					// Accumulate within workgroups
					createReduce2Fn( maxWorkgroupSize, maxWorkgroupSize * maxWorkgroupSize, size ).compute( maxWorkgroupSize * maxWorkgroupSize, [ maxWorkgroupSize ] ),
					// 1 Block accumulation
					createReduce2Fn( maxWorkgroupSize, maxWorkgroupSize, maxWorkgroupSize ).compute( maxWorkgroupSize, [ maxWorkgroupSize ] ),

				];


				const createWorkgroupSyncBlock = ( workgroupSize, blockSize, tSum ) => {

					If(
						workgroupSize.greaterThan( blockSize ).and(
							invocationLocalIndex.lessThan( blockSize )
						).and(
							invocationLocalIndex.add( blockSize ).lessThan( workgroupSize )
						),
						() => {

							tSum.element( invocationLocalIndex ).addAssign( tSum.element( invocationLocalIndex.add( blockSize ) ) );
			
						}
					);

					workgroupBarrier();
			
				};

				const createReduce3Fn = ( workgroupSize, dispatch, numElements ) => {

					const fnDef = Fn( () => {

						const WORKGROUP_SIZE = uint( workgroupSize );
						const DISPATCH = uint( dispatch );
						const DISPATCHED_WORKGROUPS = uint( 256 ); // # of elements in maxworkgroupSize * maxWorkgroupSize so 256 workgroups dispatched
						const NUM_ELEMENTS = uint( numElements );

						const tSum = workgroupArray( 'uint', workgroupSize );

						const k = instanceIndex.toVar( 'k' );
						tSum.element( invocationLocalIndex ).assign( uint( 0 ) );

						Loop( k.lessThan( NUM_ELEMENTS ), () => {

							tSum.element( invocationLocalIndex ).addAssign( currentStorage.element( k ) );

							k.addAssign( DISPATCH );

						} );

						workgroupBarrier();

						// Reset the loop condition (account for numWorkgroups % 2 != 0)
						k.assign( pow2Ceil( WORKGROUP_SIZE ).div( 2 ) );

						createWorkgroupSyncBlock( WORKGROUP_SIZE, 128, tSum );
						createWorkgroupSyncBlock( WORKGROUP_SIZE, 64, tSum );
						createWorkgroupSyncBlock( WORKGROUP_SIZE, 32, tSum );

						// Icd Dmagine a tiled partition of 32 threads/invocations whose parent is a 256 invocation block/workgroup
						// Each workgroup contains 8 subgroups/warps
						// In this case, we only want to operate within the first warp
						// of each workgroup

						// Equivalent to CUDA function meta_group_rank
						const subgroupMetaRank = ( invocationLocalIndex.mod( WORKGROUP_SIZE ) ).div( subgroupSize );

						const isFirstSubgroup = subgroupMetaRank.equal( 0 ).toVar( 'isFirstSubgroup' );

						// No need to sync within warp as warp operations inherently execute in parallel
						tSum.element( invocationLocalIndex ).addAssign( subgroupShuffleDown(
							nativeSelect( uint( 0 ), tSum.element( invocationLocalIndex ), isFirstSubgroup ),
							16
						) );
						tSum.element( invocationLocalIndex ).addAssign( subgroupShuffleDown(
							nativeSelect( uint( 0 ), tSum.element( invocationLocalIndex ), isFirstSubgroup ),
							8
						) );
						tSum.element( invocationLocalIndex ).addAssign( subgroupShuffleDown(
							nativeSelect( uint( 0 ), tSum.element( invocationLocalIndex ), isFirstSubgroup ),
							4
						) );
						tSum.element( invocationLocalIndex ).addAssign( subgroupShuffleDown(
							nativeSelect( uint( 0 ), tSum.element( invocationLocalIndex ), isFirstSubgroup ),
							2
						) );
						tSum.element( invocationLocalIndex ).addAssign( subgroupShuffleDown(
							nativeSelect( uint( 0 ), tSum.element( invocationLocalIndex ), isFirstSubgroup ),
							1
						) );

						If( invocationLocalIndex.equal( uint( 0 ) ), () => {

							workgroupSums.element( workgroupId.x ).assign( tSum.element( uint( 0 ) ) );
			
						} );

					} )();

					return fnDef;

				};

				const accumulateFn = Fn( () => {

					atomicAdd( atomicAccumulator.element( 0 ), workgroupSums.element( instanceIndex ) );

				} );

				const reduce3Calls = [
					createReduce3Fn( maxWorkgroupSize, maxWorkgroupSize * maxWorkgroupSize, size ).compute( maxWorkgroupSize * maxWorkgroupSize, [ maxWorkgroupSize ] ),
					accumulateFn().compute( 256, [ maxWorkgroupSize ] )
				];


				// Work Per Thread
				// numRows: 4 * 32 = 128
				// workgroupSize2ndPass = 32

				const workPerThread = 4;
				const numRows = workPerThread * 32;
				console.log( numRows );
				const rowSize = divRoundUp( size, numRows );
				console.log( rowSize );

				const intermediateArray = new Uint32Array( numRows );
				const intermediateBuffer = instancedArray( intermediateArray, 'uint', numRows );

				// Run with workgroupSize of 256 in the first pass
				// workgroups size of workgroupSize2ndPass in the second pass
				// For some reason the number of workgroups is dispatched in the y dimension, rather than the x.

				// 2041 row Size

				// 2041 / 256

				const RowReduce = ( currentStorage ) => {


				};


				const reduce4Fn = Fn( () => {

					const ROW_SIZE = uint( rowSize );
					const WORKGROUP_SIZE = uint( maxWorkgroupSize );
					const WORK_PER_THREAD = uint( 4 );

					const inputSize = arrayLength( currentStorage );
					const row = workgroupId.x.mul( ROW_SIZE );


					// If the current rows elements exceed the bounds of the input
					// Select either 0 or number of elements left,
					// otherwise, select existing ROW_SIZE
					const currentRowSize = nativeSelect(
						ROW_SIZE,
						nativeSelect( 0, inputSize.sub( row ), inputSize.greaterThan( row ) ),
						( row.add( ROW_SIZE ) ).greaterThan( inputSize )
					);

					const total = uint( 0 ).toVar( 'total' );

					const blockSize = WORKGROUP_SIZE.mul( workPerThread );
					const block = uint( 0 ).toVar( 'block' );
					const blockLimiter = ROW_SIZE.DIV( blockSize ).toVar( 'blockLimiter' );
					Loop( block.lessThan( blockLimiter ), () => {

						const idx = block.mul( blockSize ).add( invocationLocalIndex.mul( workPerThread ) );
						const i = uint( 0 ).toVar( 'readOffset' );
						Loop( i.lessThan( WORK_PER_THREAD ), () => {

			
						} );


			
					} );


					total.assign( subgroupAdd( total ) );

					const delta = WORKGROUP_SIZE.div( subgroupSize ).toVar( 'delta' );

					const subgroupMetaRank = invocationLocalIndex.div( subgroupSize );


					Loop( float( delta ).greaterThan( 1.0 ), () => {

						If( invocationSubgroupIndex.assign( 0 ), () => {
			
							workgroupSums.element( subgroupMetaRank ).assign( total );

						} );

						workgroupBarrier();

						total.assign( nativeSelect( 0, workgroupSums.element( invocationLocalIndex ), invocationLocalIndex.lessThan( delta ) ) );
						total.assign( subgroupAdd( total ) );

						delta.divAssign( subgroupSize );

					} );

				} );


				const divRoundUp = ( size, part_size ) => {

					Math.floor( ( size + part_size - 1 ) / part_size );

				};

				const createIncorrectBaselineFn = () => {

					const fnDef = Fn( () => {

						currentStorage.element( instanceIndex ).assign( 99999 );

					} )();

					return fnDef;
			
				};

				const incorrectBaselineCalls = [
					createIncorrectBaselineFn().compute( size ),
				];

				const calls = {
					'Reduce 0 (N/2)': reduce0Calls,
					'Reduce 1 (Naive Accumulate)': reduce1Calls,
					'Reduce 2 (Workgroup Reduction)': reduce2Calls,
					'Reduce 3 (Simple Shuffle)': reduce3Calls,
					'Incorrect Baseline': incorrectBaselineCalls
				};

				const material = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );

				const getColor = ( bufferToCheck, colorChanger, width, height ) => {

					const subtracter = float( colorChanger ).div( width.mul( height ) );

					const color = vec3( subtracter.oneMinus() ).toVar();

					const { highlight } = effectController;

					// Validate that element 0 is equal to expected result of reduction
					If( highlight.equal( 1 ), () => {

						If( ( bufferToCheck.element( 0 ) ).equal( size ), () => {

							color.assign( vec3( 0.0, subtracter.oneMinus(), 0.0 ) );

						} ).Else( () => {

							color.assign( vec3( subtracter.oneMinus(), 0.0, 0.0 ) );

						} );

					} );

					return color;

				};

				const displayColorNodes = {

					'Entire Grid': Fn( () => {

						const { gridElementWidth, gridElementHeight, gridDisplayWidth, gridDisplayHeight } = unifiedEffectController;
						const { currentAlgo } = effectController;

						const newUV = uv().mul( vec2( gridDisplayWidth, gridDisplayHeight ) );

						const pixel = uvec2( uint( floor( newUV.x ) ), uint( floor( newUV.y ) ) );

						const elementIndex = uint( gridDisplayWidth ).mul( pixel.y ).add( pixel.x );

						const colorChanger = uint( 0 ).toVar();
						const color = vec3( 0 ).toVar( 'color' );

						If( currentAlgo.equal( 3 ), () => {

							// Workgroup Sums condition

							colorChanger.assign( workgroupSums.element( 0 ) );
							color.assign( getColor( workgroupSums, colorChanger, gridElementWidth, gridElementHeight ) );

						} ).Else( () => {

							colorChanger.assign( currentStorage.element( elementIndex ) );
							color.assign( getColor( currentStorage, colorChanger, gridElementWidth, gridElementHeight ) );

						} );

						return color;

					} )(),

					'Logarithmic': Fn( () => {

						const { gridElementWidth, gridElementHeight } = unifiedEffectController;
						const { currentAlgo } = effectController;

						const newUV = uv().mul( vec2( Math.log2( size ) ), 1 );

						const colorChanger = uint( 0 ).toVar();
						const color = vec3( 0 ).toVar( 'color' );

						If( currentAlgo.equal( 3 ), () => {

							// Workgroup Sums condition

							colorChanger.assign( workgroupSums.element( 0 ) );
							color.assign( getColor( workgroupSums, colorChanger, gridElementWidth, gridElementHeight ) );

						} ).Else( () => {

							colorChanger.assign( currentStorage.element( uint( 1 ).shiftLeft( newUV.x ) ) );
							color.assign( getColor( currentStorage, colorChanger, gridElementWidth, gridElementHeight ) );

						} );

						return color;

					} )(),

				};

				material.colorNode = displayColorNodes[ unifiedEffectController[ 'Display Mode' ] ];
				material.needsUpdate = true;

				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), material );
				scene.add( plane );

				const animate = () => {

					renderer.render( scene, camera );

				};

				renderer.setAnimationLoop( animate );

				document.body.appendChild( renderer.domElement );
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.top = '0';
				renderer.domElement.style.left = '0';
				renderer.domElement.style.width = '50%';
				renderer.domElement.style.height = '100%';

				if ( ! leftSideDisplay ) {

					renderer.domElement.style.left = '50%';

					scene.background = new THREE.Color( 0x212121 );

				} else {

					scene.background = new THREE.Color( 0x313131 );

				}

				renderer.info.autoReset = false;

				const stepAnimation = async function () {

					const currentAlgorithm = effectController.algo;
					const state = effectController.state;
					const stateController = leftSideDisplay ? stateLeftController : stateRightController;

					if ( state === 'Reset' ) {

						renderer.computeAsync( computeResetBuffer );
						renderer.computeAsync( computeResetWorkgroupSums );

					} else if ( state === 'Run Algo' ) {

						renderer.info.reset();

						let cpuTime = 0;

						switch ( currentAlgorithm ) {

							case 'CPU (Serial)': {

								cpuTime = serialAlgorithm( array );

								break;

							}

							case 'CPU (Reduce)': {

								cpuTime = serialAlgorithmNativeReduce( array );

								break;

							}
			
							case 'Reduce 0 (N/2)': {

								let m = size / 2;

								for ( let i = 0; i < reduce0Calls.length; i ++ ) {

									effectController.numThreadsDispatched.value = m;

									const reduce0 = reduce0Calls[ i ];
									// Do a reduction step
									renderer.computeAsync( reduce0 );
									renderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );

									m /= 2;

								}


								break;

							}

							default: {

								const currentAlgoCalls = calls[ currentAlgorithm ];

								for ( let i = 0; i < currentAlgoCalls.length; i ++ ) {

									renderer.computeAsync( currentAlgoCalls[ i ] );
									renderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );

								}

								break;

							}

						}

						// DEBUG: const reductionResult = new Uint32Array( await renderer.getArrayBufferAsync( currentBuffer ) )[0];

						let passInfoString = '';

						if ( effectController.algo.substring( 0, 3 ) === 'CPU' ) {

							passInfoString = `Ran in ${cpuTime}ms<br>`;

						} else {

							passInfoString = `${renderer.info.compute.frameCalls} pass in ${renderer.info.compute.timestamp.toFixed( 6 )}ms<br>`;

						}


						timestamps[ leftSideDisplay ? 'left_side_display' : 'right_side_display' ].innerHTML = `

							Compute ${effectController.algo}: ${passInfoString}`;

					}

					renderer.render( scene, camera );
					renderer.resolveTimestampsAsync( THREE.TimestampQuery.RENDER );

					// Validate next state

					if ( state === 'Run Algo' ) {

						stateController.setValue( 'Validate' );

						effectController.highlight.value = 1;

					} else if ( state === 'Validate' ) {

						stateController.setValue( 'Reset' );

						effectController.highlight.value = 0;

					} else if ( state === 'Reset' ) {

						stateController.setValue( 'Run Algo' );

					}

					setTimeout( stepAnimation, 500 );

				};


				window.addEventListener( 'resize', onWindowResize );

				function onWindowResize() {

					renderer.setSize( window.innerWidth / 2, window.innerHeight );

					const aspect = ( window.innerWidth / 2 ) / window.innerHeight;

					const frustumHeight = camera.top - camera.bottom;

					camera.left = - frustumHeight * aspect / 2;
					camera.right = frustumHeight * aspect / 2;

					camera.updateProjectionMatrix();

					renderer.render( scene, camera );

				}

				setTimeout( stepAnimation, 500 );

			}

		</script>
	</body>
</html>