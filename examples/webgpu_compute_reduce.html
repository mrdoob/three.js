<html lang="en">
	<head>
		<title>three.js webgpu - compute reduction</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
			<br /> This example demonstrates the performance of various simple parallel reduction kernels.
			<br /> Reference implementations are translated from the CUDA/WGSL code present in the following books/repos:
			<br /> Impl. 0 - 2: <a href="https://www.cambridge.org/core/books/programming-in-parallel-with-cuda/C43652A69033C25AD6933368CDBE084C"><i>Programming in Parallel with CUDA</i></a> by <a href="https://people.bss.phy.cam.ac.uk/~rea1/">Richard Ansorge</a>
			<br /> Impl. 3: <a href="https://github.com/frost-beta/betann/blob/main/betann/wgsl/reduce_all.wgsl"><i>betann reduce_all kernel</i></a> by <a href="https://github.com/zcbenz">zcbenz</a>
			<div id="left_side_display" style="position: absolute;top: 150px;left: 0;padding: 10px;background: rgba( 0, 0, 0, 0.5 );color: #fff;font-family: monospace;font-size: 12px;line-height: 1.5;pointer-events: none;text-align: left;"></div>
			<div id="right_side_display" style="position: absolute;top: 150px;right: 0;padding: 10px;background: rgba( 0, 0, 0, 0.5 );color: #fff;font-family: monospace;font-size: 12px;line-height: 1.5;pointer-events: none;text-align: left;"></div>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { instancedArray, Loop, If, vec3, nativeSelect, clamp, atomicStore, subgroupAdd, uniform, uv, uint, float, Fn, vec2, invocationLocalIndex, invocationSubgroupIndex, uvec2, floor, instanceIndex, workgroupId, workgroupBarrier, workgroupArray, subgroupSize } from 'three/tsl';

			import WebGPU from 'three/addons/capabilities/WebGPU.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			const timestamps = {
				left_side_display: document.getElementById( 'left_side_display' ),
				right_side_display: document.getElementById( 'right_side_display' )
			};

			// Total number of elements and the dimensions of the display grid.
			const size = 262144;
			const gridDim = Math.sqrt( size );
			let maxWorkgroupSize = 64;
			let minSubgroupSize = 4;

			// Algorithm speed increase as you iterate through algorithms array
			const algorithms = [
				'Reduce 0 (N/2)',
				'Reduce 1 (Naive Accumulate)',
				'Reduce 2 (Workgroup Reduction)',
				'Reduce 3 (Subgroup Reduce)',
				'Incorrect Baseline',
			];

			// Input Grid: Displays input data in a grid format
			// Input Log2: Displays input grid data's logarithmic indices horizontally (1, 2, 4, 8, 16, ..., size)
			const displayModes = [ 'Input Grid', 'Input Log2', 'Input Element 0' ];

			// Holds uniforms for both displays as well as debug information
			const unifiedEffectController = {
				// Number of elements in the grid
				gridElementWidth: uniform( gridDim ),
				gridElementHeight: uniform( gridDim ),
				// Number of elements in the grid being displayed
				gridDisplayWidth: uniform( gridDim ),
				gridDisplayHeight: uniform( gridDim ),
				// How to display end result of reduction.
				// Ideally this is unique to the reduction method being deployed
				'Display Mode': 'Input Log2',
				loggedBuffer: 'Input Buffer',
				elementsReduced: size,
			};
			

			const leftEffectController = {
				algo: 'Reduce 0 (N/2)',
				highlight: uniform( 0 ),
				// Uniform that corresponds to the index of the current algorithm within the algorithms array
				currentAlgo: uniform( 0 ),
				// Current state of reduction (Running, validating, reseting)
				state: 'Run Algo',
				displayMode: 'Input Log2',
				// Reduce 0 specfic uniform
				numThreadsDispatched: uniform( size / 2 ),
			};

			const rightEffectController = {
				algo: 'Reduce 3 (Subgroup Reduce)',
				currentAlgo: uniform( 3 ),
				highlight: uniform( 0 ),
				displayMode: 'Input Element 0',
				state: 'Run Algo',
				numThreadsDispatched: uniform( size / 2 )
			};

			const leftMaterial = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );
			const rightMaterial = new THREE.MeshBasicNodeMaterial( { color: 0x00ff00 } );
			const leftDisplayColorNodes = {};
			const rightDisplayColorNodes = {};
			
			// https://medium.com/@rimikadhara/7-step-optimization-of-parallel-reduction-with-cuda-33a3b2feafd8
			// https://superjomn.github.io/posts/reduce-cuda/

			const gui = new GUI();

			gui.add( leftEffectController, 'algo', algorithms ).onChange( () => {

				leftEffectController.currentAlgo.value = algorithms.findIndex( val => val === leftEffectController.algo );
			

			} );

			gui.add( rightEffectController, 'algo', algorithms ).onChange( () => {

				rightEffectController.currentAlgo.value = algorithms.findIndex( val => val === rightEffectController.algo );

			} );

			gui.add( leftEffectController, 'displayMode', displayModes ).name( 'Left Display Mode' ).onChange( () => {

				leftMaterial.colorNode = leftDisplayColorNodes[ leftEffectController.displayMode ];
				leftMaterial.needsUpdate = true;

			} );
			gui.add( rightEffectController, 'displayMode', displayModes ).name( 'Right Display Mode' ).onChange( () => {

				rightMaterial.colorNode = rightDisplayColorNodes[ rightEffectController.displayMode ];
				rightMaterial.needsUpdate = true;

			} );

			const debugFolder = gui.addFolder( 'Debug' );
			const elementsReducedController = debugFolder.add( unifiedEffectController, 'elementsReduced' ).name( 'Elements Reduced' );
			elementsReducedController.disable();
			const stateLeftController = debugFolder.add( leftEffectController, 'state' ).name( 'Left Display State' );
			stateLeftController.disable();
			const stateRightController = debugFolder.add( rightEffectController, 'state' ).name( 'Right Display State' );
			stateRightController.disable();
			debugFolder.add( unifiedEffectController, 'loggedBuffer', [ 'Input Buffer', 'Workgroup Sums Buffer', 'Accumulation Buffer' ] ).name( 'Buffer to Log' );
			debugFolder.close();

			if ( WebGPU.isAvailable() === false ) {

				document.body.appendChild( WebGPU.getErrorMessage() );

				throw new Error( 'No WebGPU support' );

			}

			const divRoundUp = ( size, part_size ) => {

				return Math.floor( ( size + part_size - 1 ) / part_size );

			};

			init();

			init( false );

			async function init( leftSideDisplay = true ) {

				const effectController = leftSideDisplay ? leftEffectController : rightEffectController;

				const aspect = ( window.innerWidth / 2 ) / window.innerHeight;
				const camera = new THREE.OrthographicCamera( - aspect, aspect, 1, - 1, 0, 2 );
				camera.position.z = 1;

				const scene = new THREE.Scene();

				const array = new Uint32Array( Array.from( { length: size }, ( _, i ) => {

					return i + 1;

				} ) );

				const inputStorage = instancedArray( array, 'uint', size ).setPBO( true ).setName( `Current_${leftSideDisplay ? 'Left' : 'Right'}` );
				const inputVectorizedStorage = instancedArray( array, 'vec4' ).setPBO( true ).setName( `CurrentVectorized_${leftSideDisplay ? 'Left' : 'Right'}` );
				const atomicAccumulator = instancedArray( new Uint32Array( 1 ), 'uint' ).setPBO( true ).toAtomic();
			
				// Reduce 3 Calculations
				const workPerThread = 4;
				const numRows = workPerThread * 32;
				const rowSize = divRoundUp( size, numRows );

				const workgroupSumsArray = new Uint32Array( numRows );
				const workgroupSumsStorage = instancedArray( workgroupSumsArray, 'uint', numRows ).setPBO( true ).setName( `WorkgroupSums_${leftSideDisplay ? 'Left' : 'Right'}` );

				const buffers = {
					'Input Buffer': inputStorage,
					'Workgroup Sums Buffer': workgroupSumsStorage,
					'Accumulation Buffer': atomicAccumulator,
				};

				const logFunctionName = `Log ${leftSideDisplay ? 'Left' : 'Right'} Side`;
				const functionObj = {};
				functionObj[ logFunctionName ] = async() => {

					const selectedBuffer = buffers[ unifiedEffectController.loggedBuffer ];
					console.log( new Uint32Array( await renderer.getArrayBufferAsync( selectedBuffer.value ) ) );

				};

				debugFolder.add( functionObj, `Log ${leftSideDisplay ? 'Left' : 'Right'} Side` );

				const computeResetBufferFn = Fn( () => {

					inputStorage.element( instanceIndex ).assign( 1 );
			
				} );

				const computeResetWorkgroupSumsFn = Fn( () => {

					workgroupSumsStorage.element( instanceIndex ).assign( 0 );
					atomicStore( atomicAccumulator.element( 0 ), 0 );

				} );

				// Re-initialize compute buffer
				const computeResetBuffer = computeResetBufferFn().compute( size );
				const computeResetWorkgroupSums = computeResetWorkgroupSumsFn().compute( 256 );

				const renderer = new THREE.WebGPURenderer( { antialias: false, trackTimestamp: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth / 2, window.innerHeight );

				// Unfortunately, need to arbitrarily run compute shader to get access to device limits
				await renderer.computeAsync( computeResetBuffer );

				if ( renderer.backend.device !== null ) {

					maxWorkgroupSize = renderer.backend.device.limits.maxComputeWorkgroupSizeX;
					minSubgroupSize = renderer.backend.device.adapterInfo.subgroupMinSize;

				}

				// Create and store dispatches of reduction of certain size. Map each set of dispatches to algorithm name.

				const computeReduce0Fn = Fn( () => {

					const { numThreadsDispatched } = effectController;

					inputStorage.element( instanceIndex ).addAssign( inputStorage.element( instanceIndex.add( numThreadsDispatched ) ) );

				} )();

				const reduce0Calls = [];

				for ( let i = size / 2; i >= 1; i /= 2 ) {

					const reduce0 = computeReduce0Fn.compute( i, [ maxWorkgroupSize ] );
					reduce0Calls.push( reduce0 );

				}

				// Thanks to Sam0oneau of Graphics Programming Discord for the explanation.
				// (Graphics Programming Discord Message Link): https://discord.com/channels/318590007881236480/374061825454768129/1391248956171882597

				const createReduce1Fn = ( createReduce1FnProps ) => {

					const { dispatchSize, numElements } = createReduce1FnProps;

					const fnDef = Fn( () => {

						//const dispatchSize = uint( dispatch ).toVar( 'dispatchSize' );
						const tSum = uint( 0 ).toVar();
						const k = instanceIndex.toVar( 'k' );

						Loop( k.lessThan( uint( numElements ) ), ( ) => {

							tSum.addAssign( inputStorage.element( k ) );
							k.addAssign( uint( dispatchSize ) );

						} );

						inputStorage.element( instanceIndex ).assign( tSum );


					} )();

					return fnDef;
			
				};

				/* Reduce 1 Example (Assume Workgroup Size 256, numElements: 262144) -> Initial currentBuffer State: | 1, 1, 1, 1, ... |
				 *
				 * KERNEL 1:
				 * Executes 256 threads by 256 workgroups. Each thread loops 4 times and accesses elements
				 * at the indices below.
				 *          Thread 1                        Thread 2                         Thread 3
				 * | 0, 65536, ..., n * 65536 | 1, 65537, .... (n * 65536) + 1 | 1, 65538, .... (n * 65536) + 2 | etc
				 * Buffer Values: | 4, 4, 4, 4, ...|
				 *
				 * KERNEL 2:
				 * Executes 256 threads by one workgroup. Each thread loops 1024 times
				 *          Thread 1                     Thread 2                     Thread 3
				 * | 0, 256, ...., n * 256    | 1, 257, ... (n * 256) + 1 | 2, 258, ... (n * 256) + 3 | etc
				 * Buffer Values: | 1024, 1024, 1024, 1024, ... |
				 *
				 * KERNEL 3:
				 * Executes 1 thread by one workgroup. Single thread loops 256 times
				 *          Thread 1
				 * | 0, 1, 2, 3, 4, 5, 6 ... etc|
				 * Buffer Values: [262144, 1024, 1024]
				 */

				const reduce1Calls = [
					// Accumulation
					createReduce1Fn( {
						dispatchSize: maxWorkgroupSize * maxWorkgroupSize,
						numElements: size
					} ).compute( maxWorkgroupSize * maxWorkgroupSize, [ maxWorkgroupSize ] ),
					// 1 Block accumulation
					createReduce1Fn( {
						dispatchSize: maxWorkgroupSize,
						numElements: maxWorkgroupSize * maxWorkgroupSize
					} ).compute( maxWorkgroupSize, [ maxWorkgroupSize ] ),
					// Final result
					createReduce1Fn( {
						dispatchSize: 1,
						numElements: maxWorkgroupSize
					} ).compute( 1, [ 1 ] ),
				];

				const pow2Ceil = Fn( ( [ x ] ) => {

					If( x.equal( uint( 0 ) ), () => {

						return uint( 1 );

					} );

					const val = x.sub( 1 ).toVar( 'val' );
					val.assign( val.bitOr( val.shiftRight( 1 ) ) );
					val.assign( val.bitOr( val.shiftRight( 2 ) ) );
					val.assign( val.bitOr( val.shiftRight( 4 ) ) );
					val.assign( val.bitOr( val.shiftRight( 8 ) ) );
					val.assign( val.bitOr( val.shiftRight( 16 ) ) );
					return val.add( 1 );

				} ).setLayout( {
					name: 'pow2Ceil',
					type: 'uint',
					inputs: [
						{ name: 'x', type: 'uint' }
					]
				} );

				// For non power of 2 # of workgroups
				const createReduce2Fn = ( createReduce2FnProps ) => {

					const { workgroupSize, dispatchSize, numElements } = createReduce2FnProps;

					const fnDef = Fn( () => {

						const tSum = workgroupArray( 'uint', workgroupSize );

						const k = instanceIndex.toVar( 'k' );
						tSum.element( invocationLocalIndex ).assign( uint( 0 ) );

						Loop( k.lessThan( uint( numElements ) ), () => {

							tSum.element( invocationLocalIndex ).addAssign( inputStorage.element( k ) );

							k.addAssign( uint( dispatchSize ) );

						} );

						workgroupBarrier();

						// Reset the loop condition (account for numWorkgroups % 2 != 0)
						k.assign( pow2Ceil( uint( workgroupSize ) ).div( 2 ) );

						Loop( k.greaterThan( 0 ), () => {

							If( invocationLocalIndex.lessThan( k ).and( invocationLocalIndex.add( k ).lessThan( workgroupSize ) ), () => {

								tSum.element( invocationLocalIndex ).addAssign( tSum.element( invocationLocalIndex.add( k ) ) );

							} );
							workgroupBarrier();
							k.divAssign( 2 );

						} );

						If( invocationLocalIndex.equal( uint( 0 ) ), () => {

							inputStorage.element( workgroupId.x ).assign( tSum.element( uint( 0 ) ) );

						} );

					} )();

					return fnDef;

				};

				const reduce2Calls = [
					// Accumulate within workgroups
					createReduce2Fn( {
						workgroupSize: maxWorkgroupSize,
						dispatchSize: maxWorkgroupSize * maxWorkgroupSize,
						numElements: size
					} ).compute( maxWorkgroupSize * maxWorkgroupSize, [ maxWorkgroupSize ] ),
					// 1 Block accumulation
					createReduce2Fn( {
						workgroupSize: maxWorkgroupSize,
						dispatchSize: maxWorkgroupSize,
						numElements: maxWorkgroupSize
					} ).compute( maxWorkgroupSize, [ maxWorkgroupSize ] ),
				];

				/* Create array with enough indices for worst-case subgroup size */
				const createSubgroupArray = ( type, workgroupSize, minSubgroupSize = 4 ) => {

					return workgroupArray( 'uint', workgroupSize / minSubgroupSize );

				};

				const ROW_SIZE = uint( rowSize );

				// zcbenz implementation
				// https://github.com/frost-beta/betann/blob/8aa2701caf63fb29bd4cd2454e656973342c1588/betann/wgsl/reduce_ops.wgsl#L71
				const RowReduce = ( rowReduceProps ) => {

					const { workgroupSize, inputBuffer, total, rowOffset, currentRowSize, workPerThread } = rowReduceProps;

					// Number of unvectorized elements each workgroup can ingest
					// At workgroupSize of 256, blockSize will be 1024
					const blockSize = uint( workgroupSize ).mul( workPerThread );
					const block = uint( 0 ).toVar( 'block' );

					// At rowSize of 2048, there will be two blocks
					const blockLimiter = currentRowSize.div( blockSize ).toVar( 'blockLimiter' );
					Loop( block.lessThan( blockLimiter ), () => {

						const blockOffset = block.mul( blockSize );
						const startThread = blockOffset.add( invocationLocalIndex.mul( workPerThread ) );
						const localThreadOffset = uint( 0 ).toVar( 'localThreadOffset' );
						Loop( localThreadOffset.lessThan( workPerThread ), () => {

							const inputElement = inputBuffer.element( rowOffset.add( startThread ).add( localThreadOffset ) );
							total.addAssign( inputElement );
			
							// Increment up a thread
							localThreadOffset.addAssign( 1 );

						} );

						// Increment up a block
						block.addAssign( 1 );

					} );

					// Ignoring left over check for this example, since we know ahead of time the value of leftover (2048 % 1024 === 0)
			
				};

				const WorkgroupReduce = ( workgroupReduceProps ) => {

					const { total, workgroupSize, minSubgroupSize } = workgroupReduceProps;
			
					const subgroupSums = createSubgroupArray( 'uint', workgroupSize, minSubgroupSize );

					// Assign sum of all values in subgroup to total
					total.assign( subgroupAdd( total ) );

					const delta = uint( workgroupSize ).div( subgroupSize ).toVar( 'delta' );

					const subgroupMetaRank = invocationLocalIndex.div( subgroupSize );

					Loop( float( delta ).greaterThan( 1.0 ), () => {

						If( invocationSubgroupIndex.equal( 0 ), () => {
			
							// Each subgroup will populate the subgroupSums array
							subgroupSums.element( subgroupMetaRank ).assign( total );

						} );

						// Ensure that all subgroups in the workgroup have populated the workgroup memory array
						workgroupBarrier();

						// Thread 0 - subgroupsInWorkgroup will assign a value to total
						total.assign( nativeSelect( invocationLocalIndex.lessThan( delta ), subgroupSums.element( invocationLocalIndex ), 0 ) );
						// # of subgroups in workgroup is invariably less than # of threads in subgroup, so subgroupAdd will still sync here
						total.assign( subgroupAdd( total ) );

						delta.divAssign( subgroupSize );

					} );

				};

				// b0nes164 inspired implementation with vec4

				const createReduce3Fn = ( createReduce4FnProps ) => {

					const { workgroupSize, workPerThread, inputBuffer, intermediateBuffer, minSubgroupSize } = createReduce4FnProps;

					const fnDef = Fn( () => {

						const inputSize = uint( inputBuffer.bufferCount.length );
						const rowOffset = workgroupId.x.mul( ROW_SIZE );
			
						// If the current rows elements exceed the bounds of the input
						// Select either 0 or number of elements left,
						// otherwise, select existing ROW_SIZE
						const currentRowSize = nativeSelect(
							( rowOffset.add( ROW_SIZE ) ).greaterThan( inputSize ),
							nativeSelect( inputSize.greaterThan( rowOffset ), inputSize.sub( rowOffset ), 0 ),
							ROW_SIZE,
						);

						const total = uint( 0 ).toVar( 'total' );

						RowReduce( {
							inputBuffer: inputBuffer,
							total: total,
							rowOffset: rowOffset,
							currentRowSize: currentRowSize,
							workPerThread: workPerThread,
							workgroupSize: workgroupSize,
						} );

						WorkgroupReduce( {
							total: total,
							workgroupSize: workgroupSize,
							minSubgroupSize: minSubgroupSize
						} );

						// Populate each workgroup with its reduction
						If( invocationLocalIndex.equal( 0 ), () => {

							intermediateBuffer.element( workgroupId.x ).assign( total );
			
						} );

					} )();

					return fnDef;

				};


				const createIncorrectBaselineFn = () => {

					const fnDef = Fn( () => {

						inputStorage.element( instanceIndex ).assign( 99999 );

					} )();

					return fnDef;
			
				};

				const reduce3Calls = [
					createReduce3Fn( {
						inputBuffer: inputStorage,
						intermediateBuffer: workgroupSumsStorage,
						workgroupSize: maxWorkgroupSize,
						minSubgroupSize: minSubgroupSize,
						workPerThread: 4,
					} ).compute( maxWorkgroupSize * numRows, [ maxWorkgroupSize ] ),
					createReduce3Fn( {
						inputBuffer: workgroupSumsStorage,
						intermediateBuffer: inputStorage,
						workgroupSize: 32,
						minSubgroupSize: minSubgroupSize,
						workPerThread: 4,
					} ).compute( 32, [ 32 ] )
				];

				const createReduce4Fn = ( createReduce4FnProps ) => {

					const { workgroupSize, workPerThread, numElements, minSubgroupSize } = createReduce4FnProps;
					const partitionSize = uint(workgroupSize * workPerThread);
					const numThreadBlocks = 

					const MAX_REDUCE_SIZE = uint(workgroupSize).div(minSubgroupSize);

					vecSize = numElements / 4;

					const fnDef = Fn( () => {

						const workgroupReductionArray = createSubgroupArray('uint', maxWorkgroupSize, minSubgroupSize);

						// Get the index of the subgroup within the workgroup
						const subgroupMetaRank = invocationLocalIndex.div( subgroupSize );
						// Offset by 4 subgroups from current subgroup since each thread will scan in values from across 4 subgroups
						const subgroupOffset = subgroupMetaRank.mul( subgroupSize ).mul( workPerThread );
						subgroupOffset.addAssign( invocationSubgroupIndex );

						// Per workgroup, offset by number of elements scanned per workgroup
						const workgroupOffset = workgroupId.x.mul( partitionSize );

						const startThread = subgroupOffset.add( workgroupOffset );

						const subgroupReduction = uint(0);

						If(workgroupId.x.lessThan(info.thread_blocks - 1u), () => {

							const currentSubgroupInBlock = uint(0).toVar();

							Loop( currentSubgroupInBlock.lessThan(workPerThread), () => {

								// Get vectorized element from input array
								const val = inputVectorizedStorage.element(startThread);

								// Sum values within vec4 together by using result of dot product
								subgroupReduction.addAssign(dot(val, vec4(1)));

								// Increment so thread will scan value in next subgroup
								startThread.addAssign(subgroupSize);

								// Increment to continue loop
								currentSubgroupInBlock.addAssign(1);
								
							})
						})

						If(workgroupId.x.equal(info.thread_blocks - 1u), () => {

							const currentSubgroupInBlock = uint(0).toVar();

							Loop( currentSubgroupInBlock.lessThan(workPerThread), () => {

								const inputValue = inputVectorizedStorage.element(startThread);

								const val = select(startThread.lessThan(vecSize), inputValue, vec4(0));

								// Sum values within vec4 together by using result of dot product
								subgroupReduction.addAssign(dot(val, vec4(1)));

								// Increment so thread will scan value in next subgroup
								startThread.addAssign(subgroupSize);

								// Increment to continue loop
								currentSubgroupInBlock.addAssign(1);
								
							})
						})

						subgroupReduction.assign(subgroupAdd(subgroupReduction));

						// Delegate one thread per subgroup to assign to the workgroupArray storing elements per subgroup
						If(invocationSubgroupIndex.equal(0), () => {

							workgroupArray.element(subgroupMetaRank).assign()

						})

						// Ensure that each workgroup has populated wg_reduce with data
						// from each subgroup before we begin reducing down its values

						
							
							{
        for(var k = 0u; k < VEC4_SPT; k += 1u){
            let t = scan_in[i];
            s_red += dot(t, vec4(1u, 1u, 1u, 1u));
            i += lane_count;
        }
    }

    if(wgid.x == info.thread_blocks - 1u){
        for(var k = 0u; k < VEC4_SPT; k += 1u){
            let t = select(vec4<u32>(0u, 0u, 0u, 0u), scan_in[i], i < info.vec_size);
            s_red += dot(t, vec4(1u, 1u, 1u, 1u));
            i += lane_count;
        }
    }




			
					} );


			
				};

				const incorrectBaselineCalls = [
					createIncorrectBaselineFn().compute( size ),
				];
			
				const calls = {
					'Reduce 0 (N/2)': reduce0Calls,
					'Reduce 1 (Naive Accumulate)': reduce1Calls,
					'Reduce 2 (Workgroup Reduction)': reduce2Calls,
					'Reduce 3 (Subgroup Reduce)': reduce3Calls,
					'Incorrect Baseline': incorrectBaselineCalls
				};

				const getColor = ( bufferToCheck, colorChanger, width, height ) => {

					const subtracter = float( colorChanger ).div( width.mul( height ) );

					const color = vec3( subtracter.oneMinus() ).toVar();

					const { highlight } = effectController;

					// Validate that element 0 is equal to expected result of reduction
					If( highlight.equal( 1 ), () => {

						If( ( bufferToCheck.element( 0 ) ).equal( size ), () => {

							color.assign( vec3( 0.0, subtracter.oneMinus(), 0.0 ) );

						} ).Else( () => {

							color.assign( vec3( subtracter.oneMinus(), 0.0, 0.0 ) );

						} );

					} );

					return color;

				};

				const displayNodes = leftSideDisplay ? leftDisplayColorNodes : rightDisplayColorNodes;
				displayNodes[ 'Input Grid' ] = Fn( () => {

					const { gridElementWidth, gridElementHeight, gridDisplayWidth, gridDisplayHeight } = unifiedEffectController;

					const newUV = uv().mul( vec2( gridDisplayWidth, gridDisplayHeight ) );

					const pixel = uvec2( uint( floor( newUV.x ) ), uint( floor( newUV.y ) ) );

					const elementIndex = uint( gridDisplayWidth ).mul( pixel.y ).add( pixel.x );

					const colorChanger = uint( 0 ).toVar();
					const color = vec3( 0 ).toVar( 'color' );

					colorChanger.assign( inputStorage.element( elementIndex ) );
					color.assign( getColor( inputStorage, colorChanger, gridElementWidth, gridElementHeight ) );

					return color;

				} )();

				displayNodes[ 'Input Log2' ] = Fn( () => {

					const { gridElementWidth, gridElementHeight } = unifiedEffectController;

					const newUV = uv().mul( vec2( Math.log2( size ) ), 1 );

					const colorChanger = uint( 0 ).toVar();
					const color = vec3( 0 ).toVar( 'color' );
			
					colorChanger.assign( inputStorage.element( uint( 1 ).shiftLeft( newUV.x ) ) );
					color.assign( getColor( inputStorage, colorChanger, gridElementWidth, gridElementHeight ) );

					return color;

				} )();

				displayNodes[ 'Input Element 0' ] = Fn( () => {

					const { gridElementWidth, gridElementHeight } = unifiedEffectController;

					const colorChanger = uint( 0 ).toVar();
					const color = vec3( 0 ).toVar( 'color' );

					// Clamp display of single element to shade where green is still readable
					colorChanger.assign( clamp( inputStorage.element( 0 ), 0, size / 2 ) );
					color.assign( getColor( inputStorage, colorChanger, gridElementWidth, gridElementHeight ) );
					return color;
			
				} )();

				( leftSideDisplay ? leftMaterial : rightMaterial ).colorNode = displayNodes[ effectController.displayMode ];
				( leftSideDisplay ? leftMaterial : rightMaterial ).needsUpdate = true;

				const plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1 ), ( leftSideDisplay ? leftMaterial : rightMaterial ) );
				scene.add( plane );

				const animate = () => {

					renderer.render( scene, camera );

				};

				renderer.setAnimationLoop( animate );

				document.body.appendChild( renderer.domElement );
				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.top = '0';
				renderer.domElement.style.left = '0';
				renderer.domElement.style.width = '50%';
				renderer.domElement.style.height = '100%';

				if ( ! leftSideDisplay ) {

					renderer.domElement.style.left = '50%';

					scene.background = new THREE.Color( 0x212121 );

				} else {

					scene.background = new THREE.Color( 0x313131 );

				}

				renderer.info.autoReset = false;

				const stepAnimation = async function () {

					const currentAlgorithm = effectController.algo;
					const state = effectController.state;
					const stateController = leftSideDisplay ? stateLeftController : stateRightController;

					if ( state === 'Reset' ) {

						renderer.computeAsync( computeResetBuffer );
						renderer.computeAsync( computeResetWorkgroupSums );

					} else if ( state === 'Run Algo' ) {

						renderer.info.reset();

						const cpuTime = 0;

						switch ( currentAlgorithm ) {
			
							case 'Reduce 0 (N/2)': {

								let m = size / 2;

								for ( let i = 0; i < reduce0Calls.length; i ++ ) {

									effectController.numThreadsDispatched.value = m;

									const reduce0 = reduce0Calls[ i ];
									// Do a reduction step
									renderer.computeAsync( reduce0 );
									renderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );

									m /= 2;

								}


								break;

							}

							default: {

								const currentAlgoCalls = calls[ currentAlgorithm ];

								for ( let i = 0; i < currentAlgoCalls.length; i ++ ) {

									renderer.computeAsync( currentAlgoCalls[ i ] );
									renderer.resolveTimestampsAsync( THREE.TimestampQuery.COMPUTE );

								}

								break;

							}

						}

						// DEBUG: const reductionResult = new Uint32Array( await renderer.getArrayBufferAsync( currentBuffer ) )[0];

						let passInfoString = '';

						if ( effectController.algo.substring( 0, 3 ) === 'CPU' ) {

							passInfoString = `Ran in ${cpuTime}ms<br>`;

						} else {

							passInfoString = `${renderer.info.compute.frameCalls} pass in ${renderer.info.compute.timestamp.toFixed( 6 )}ms<br>`;

						}


						timestamps[ leftSideDisplay ? 'left_side_display' : 'right_side_display' ].innerHTML = `

							Compute ${effectController.algo}: ${passInfoString}`;

					}

					renderer.render( scene, camera );
					renderer.resolveTimestampsAsync( THREE.TimestampQuery.RENDER );

					// Validate next state

					if ( state === 'Run Algo' ) {

						stateController.setValue( 'Validate' );

						effectController.highlight.value = 1;

					} else if ( state === 'Validate' ) {

						stateController.setValue( 'Reset' );

						effectController.highlight.value = 0;

					} else if ( state === 'Reset' ) {

						stateController.setValue( 'Run Algo' );

					}

					setTimeout( stepAnimation, 500 );

				};


				window.addEventListener( 'resize', onWindowResize );

				function onWindowResize() {

					renderer.setSize( window.innerWidth / 2, window.innerHeight );

					const aspect = ( window.innerWidth / 2 ) / window.innerHeight;

					const frustumHeight = camera.top - camera.bottom;

					camera.left = - frustumHeight * aspect / 2;
					camera.right = frustumHeight * aspect / 2;

					camera.updateProjectionMatrix();

					renderer.render( scene, camera );

				}

				setTimeout( stepAnimation, 500 );

			}

		</script>
	</body>
</html>