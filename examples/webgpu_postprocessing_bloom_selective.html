<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - bloom selective</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Selective Bloom</span>
			</div>

			<small>Using MRT do define whether an object should be affected by Bloom or not.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { pass, mrt, output, float, uniform } from 'three/tsl';
			import { bloom } from 'three/addons/tsl/display/BloomNode.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			// scene

			const scene = new THREE.Scene();

			const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );
			camera.position.set( 0, 0, 20 );
			camera.lookAt( 0, 0, 0 );

			const geometry = new THREE.IcosahedronGeometry( 1, 15 );

			for ( let i = 0; i < 50; i ++ ) {

				const color = new THREE.Color();
				color.setHSL( Math.random(), 0.7, Math.random() * 0.2 + 0.05 );

				const bloomIntensity = Math.random() > 0.5 ? 1 : 0;

				const material = new THREE.MeshBasicNodeMaterial( { color: color } );
				material.mrtNode = mrt( {
					bloomIntensity: uniform( bloomIntensity )
				} );

				const sphere = new THREE.Mesh( geometry, material );
				sphere.position.x = Math.random() * 10 - 5;
				sphere.position.y = Math.random() * 10 - 5;
				sphere.position.z = Math.random() * 10 - 5;
				sphere.position.normalize().multiplyScalar( Math.random() * 4.0 + 2.0 );
				sphere.scale.setScalar( Math.random() * Math.random() + 0.5 );
				scene.add( sphere );

			}

			// renderer

			const renderer = new THREE.WebGPURenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setAnimationLoop( animate );
			renderer.inspector = new Inspector();
			renderer.toneMapping = THREE.NeutralToneMapping;
			document.body.appendChild( renderer.domElement );

			// post processing

			const scenePass = pass( scene, camera );
			scenePass.setMRT( mrt( {
				output,
				bloomIntensity: float( 0 ) // default bloom intensity
			} ) );

			const outputPass = scenePass.getTextureNode().toInspector( 'Color' );
			const bloomIntensityPass = scenePass.getTextureNode( 'bloomIntensity' ).toInspector( 'Bloom Intensity' );

			const bloomPass = bloom( outputPass.mul( bloomIntensityPass ) );

			const postProcessing = new THREE.PostProcessing( renderer );
			postProcessing.outputColorTransform = false;
			postProcessing.outputNode = outputPass.add( bloomPass ).renderOutput();

			// controls

			const controls = new OrbitControls( camera, renderer.domElement );
			controls.maxPolarAngle = Math.PI * 0.5;
			controls.minDistance = 1;
			controls.maxDistance = 100;

			// raycaster

			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();

			window.addEventListener( 'pointerdown', ( event ) => {

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				const intersects = raycaster.intersectObjects( scene.children, false );

				if ( intersects.length > 0 ) {

					const material = intersects[ 0 ].object.material;

					const bloomIntensity = material.mrtNode.get( 'bloomIntensity' );
					bloomIntensity.value = bloomIntensity.value === 0 ? 1 : 0;

				}

			} );

			// gui

			const gui = renderer.inspector.createParameters( 'Settings' );

			const bloomFolder = gui.addFolder( 'Bloom' );
			bloomFolder.add( bloomPass.threshold, 'value', 0.0, 1.0 ).name( 'threshold' );
			bloomFolder.add( bloomPass.strength, 'value', 0.0, 3 ).name( 'strength' );
			bloomFolder.add( bloomPass.radius, 'value', 0.0, 1.0 ).name( 'radius' );

			const toneMappingFolder = gui.addFolder( 'Tone Mapping' );
			toneMappingFolder.add( renderer, 'toneMappingExposure', 0.1, 3 ).name( 'exposure' );

			// events

			window.onresize = function () {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			};

			// animate

			function animate() {

				postProcessing.render();

			}

		</script>

	</body>

</html>
