<!DOCTYPE html>
<html lang="en">

<head>

	<head>
		<title>three.js webgl - postprocessing - Screen Space Reflection</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

<body>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> -
		<a href="https://github.com/mrdoob/three.js/pull/20156" target="_blank" rel="noopener">SSRPass</a> demo by <a href="https://github.com/gonnavis" target="_blank">Vis</a>.<br />
		based on <a href="https://threejs.org/examples/?q=physic#webgl_shading_physical" target="_blank" rel="noopener">this scene</a>
	</div>

<!-- <script src="https://cdn.bootcdn.net/ajax/libs/vConsole/3.3.4/vconsole.min.js"></script>
<script>
  var vConsole = new VConsole();
</script> -->
<script type="module">

	import * as THREE from '../build/three.module.js';

	import Stats from './jsm/libs/stats.module.js';

	import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
	
	import { OrbitControls } from './jsm/controls/OrbitControls.js'
	
	import { GUI } from './jsm/libs/dat.gui.module.js';
	import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
	import { SSRPass } from './jsm/postprocessing/SSRPass.js';

	var params = {
		enableSSR: true,
		darken: true,
	}
	var composer
	var ssrPass
	var gui

	var container, stats;

	var camera, scene, renderer;

	var mesh;

	var controls;

	var sunLight, pointLight, ambientLight;

	var mixer;

	var clock = new THREE.Clock();

	var shadowCameraHelper, shadowConfig = {

		shadowCameraVisible: false,
		shadowCameraNear: 750,
		shadowCameraFar: 4000,
		shadowBias: - 0.0002

	};

	init();
	animate();

	function init() {

		container = document.createElement( 'div' );
		document.body.appendChild( container );

		// CAMERA

		// var cameraNear = 1
		// var cameraFar = 2000
		// var aspect = window.innerWidth / window.innerHeight;
		// camera = new THREE.OrthographicCamera(initialFrustumSize * aspect / - 2, initialFrustumSize * aspect / 2, initialFrustumSize / 2, initialFrustumSize / - 2, cameraNear, cameraFar);
		// camera.position.set(394.8768477903498,  424.03752576248496,  815.0242032138592)

		camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 2, 10000 );
		camera.position.set( 388.5770726262176,  305.6568142796153,  647.1326965696304);
		// camera.position.set( -612.8787517743004,  518.3480614141735,  137.45500830289768);
		// window.camera=camera

		// SCENE

		scene = new THREE.Scene();
		window.scene=scene
		scene.fog = new THREE.Fog( 0, 1000, 10000 );

		// TEXTURES
		var textureLoader = new THREE.TextureLoader();

		var textureSquares = textureLoader.load( "textures/patterns/bright_squares256.png" );
		textureSquares.repeat.set( 50, 50 );
		textureSquares.wrapS = textureSquares.wrapT = THREE.RepeatWrapping;
		textureSquares.magFilter = THREE.NearestFilter;
		textureSquares.encoding = THREE.sRGBEncoding;

		var textureNoiseColor = textureLoader.load( "textures/disturb.jpg" );
		textureNoiseColor.repeat.set( 1, 1 );
		textureNoiseColor.wrapS = textureNoiseColor.wrapT = THREE.RepeatWrapping;
		textureNoiseColor.encoding = THREE.sRGBEncoding;

		var textureLava = textureLoader.load( "textures/lava/lavatile.jpg" );
		textureLava.repeat.set( 6, 2 );
		textureLava.wrapS = textureLava.wrapT = THREE.RepeatWrapping;
		textureLava.encoding = THREE.sRGBEncoding;

		// GROUND

		var groundMaterial = new THREE.MeshPhongMaterial( {
			shininess: 80,
			color: 0xffffff,
			specular: 0xffffff,
			map: textureSquares
		} );

		var planeGeometry = new THREE.PlaneBufferGeometry( 100, 100 );

		var ground = new THREE.Mesh( planeGeometry, groundMaterial );
		ground.position.set( 0, 0, 0 );
		ground.rotation.x = - Math.PI / 2;
		ground.scale.set( 1000, 1000, 1000 );
		ground.receiveShadow = true;
		scene.add( ground );

		// MATERIALS

		var materialLambert = new THREE.MeshPhongMaterial( { shininess: 50, color: 0xffffff, map: textureNoiseColor } );
		var materialPhong = new THREE.MeshPhongMaterial( { shininess: 50, color: 0xffffff, specular: 0x999999, map: textureLava } );
		var materialPhongCube = new THREE.MeshPhongMaterial( { shininess: 50, color: 0xffffff, specular: 0x999999, } );

		// OBJECTS

		var sphereGeometry = new THREE.SphereBufferGeometry( 100, 64, 32 );
		var torusGeometry = new THREE.TorusBufferGeometry( 240, 60, 32, 64 );
		var cubeGeometry = new THREE.BoxBufferGeometry( 150, 150, 150 );

		addObject( torusGeometry, materialPhong, 0, 100, 0, 0 );
		addObject( cubeGeometry, materialLambert, 350, 75, 300, 0 );

		mesh = addObject( sphereGeometry, materialPhongCube, 350, 100, - 350, 0 );

		function addObjectColor( geometry, color, x, y, z, ry ) {

			var material = new THREE.MeshPhongMaterial( { color: 0xffffff } );

			return addObject( geometry, material, x, y, z, ry );

		}

		function addObject( geometry, material, x, y, z, ry ) {

			var tmpMesh = new THREE.Mesh( geometry, material );

			tmpMesh.material.color.offsetHSL( 0.1, - 0.1, 0 );

			tmpMesh.position.set( x, y, z );

			tmpMesh.rotation.y = ry;

			tmpMesh.castShadow = true;
			tmpMesh.receiveShadow = true;

			scene.add( tmpMesh );

			return tmpMesh;

		}

		var bigCube = new THREE.BoxBufferGeometry( 50, 500, 50 );
		var midCube = new THREE.BoxBufferGeometry( 50, 200, 50 );
		var smallCube = new THREE.BoxBufferGeometry( 100, 100, 100 );

		addObjectColor( bigCube, 0xff0000, - 500, 250, 0, 0 );
		addObjectColor( smallCube, 0xff0000, - 500, 50, - 150, 0 );

		addObjectColor( midCube, 0x00ff00, 500, 100, 0, 0 );
		addObjectColor( smallCube, 0x00ff00, 500, 50, - 150, 0 );

		addObjectColor( midCube, 0x0000ff, 0, 100, - 500, 0 );
		addObjectColor( smallCube, 0x0000ff, - 150, 50, - 500, 0 );

		addObjectColor( midCube, 0xff00ff, 0, 100, 500, 0 );
		addObjectColor( smallCube, 0xff00ff, - 150, 50, 500, 0 );

		addObjectColor( new THREE.BoxBufferGeometry( 500, 10, 10 ), 0xffff00, 0, 600, 0, Math.PI / 4 );
		addObjectColor( new THREE.BoxBufferGeometry( 250, 10, 10 ), 0xffff00, 0, 600, 0, 0 );

		addObjectColor( new THREE.SphereBufferGeometry( 100, 32, 26 ), 0xffffff, - 300, 100, 300, 0 );

		// MORPHS

		var loader = new GLTFLoader();

		loader.load( "models/gltf/SittingBox.glb", function ( gltf ) {

			var mesh = gltf.scene.children[ 0 ];

			mixer = new THREE.AnimationMixer( mesh );

			mixer.clipAction( gltf.animations[ 0 ] ).setDuration( 10 ).play();

			var s = 200;
			mesh.scale.set( s, s, s );

			mesh.castShadow = true;
			mesh.receiveShadow = true;

			scene.add( mesh );

		} );

		// LIGHTS

		ambientLight = new THREE.AmbientLight( 0x3f2806 );
		scene.add( ambientLight );

		pointLight = new THREE.PointLight( 0xffaa00, 1, 5000 );
		scene.add( pointLight );

		sunLight = new THREE.DirectionalLight( 0xffffff, 0.3 );
		sunLight.position.set( 1000, 2000, 1000 );
		sunLight.castShadow = true;
		sunLight.shadow.camera.top = 750;
		sunLight.shadow.camera.bottom = - 750;
		sunLight.shadow.camera.left = - 750;
		sunLight.shadow.camera.right = 750;
		sunLight.shadow.camera.near = shadowConfig.shadowCameraNear;
		sunLight.shadow.camera.far = shadowConfig.shadowCameraFar;
		sunLight.shadow.mapSize.set( 1024, 1024 );
		sunLight.shadow.bias = shadowConfig.shadowBias;

		scene.add( sunLight );

		// SHADOW CAMERA HELPER

		shadowCameraHelper = new THREE.CameraHelper( sunLight.shadow.camera );
		shadowCameraHelper.visible = shadowConfig.shadowCameraVisible;
		scene.add( shadowCameraHelper );

		// RENDERER

		renderer = new THREE.WebGLRenderer( { antialias: false } );
		// renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );

		//

		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;
		renderer.outputEncoding = THREE.sRGBEncoding;

		//

		controls = new OrbitControls( camera, renderer.domElement );

		// STATS

		stats = new Stats();
		container.appendChild( stats.dom );

		// EVENTS

		window.addEventListener( 'resize', onWindowResize, false );

		// composer

		composer = new EffectComposer(renderer);
		ssrPass = new SSRPass({
			scene, 
			camera, 
			width: innerWidth, 
			height: innerHeight,
			// encoding: THREE.sRGBEncoding,
		});
		composer.addPass(ssrPass);

		// GUI

		gui = new GUI( { width: 400 } );
		// ssrPass.surfDist=4.2
		ssrPass.surfDist=.007
    // ssrPass.opacity=.2
		// ssrPass.output=SSRPass.OUTPUT.SSR
		gui.add(params, 'enableSSR').name( 'Enable SSR' );
		gui.add(params, 'darken').onChange(function(value){
			if(value){
				ssrPass.encoding = THREE.LinearEncoding
			}else{
				ssrPass.encoding = THREE.sRGBEncoding
			}
		});
		gui.add(ssrPass,'isBouncing')
		gui.add(ssrPass, 'output', {
			'Default': SSRPass.OUTPUT.Default,
			'DefaultBlur': SSRPass.OUTPUT.DefaultBlur,
			'SSR Only': SSRPass.OUTPUT.SSR,
			'SSR Only + Blur': SSRPass.OUTPUT.Blur,
			'Beauty': SSRPass.OUTPUT.Beauty,
			'Depth': SSRPass.OUTPUT.Depth,
			'Normal': SSRPass.OUTPUT.Normal,
			// 'Metalness': SSRPass.OUTPUT.Metalness,
		}).onChange(function (value) {

			ssrPass.output = parseInt(value);

		});
		gui.add(ssrPass, 'opacity').min(0).max(1);
		gui.add(ssrPass, 'maxDistance').min(0).max(2000);
		// gui.add(ssrPass, 'surfDist').min(0).max(10).step(.1);
		gui.add(ssrPass, 'surfDist').min(0).max(.02).step(.0001);

	}

	//

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize(window.innerWidth, window.innerHeight);
		composer.setSize(window.innerWidth, window.innerHeight);

	}

	//

	function animate() {

		requestAnimationFrame( animate );

		stats.begin();
		render();
		stats.end();

	}

	function render() {

		// update

		var delta = clock.getDelta();

		controls.update();

		if ( mixer ) {

			mixer.update( delta );

		}

		if(params.enableSSR){
			composer.render();
		}else{
			renderer.render(scene,camera)
		}

	}

</script>

</body>

</html>
