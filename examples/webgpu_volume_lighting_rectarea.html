<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgpu - volumetric lighting rect area</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="example.css">
	</head>

	<body>

		<div id="info">
			<a href="https://threejs.org/" target="_blank" rel="noopener" class="logo-link"></a>

			<div class="title-wrapper">
				<a href="https://threejs.org/" target="_blank" rel="noopener">three.js</a><span>Volumetric Lighting Rect Area</span>
			</div>

			<small>Compatible with rect area lights and shadows using post-processing pass.</small>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.webgpu.js",
					"three/webgpu": "../build/three.webgpu.js",
					"three/tsl": "../build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three/webgpu';
			import { vec3, Fn, time, texture3D, screenUV, uniform, screenCoordinate, pass } from 'three/tsl';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
			import { RectAreaLightTexturesLib } from 'three/addons/lights/RectAreaLightTexturesLib.js';

			import { Inspector } from 'three/addons/inspector/Inspector.js';

			import { bayer16 } from 'three/addons/tsl/math/Bayer.js';
			import { gaussianBlur } from 'three/addons/tsl/display/GaussianBlurNode.js';

			let renderer, scene, camera;
			let volumetricMesh, meshKnot;
			let rectLight1, rectLight2, rectLight3;
			let clock;
			let postProcessing;

			init();

			function createTexture3D() {

				let i = 0;

				const size = 128;
				const data = new Uint8Array( size * size * size );

				const scale = 10;
				const perlin = new ImprovedNoise();

				const repeatFactor = 5.0;

				for ( let z = 0; z < size; z ++ ) {

					for ( let y = 0; y < size; y ++ ) {

						for ( let x = 0; x < size; x ++ ) {

							const nx = ( x / size ) * repeatFactor;
							const ny = ( y / size ) * repeatFactor;
							const nz = ( z / size ) * repeatFactor;

							const noiseValue = perlin.noise( nx * scale, ny * scale, nz * scale );

							data[ i ] = ( 128 + 128 * noiseValue );

							i ++;

						}

					}

				}

				const texture = new THREE.Data3DTexture( data, size, size, size );
				texture.format = THREE.RedFormat;
				texture.minFilter = THREE.LinearFilter;
				texture.magFilter = THREE.LinearFilter;
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				texture.unpackAlignment = 1;
				texture.needsUpdate = true;

				return texture;

			}

			function init() {

				THREE.RectAreaLightNode.setLTC( RectAreaLightTexturesLib.init() );

				const LAYER_VOLUMETRIC_LIGHTING = 10;

				clock = new THREE.Clock();

				renderer = new THREE.WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.NeutralToneMapping;
				renderer.toneMappingExposure = 2;
				renderer.shadowMap.enabled = true;
				renderer.inspector = new Inspector();
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 250 );
				camera.position.set( 0, 5, - 15 );

				// Volumetric Fog Area

				const noiseTexture3D = createTexture3D();

				const smokeAmount = uniform( 2 );

				const volumetricMaterial = new THREE.VolumeNodeMaterial();
				volumetricMaterial.steps = 12;
				volumetricMaterial.offsetNode = bayer16( screenCoordinate ); // Add dithering to reduce banding
				volumetricMaterial.scatteringNode = Fn( ( { positionRay } ) => {

					// Return the amount of fog based on the noise texture

					const timeScaled = vec3( time, 0, time.mul( .3 ) );

					const sampleGrain = ( scale, timeScale = 1 ) => texture3D( noiseTexture3D, positionRay.add( timeScaled.mul( timeScale ) ).mul( scale ).mod( 1 ), 0 ).r.add( .5 );

					let density = sampleGrain( .1 );
					density = density.mul( sampleGrain( .05, 1 ) );
					density = density.mul( sampleGrain( .02, 2 ) );

					return smokeAmount.mix( 1, density );

				} );

				volumetricMesh = new THREE.Mesh( new THREE.BoxGeometry( 50, 40, 50 ), volumetricMaterial );
				volumetricMesh.receiveShadow = true;
				volumetricMesh.position.y = 20;
				volumetricMesh.layers.disableAll();
				volumetricMesh.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				scene.add( volumetricMesh );

				// Objects

				rectLight1 = new THREE.RectAreaLight( 0xff0000, 5, 4, 10 );
				rectLight1.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				rectLight1.position.set( - 5, 5, 5 );
				scene.add( rectLight1 );

				rectLight2 = new THREE.RectAreaLight( 0x00ff00, 5, 4, 10 );
				rectLight2.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				rectLight2.position.set( 0, 5, 5 );
				scene.add( rectLight2 );

				rectLight3 = new THREE.RectAreaLight( 0x0000ff, 5, 4, 10 );
				rectLight3.layers.enable( LAYER_VOLUMETRIC_LIGHTING );
				rectLight3.position.set( 5, 5, 5 );
				scene.add( rectLight3 );

				//

				const createRectLightMesh = ( rectLight ) => {

					const geometry = new THREE.PlaneGeometry( 4, 10 );
					const frontMaterial = new THREE.MeshBasicMaterial( { color: rectLight.color, side: THREE.BackSide } );
					const backMaterial = new THREE.MeshStandardMaterial( { color: 0x111111 } );

					const backSide = new THREE.Mesh( geometry, backMaterial );
					backSide.position.set( 0, 0, .08 );

					const frontSide = new THREE.Mesh( geometry, frontMaterial );
					frontSide.position.set( 0, 0, .01 );

					rectLight.add( backSide );
					rectLight.add( frontSide );

				};

				createRectLightMesh( rectLight1 );
				createRectLightMesh( rectLight2 );
				createRectLightMesh( rectLight3 );

				//

				const geoFloor = new THREE.BoxGeometry( 2000, 0.1, 2000 );
				const matStdFloor = new THREE.MeshStandardMaterial( { color: 0xbcbcbc, roughness: 0.1, metalness: 0 } );
				const mshStdFloor = new THREE.Mesh( geoFloor, matStdFloor );
				scene.add( mshStdFloor );

				const geoKnot = new THREE.TorusKnotGeometry( 1.5, 0.5, 200, 16 );
				const matKnot = new THREE.MeshStandardMaterial( { color: 0xffffff, roughness: 0, metalness: 0 } );
				meshKnot = new THREE.Mesh( geoKnot, matKnot );
				meshKnot.position.set( 0, 5, 0 );
				scene.add( meshKnot );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 5;
				controls.maxDistance = 200;
				controls.target.copy( meshKnot.position );
				controls.update();

				// Post-Processing

				postProcessing = new THREE.PostProcessing( renderer );

				// Layers

				const volumetricLightingIntensity = uniform( 1 );

				const volumetricLayer = new THREE.Layers();
				volumetricLayer.disableAll();
				volumetricLayer.enable( LAYER_VOLUMETRIC_LIGHTING );

				// Scene Pass

				const scenePass = pass( scene, camera );
				const sceneDepth = scenePass.getTextureNode( 'depth' );

				// Material - Apply occlusion depth of volumetric lighting based on the scene depth

				volumetricMaterial.depthNode = sceneDepth.sample( screenUV );

				// Volumetric Lighting Pass

				const volumetricPass = pass( scene, camera, { depthBuffer: false } );
				volumetricPass.setLayers( volumetricLayer );
				volumetricPass.setResolutionScale( .25 );

				// Compose and Denoise

				const denoiseStrength = uniform( .6 );

				const blurredVolumetricPass = gaussianBlur( volumetricPass, denoiseStrength );

				const scenePassColor = scenePass.add( blurredVolumetricPass.mul( volumetricLightingIntensity ) );

				postProcessing.outputNode = scenePassColor;

				// GUI

				const params = {
					resolution: volumetricPass.getResolutionScale(),
					denoise: true
				};

				const gui = renderer.inspector.createParameters( 'Volumetric Lighting' );

				const rayMarching = gui.addFolder( 'Ray Marching' );
				rayMarching.add( params, 'resolution', .1, .5 ).onChange( ( resolution ) => {

					volumetricPass.setResolutionScale( resolution );

				} );
				rayMarching.add( volumetricMaterial, 'steps', 2, 12 ).name( 'step count' );
				rayMarching.add( denoiseStrength, 'value', 0, 1 ).name( 'denoise strength' );
				rayMarching.add( params, 'denoise' ).onChange( ( denoise ) => {

					const volumetric = denoise ? blurredVolumetricPass : volumetricPass;

					const scenePassColor = scenePass.add( volumetric.mul( volumetricLightingIntensity ) );

					postProcessing.outputNode = scenePassColor;
					postProcessing.needsUpdate = true;

				} );

				const lighting = gui.addFolder( 'Lighting / Scene' );
				lighting.add( volumetricLightingIntensity, 'value', 0, 2 ).name( 'fog intensity' );
				lighting.add( smokeAmount, 'value', 0, 3 ).name( 'smoke amount' );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				const delta = clock.getDelta();

				rectLight1.rotation.y += - delta;
				rectLight2.rotation.y += delta * .5;
				rectLight3.rotation.y += delta;

				postProcessing.render();

			}

		</script>

	</body>
</html>
