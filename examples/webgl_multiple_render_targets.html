
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - multiple render targets</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #000;
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script src="../build/three.min.js"></script>
    <script src="../src/renderers/WebGLRenderer.js"></script>
    <script src="../src/renderers/WebGLShaders.js"></script>
    <script src="../src/renderers/WebGLRenderTarget.js"></script>
    <script>

      var container;

      var camera, object, scene, renderer;
      var RTTScene, RTTCamera, quad;
      var targetArray;
      var shader;

      init();
      animate();

      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 400, 1500 );
        camera.position.y = 400;

        scene = new THREE.Scene();

        var light, material;

        scene.add( new THREE.AmbientLight( 0x404040 ) );

        light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 0, 1, 0 );
        scene.add( light );

        var map = THREE.ImageUtils.loadTexture( 'textures/ash_uvgrid01.jpg' );
        map.wrapS = map.wrapT = THREE.RepeatWrapping;
        map.anisotropy = 16;

        // material = new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: map, side: THREE.DoubleSide } );
        material = new THREE.ShaderMaterial({
          uniforms: {
            map: { type: "t", value: map }
          },
          vertexShader: [
            'varying vec2 vUv;',
            'varying vec3 vNormal;',
            'void main() {',
              'vUv = uv;',
              'vNormal = normalMatrix * normal;',
              'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
            '}'
          ].join("\n"),
          fragmentShader: [
            'uniform sampler2D map;',
            'varying vec2 vUv;',
            'varying vec3 vNormal;',
            'void main() {',
              'vec4 texelColor = texture2D( map, vUv );',

              'gl_FragData[0] = texelColor;',
              'gl_FragData[1] = vec4(vNormal/2.0+vec3(0.5),1.0);',
              'gl_FragData[2] = vec4(vUv,0.0,1.0);',
            '}'
          ].join("\n")
        });

        object = [];
        object[0] = new THREE.Mesh( new THREE.SphereGeometry( 75, 20, 10 ), material );
        object[0].position.set( 0, 0, 0 );
        scene.add( object[0] );

        object[1] = new THREE.Mesh( new THREE.SphereGeometry( 50, 20, 10 ), material );
        object[1].position.set( 250, 0, 0 );
        scene.add( object[1] );

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( window.innerWidth, window.innerHeight );

        container.appendChild( renderer.domElement );

        targetArray = new THREE.WebGLRenderTargetArray(1024, 1024, 7, true); // TODO: crashed when 256 or smaller and more than 7 targets

        RTTScene = new THREE.Scene();

        RTTCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
        RTTScene.add(RTTCamera);

        quad = [];
        quad[0] = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.MeshBasicMaterial( { map: targetArray.color[0] } ) );
        quad[1] = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.MeshBasicMaterial( { map: targetArray.color[1] } ) );
        quad[2] = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.MeshBasicMaterial( { map: targetArray.color[2] } ) );
        quad[3] = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.MeshBasicMaterial( { map: targetArray.depth } ) );
        quad[0].position.set(-0.5,0.5,0);
        quad[1].position.set(0.5,0.5,0);
        quad[2].position.set(-0.5,-0.5,0);
        quad[3].position.set(0.5,-0.5,0);
        RTTScene.add(quad[0]);
        RTTScene.add(quad[1]);
        RTTScene.add(quad[2]);
        RTTScene.add(quad[3]);

        //

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      //

      function animate() {

        requestAnimationFrame( animate );

        render();

      }

      function render() {

        var timer = Date.now() * 0.0001;

        camera.position.x = Math.cos( timer ) * 800;
        camera.position.z = Math.sin( timer ) * 800;

        camera.lookAt( scene.position );


        object[0].rotation.y = Math.sin(timer * 50);

        object[1].position.x = Math.sin(parseInt(timer*10) * 0.2) * 250;
        object[1].position.z = Math.cos(parseInt(timer*10) * 0.2) * 250;

        renderer.render( scene, camera, targetArray, false);

        renderer.render( RTTScene, RTTCamera );

      }

    </script>

  </body>
</html>
