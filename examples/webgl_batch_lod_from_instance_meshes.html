<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js raycaster - batch - lod - from - instance - meshes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			a {
				text-decoration: underline;
			}
		</style>
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> batch lod - <a href="https://github.com/agargaro/batched-mesh-extensions" target="_blank" rel="noopener">@three.ez/batched-mesh-extensions</a><br/>
			Combining Instance Meshes that share a Material into a BatchedMesh<br>
			Each geometry has also a LOD. <br> 
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/",
 
					"three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.0/build/index.module.js",
					"@three.ez/batched-mesh-extensions": "https://cdn.jsdelivr.net/npm/@three.ez/batched-mesh-extensions@0.0.11/build/webgl.js", 
					"bvh.js": "https://cdn.jsdelivr.net/npm/bvh.js@0.0.13/build/index.js",
					"@three.ez/simplify-geometry": "https://cdn.jsdelivr.net/npm/@three.ez/simplify-geometry@0.0.1/build/index.js",
					"meshoptimizer": "https://cdn.jsdelivr.net/npm/meshoptimizer@0.23.0/+esm"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import Stats from 'three/addons/libs/stats.module.js';
			import { MapControls } from 'three/addons/controls/MapControls.js';
			import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'; 
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
			import { acceleratedRaycast, computeBatchedBoundsTree } from 'three-mesh-bvh';
			import { createRadixSort, extendBatchedMeshPrototype, getBatchedMeshLODCount } from '@three.ez/batched-mesh-extensions';
			import { performanceRangeLOD, simplifyGeometriesByErrorLOD } from '@three.ez/simplify-geometry';

			// add and override BatchedMesh methods ( @three.ez/batched-mesh-extensions )
			extendBatchedMeshPrototype(); 
			THREE.BatchedMesh.prototype.computeBoundsTree = computeBatchedBoundsTree;

			let stats;
			let camera, scene, renderer; 
			let animatedCam, dirlight, onEnterFrame;
			let clock = new THREE.Clock();

			init();

			async function init() {

				// renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				document.body.appendChild( renderer.domElement );

				//

				scene = new THREE.Scene();

				const pmremGenerator = new THREE.PMREMGenerator( renderer );
				scene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;
				scene.environmentIntensity = 0.1;

				//

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.set( 0, 20, 55 );

				// 

				stats = new Stats();
				document.body.appendChild( stats.dom );

				const loader = new GLTFLoader();
				const dracoLoader = new DRACOLoader();
					  dracoLoader.setDecoderPath( 'jsm/libs/draco/gltf/' );

					  loader.setDRACOLoader( dracoLoader );

				const gltf = await loader.loadAsync( 'models/gltf/level-optimized.glb' );

				setupScene( gltf );
				 
				window.addEventListener( 'resize', onWindowResize );
				onWindowResize();
			
				renderer.setAnimationLoop( animate );

			} 

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			} 

			
			async function setupScene( gltf )
			{
				const remove = [];
				const material2batch = {};
				

				gltf.scene.traverse( o =>{

					if( o instanceof THREE.InstancedMesh )
					{
						if( !o.material.name ) return;
						if( !material2batch[o.material.name] )
						{ 
							material2batch[o.material.name] = [o]
						}
						else 
						{
							material2batch[o.material.name].push(o);
						} 

						remove.push(o); 
					}
					else if ( o instanceof THREE.DirectionalLight )
					{
						o.intensity =  o.intensity / 120; 
						o.castShadow = true;
						o.shadow.mapSize.set(1024,1024);

						let size = 60;

						o.shadow.camera.top = -size;
						o.shadow.camera.bottom = size;
						o.shadow.camera.left = -size;
						o.shadow.camera.right = size;
						o.shadow.bias = -0.0003; 
						dirlight = o; 
					}
					else if( o instanceof  THREE.Mesh )
					{
						o.castShadow = true;
						o.receiveShadow = true;
					}
					else if ( o instanceof  THREE.PerspectiveCamera )
					{
						animatedCam = o;
						camera.fov = animatedCam.fov;
						camera.updateProjectionMatrix()
					}

				});

				scene.add( gltf.scene );
				remove.forEach(o=>o.removeFromParent());

				for( const mname in material2batch )
				{
					const imeshes = material2batch[mname];
					let count = 0;
					const geometries = [];

					for (let i = 0; i < imeshes.length; i++) {
						const imesh = imeshes[i];
						count += imesh.count ;
						geometries.push( imesh.geometry );  
					}

					const material = imeshes[1].material;
					const geometriesLODArray = await simplifyGeometriesByErrorLOD( geometries, 4, performanceRangeLOD );
					const { vertexCount, indexCount, LODIndexCount } = getBatchedMeshLODCount( geometriesLODArray );
					const batchedMesh = new THREE.BatchedMesh( count, vertexCount, indexCount, material);
					batchedMesh.customSort = createRadixSort( batchedMesh );
					batchedMesh.castShadow = true;
					batchedMesh.receiveShadow = true; 

					for ( let i = 0; i < geometriesLODArray.length; i ++ ) {
						const geometryLOD = geometriesLODArray[ i ];
						const geometryId = batchedMesh.addGeometry( geometryLOD[ 0 ], - 1, LODIndexCount[ i ] );

						batchedMesh.addGeometryLOD( geometryId, geometryLOD[ 1 ], .05 );
						batchedMesh.addGeometryLOD( geometryId, geometryLOD[ 2 ], .01 );
						batchedMesh.addGeometryLOD( geometryId, geometryLOD[ 3 ], .003 );
						batchedMesh.addGeometryLOD( geometryId, geometryLOD[ 4 ], .001 );
				
					}

					let matrix = new THREE.Matrix4(); 

					for (let i = 0; i < imeshes.length; i++) {
						const imesh = imeshes[i]; 
						for (let j = 0; j < imesh.count; j++) 
						{ 
							const id = batchedMesh.addInstance( i );   
							
							imesh.getMatrixAt(j, matrix); 
							matrix.premultiply( imesh.matrixWorld )

							batchedMesh.setMatrixAt( id, matrix);
						}
					}

					scene.add( batchedMesh );

					// compute blas (bottom-level acceleration structure) bvh ( three-mesh-bvh )
					 batchedMesh.computeBoundsTree();

					// compute tlas (top-level acceleration structure) bvh ( @three.ez/batched-mesh-extensions )
					 batchedMesh.computeBVH( THREE.WebGLCoordinateSystem );
				}
				
				scene.add( new THREE.AmbientLight(0xffee99,.6)); 
				const skyColor = 0xfefefe;
				scene.fog = new THREE.Fog(0xfefefe,3,60)
				scene.background = new THREE.Color(skyColor);


				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap; // optional, softer shadows 


				let offset = new THREE.Vector3();
				dirlight.getWorldPosition(offset).sub( animatedCam.position );
				offset.y = 0;

				let mix = new THREE.AnimationMixer(animatedCam);
				mix.clipAction( gltf.animations[0] ).play().timeScale = 2;

				onEnterFrame = delta => {
					mix.update(delta) 

					dirlight.position.x = animatedCam.position.x + offset.x;
					dirlight.position.z = animatedCam.position.z + offset.z;

					camera.position.copy( animatedCam.position );
					camera.quaternion.copy( animatedCam.quaternion ); 
					
				}
			}

			function animate() {

				stats.begin();

				onEnterFrame?.(clock.getDelta());
				renderer.render( scene, camera );

				stats.end();

			}

		</script>

	</body>
</html>
