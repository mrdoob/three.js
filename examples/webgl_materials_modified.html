<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - modified</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> wegbl - modified material.
			<a href="http://graphics.cs.williams.edu/data/meshes.xml#14" target="_blank" rel="noopener">Lee Perry-Smith</a> head.
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import { GUI } from './jsm/libs/dat.gui.module.js';
			import Stats from './jsm/libs/stats.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';

			let camera, scene, renderer, stats;

			const guiParams = {

				'left inverted': true,
				'right inverted': false,
				'spin fast after changing': false,

			};

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.z = 20;

				scene = new THREE.Scene();

				let leftMesh, rightMesh;

				const loader = new GLTFLoader();
				loader.load( 'models/gltf/LeePerrySmith/LeePerrySmith.glb', function ( gltf ) {

					const geometry = gltf.scene.children[ 0 ].geometry;

					leftMesh = new THREE.Mesh( geometry, buildTwistMaterial( guiParams[ 'left inverted' ] ) );
					leftMesh.position.x = - 3.5;
					leftMesh.position.y = - 0.5;
					scene.add( leftMesh );

					rightMesh = new THREE.Mesh( geometry, buildTwistMaterial( guiParams[ 'right inverted' ] ) );
					rightMesh.position.x = 3.5;
					rightMesh.position.y = - 0.5;
					scene.add( rightMesh );

				} );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 10;
				controls.maxDistance = 50;

				//

				stats = new Stats();
				document.body.appendChild( stats.dom );

				const gui = new GUI( { width: 400 } );

				const leftInverseGui = gui.add( guiParams, 'left inverted' );

				leftInverseGui.onChange( function ( value ) {

					if ( leftMesh ) {

						leftMesh.material = buildTwistMaterial( guiParams[ 'left inverted' ] );

					}

				} );

				const rightInverseGui = gui.add( guiParams, 'right inverted' );

				rightInverseGui.onChange( function ( value ) {

					if ( rightMesh ) {

						rightMesh.material = buildTwistMaterial( guiParams[ 'right inverted' ] );

					}

				} );

				const fastGui = gui.add( guiParams, 'spin fast after changing' );

				// EVENTS

				window.addEventListener( 'resize', onWindowResize );

			}

			function buildTwistMaterial( inverted ) {

				const material = new THREE.MeshNormalMaterial();
				material.onBeforeCompile = function ( shader ) {

					shader.uniforms.time = { value: performance.now() / 1000 };

					shader.vertexShader =
						[
							'uniform float time;',
							'uniform float waveSpeed;',
							shader.vertexShader
						].join( '\n' );

					shader.vertexShader = shader.vertexShader.replace(
						'#include <begin_vertex>',
						[
							`float theta = sin( time * waveSpeed + position.y ) * 0.5;`,
							'float c = cos( theta );',
							'float s = sin( theta );',
							'mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );',
							'vec3 transformed = vec3( position ) * m;',
							inverted ? 'vNormal = -vNormal * m;' : 'vNormal = vNormal * m;',
						].join( '\n' )
					);

					material.userData.shader = shader;

				};

				material.onProgramChange = function ( params ) {

					params.uniforms.waveSpeed = {

						value: guiParams[ 'spin fast after changing' ] ? 4 : 1

					};

				};

				// Make sure WebGLRenderer doesnt reuse a single program if the compile-time data changes

				material.customProgramCacheKey = function () {

					return inverted;

				};

				return material;

			}

			//

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

				stats.update();

			}

			function render() {

				scene.traverse( function ( child ) {

					if ( child.isMesh ) {

						const shader = child.material.userData.shader;

						if ( shader ) {

							shader.uniforms.time.value = performance.now() / 1000;

						}

					}

				} );

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
