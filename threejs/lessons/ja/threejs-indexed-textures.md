Title: åœ§ç¸®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ”ãƒƒã‚­ãƒ³ã‚°ã¨ã‚«ãƒ©ãƒ¼
Description: åœ§ç¸®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ”ãƒƒã‚­ãƒ³ã‚°ã¨ã‚«ãƒ©ãƒ¼
TOC: åœ§ç¸®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ”ãƒƒã‚­ãƒ³ã‚°ã¨ã‚«ãƒ©ãƒ¼

ã“ã®è¨˜äº‹ã¯[Three.jsã§HTMLè¦ç´ ã‚’3Dã«æƒãˆã‚‹](threejs-align-html-elements-to-3d.html)ã®ç¶šãã§ã™ã€‚
ã¾ã èª­ã‚“ã§ã„ãªã„äººã¯ãã¡ã‚‰ã‹ã‚‰èª­ã‚“ã§ã¿ã¦ä¸‹ã•ã„ã€‚

Three.jsã‚’ä½¿ã†æ™‚ã«ã¯ã€ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãªè§£æ±ºç­–ã‚’è€ƒãˆãªã‘ã‚Œã°ãªã‚‰ãªã„äº‹ã‚‚ã‚ã‚Šã¾ã™ã€‚
ã“ã‚ŒãŒç´ æ™´ã‚‰ã—ã„è§£æ±ºç­–ã‹ã‚ã‹ã‚Šã¾ã›ã‚“ãŒã€å…±æœ‰ã—ã¦ä½•ã‹è§£æ±ºç­–ã®ææ¡ˆãŒã‚ã‚‹ã‹è¦‹ã¦ã¿ã‚ˆã†ã¨æ€ã„ã¾ã—ãŸã€‚

[å‰å›ã®è¨˜äº‹](threejs-align-html-elements-to-3d.html)ã§ã¯3Dã®åœ°çƒå„€ã®å‘¨ã‚Šã«å›½åã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å›½ã‚’é¸æŠã•ã›ã¦ã€ãã®å›½ã®é¸æŠå†…å®¹ã‚’è¡¨ç¤ºã•ã›ã‚‹ã«ã¯ã©ã†ã™ã‚Œã°è‰¯ã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ

æœ€åˆã«æ€ã„ã¤ãã®ã¯å›½ã”ã¨ã«ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ç”Ÿæˆã™ã‚‹äº‹ã§ã™ã€‚
ä»¥å‰å–ã‚Šä¸Šã’ãŸ[ãƒ”ãƒƒã‚­ãƒ³ã‚°ã‚’ä½¿ã£ãŸè§£æ±ºç­–](threejs-picking.html)ãŒã‚ã‚Šã¾ã™ã€‚
å›½ã”ã¨ã«3Dã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ä½œã‚Šã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå›½ã®ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€ã©ã®å›½ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚ŒãŸã®ã‹åˆ†ã‹ã‚Šã¾ã™ã€‚

ã“ã®è§£æ±ºç­–ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«[å‰å›ã®è¨˜äº‹](threejs-align-html-elements-to-3d.html)ã®ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ç”Ÿæˆã«ä½¿ã£ãŸåŒã˜ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã€å…¨ã¦ã®å›½ã®3Dãƒ¡ãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆã—ã¦ã¿ã¾ã—ãŸã€‚
ãã®çµæœã€15.5MBã®ãƒã‚¤ãƒŠãƒªGLTF(.glb)ãƒ•ã‚¡ã‚¤ãƒ«ãŒã§ãã¾ã—ãŸã€‚
15.5MBã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã›ã‚‹ã®ã¯ã€ç§ã«ã¯ã‚„ã‚Šã™ãã®ã‚ˆã†ã«æ€ãˆã¾ã™ã€‚

ãƒ‡ãƒ¼ã‚¿ã‚’åœ§ç¸®ã™ã‚‹æ–¹æ³•ã¯ãŸãã•ã‚“ã‚ã‚Šã¾ã™ã€‚
1ã¤ç›®ã¯ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã®è§£åƒåº¦ã‚’ä¸‹ã’ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’é©ç”¨ã™ã‚‹äº‹ã§ã™ã€‚
ãã®è§£æ±ºç­–ã‚’è¿½æ±‚ã™ã‚‹æ™‚é–“ã‚’å‰²ã„ã¦ã„ã¾ã›ã‚“ã§ã—ãŸã€‚
ã‚¢ãƒ¡ãƒªã‚«ã®å›½å¢ƒã«ã¨ã£ã¦ã¯å¤§å‹åˆ©ã§ã—ã‚‡ã†ã­ã€‚
ã‚«ãƒŠãƒ€ã®å›½å¢ƒã¯ãŠãã‚‰ãã‚‚ã£ã¨å°‘ãªã„ã§ã™ã€‚

åˆ¥ã®è§£æ±ºç­–ã¨ã—ã¦ã¯ã€å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿åœ§ç¸®ã ã‘ã‚’ä½¿ç”¨ã™ã‚‹æ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ã€‚
ä¾‹ãˆã°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åœ§ç¸®ã™ã‚‹ã¨11MBã«ãªã‚Šã¾ã—ãŸã€‚
30ï¼…æ¸›ã§ã™ãŒã€é–“é•ã„ãªãç‰©è¶³ã‚Šãªã„ã§ã™ã€‚

å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’32ãƒ“ãƒƒãƒˆã®floatå€¤ã§ã¯ãªãã€16ãƒ“ãƒƒãƒˆã®ç¯„å›²å†…ã®å€¤ã¨ã—ã¦æ ¼ç´ã§ãã¾ã™ã€‚
ã‚‚ã—ãã¯[draco compression](https://google.github.io/draco/)ã®ã‚ˆã†ãªã‚‚ã®ã‚’ä½¿ã†äº‹ã‚‚ã§ãã‚‹ã—ã€ãã‚Œã ã‘ã§å……åˆ†ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
ç§ã¯ç¢ºèªã—ã¦ãªã„ã§ã™ãŒã€ãœã²ã”è‡ªèº«ã§ç¢ºèªã—ã¦çµæœãŒã©ã†ãªã£ãŸã‹æ•™ãˆã¦ä¸‹ã•ã„ğŸ˜…

ç§ã®å ´åˆã¯[ãƒ”ãƒƒã‚­ãƒ³ã‚°ã®è¨˜äº‹](threejs-picking.html)ã®æœ€å¾Œã«å–ã‚Šä¸Šã’ãŸ[GPUãƒ”ãƒƒã‚­ãƒ³ã‚°ã®è§£æ±ºç­–](threejs-picking.html)ã«ã¤ã„ã¦è€ƒãˆã¦ã¿ã¾ã—ãŸã€‚
ã“ã®è§£æ±ºç­–ã§ã¯ã€ãƒ¡ãƒƒã‚·ãƒ¥ã®IDã‚’è¡¨ã™ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªã‚«ãƒ©ãƒ¼ã§å…¨ã¦ã®ãƒ¡ãƒƒã‚·ãƒ¥ã‚’æç”»ã—ã¾ã—ãŸã€‚
å…¨ã¦ã®ãƒ¡ãƒƒã‚·ãƒ¥ã‚’æç”»ã—ã€ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚«ãƒ©ãƒ¼ã‚’ç¢ºèªã—ã¾ã—ãŸã€‚

ãã“ã‹ã‚‰ã‚¤ãƒ³ã‚¹ãƒ”ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å¾—ã¦ã€å›½ã®é…åˆ—ã®ä¸­ã§ãã‚Œãã‚Œã®å›½ã®ã‚«ãƒ©ãƒ¼ãŒã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç•ªå·ã«ãªã‚Šã€å›½ã®åœ°å›³ã‚’äº‹å‰ã«ç”Ÿæˆã§ãã¾ã—ãŸã€‚
ãã†ã™ã‚Œã°ã€GPUãƒ”ãƒƒã‚­ãƒ³ã‚°æŠ€è¡“ã¨ä¼¼ãŸã‚ˆã†ã«ä½¿ã†äº‹ãŒã§ãã¾ã™ã€‚
ã“ã®åœ§ç¸®ãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼‰ã‚’ä½¿ã£ã¦åœ°çƒå„€ã‚’ç”»é¢å¤–ã«æç”»ã—ã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¯ãƒªãƒƒã‚¯ã—ãŸãƒ”ã‚¯ã‚»ãƒ«ã®ã‚«ãƒ©ãƒ¼ã‚’è¦‹ã‚‹ã¨å›½ã®IDãŒåˆ†ã‹ã‚Šã¾ã™ã€‚

ãã“ã§ã“ã®ã‚ˆã†ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ç”Ÿæˆã™ã‚‹[ã‚³ãƒ¼ãƒ‰](https://github.com/gfxfundamentals/threejsfundamentals/blob/master/threejs/lessons/tools/geo-picking/)ã‚’æ›¸ã„ã¦ã¿ã¾ã—ãŸã€‚

<div class="threejs_center"><img src="../resources/data/world/country-index-texture.png" style="width: 700px;"></div>

æ³¨ï¼šã“ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã¯[ã“ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆ](http://thematicmapping.org/downloads/world_borders.php)ã‹ã‚‰ã®ã‚‚ã®ã§[CC-BY-SA](http://creativecommons.org/licenses/by-sa/3.0/)ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã§ã™ã€‚

ãŸã£ãŸã®217KBã«ãªã‚Šã€å›½ã®ãƒ¡ãƒƒã‚·ãƒ¥ã®14MBã‚ˆã‚Šãšã£ã¨è‰¯ã„ã§ã™ã€‚
è§£åƒåº¦ã‚’ä¸‹ã’ã‚‹äº‹ã‚‚ã§ããã†ã§ã™ãŒã€ä»Šã®æ‰€ã¯217KBã§å……åˆ†ã ã¨æ€ã„ã¾ã™ã€‚

ã“ã‚Œã‚’ä½¿ã„å›½ã‚’ãƒ”ãƒƒã‚­ãƒ³ã‚°ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

[GPUãƒ”ãƒƒã‚­ãƒ³ã‚°ä¾‹](threejs-picking.html)ã‹ã‚‰ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ã™ã‚‹ã¨ã€ãƒ”ãƒƒã‚­ãƒ³ã‚°ã‚·ãƒ¼ãƒ³ãŒå¿…è¦ã§ã™ã€‚

```js
const pickingScene = new THREE.Scene();
pickingScene.background = new THREE.Color(0);
```

ãã—ã¦ã€ãƒ”ãƒƒã‚­ãƒ³ã‚°ã‚·ãƒ¼ãƒ³ã«åœ§ç¸®ã‚¹ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®åœ°çƒå„€ã®è¿½åŠ ãŒå¿…è¦ã§ã™ã€‚

```js
{
  const loader = new THREE.TextureLoader();
  const geometry = new THREE.SphereGeometry(1, 64, 32);

+  const indexTexture = loader.load('resources/data/world/country-index-texture.png', render);
+  indexTexture.minFilter = THREE.NearestFilter;
+  indexTexture.magFilter = THREE.NearestFilter;
+
+  const pickingMaterial = new THREE.MeshBasicMaterial({map: indexTexture});
+  pickingScene.add(new THREE.Mesh(geometry, pickingMaterial));

  const texture = loader.load('resources/data/world/country-outlines-4k.png', render);
  const material = new THREE.MeshBasicMaterial({map: texture});
  scene.add(new THREE.Mesh(geometry, material));
}
```

å‰ã«ä½¿ã£ãŸ `GPUPickingHelper` ã‚¯ãƒ©ã‚¹ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ã‚‡ã†ã€‚
å°‘ã—å¤‰æ›´ã—ã¾ã—ãŸã€‚

```js
class GPUPickHelper {
  constructor() {
    // create a 1x1 pixel render target
    this.pickingTexture = new THREE.WebGLRenderTarget(1, 1);
    this.pixelBuffer = new Uint8Array(4);
-    this.pickedObject = null;
-    this.pickedObjectSavedColor = 0;
  }
  pick(cssPosition, scene, camera) {
    const {pickingTexture, pixelBuffer} = this;

    // set the view offset to represent just a single pixel under the mouse
    const pixelRatio = renderer.getPixelRatio();
    camera.setViewOffset(
        renderer.getContext().drawingBufferWidth,   // full width
        renderer.getContext().drawingBufferHeight,  // full top
        cssPosition.x * pixelRatio | 0,             // rect x
        cssPosition.y * pixelRatio | 0,             // rect y
        1,                                          // rect width
        1,                                          // rect height
    );
    // render the scene
    renderer.setRenderTarget(pickingTexture);
    renderer.render(scene, camera);
    renderer.setRenderTarget(null);
    // clear the view offset so rendering returns to normal
    camera.clearViewOffset();
    //read the pixel
    renderer.readRenderTargetPixels(
        pickingTexture,
        0,   // x
        0,   // y
        1,   // width
        1,   // height
        pixelBuffer);

+    const id =
+        (pixelBuffer[0] << 16) |
+        (pixelBuffer[1] <<  8) |
+        (pixelBuffer[2] <<  0);
+
+    return id;
-    const id =
-        (pixelBuffer[0] << 16) |
-        (pixelBuffer[1] <<  8) |
-        (pixelBuffer[2]      );
-    const intersectedObject = idToObject[id];
-    if (intersectedObject) {
-      // pick the first object. It's the closest one
-      this.pickedObject = intersectedObject;
-      // save its color
-      this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
-      // set its emissive color to flashing red/yellow
-      this.pickedObject.material.emissive.setHex((time * 8) % 2 > 1 ? 0xFFFF00 : 0xFF0000);
-    }
  }
}
```

ã“ã‚Œã§å›½ã‚’é¸æŠã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

```js
const pickHelper = new GPUPickHelper();

function getCanvasRelativePosition(event) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (event.clientX - rect.left) * canvas.width  / rect.width,
    y: (event.clientY - rect.top ) * canvas.height / rect.height,
  };
}

function pickCountry(event) {
  // exit if we have not loaded the data yet
  if (!countryInfos) {
    return;
  }

  const position = getCanvasRelativePosition(event);
  const id = pickHelper.pick(position, pickingScene, camera);
  if (id > 0) {
    // we clicked a country. Toggle its 'selected' property
    const countryInfo = countryInfos[id - 1];
    const selected = !countryInfo.selected;
    // if we're selecting this country and modifiers are not
    // pressed unselect everything else.
    if (selected && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
      unselectAllCountries();
    }
    numCountriesSelected += selected ? 1 : -1;
    countryInfo.selected = selected;
  } else if (numCountriesSelected) {
    // the ocean or sky was clicked
    unselectAllCountries();
  }
  requestRenderIfNotRequested();
}

function unselectAllCountries() {
  numCountriesSelected = 0;
  countryInfos.forEach((countryInfo) => {
    countryInfo.selected = false;
  });
}

canvas.addEventListener('pointerup', pickCountry);
```

ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€å›½ã®é…åˆ—ã« `selected` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨­å®š/è§£é™¤ã—ã¦ã„ã¾ã™ã€‚
`Shift` ã‚„ `ctrl`ã€`cmd` ã‚’æŠ¼ã™ã¨è¤‡æ•°ã®å›½ã‚’é¸æŠã§ãã¾ã™ã€‚

æ®‹ä½œæ¥­ã¯é¸æŠã—ãŸå›½ã‚’è¡¨ç¤ºã•ã›ã‚‹ã ã‘ã§ã™ã€‚
ãƒ©ãƒ™ãƒ«ã‚’æ›´æ–°ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```js
function updateLabels() {
  // exit if we have not loaded the data yet
  if (!countryInfos) {
    return;
  }

  const large = settings.minArea * settings.minArea;
  // get a matrix that represents a relative orientation of the camera
  normalMatrix.getNormalMatrix(camera.matrixWorldInverse);
  // get the camera's position
  camera.getWorldPosition(cameraPosition);
  for (const countryInfo of countryInfos) {
-    const {position, elem, area} = countryInfo;
-    // large enough?
-    if (area < large) {
+    const {position, elem, area, selected} = countryInfo;
+    const largeEnough = area >= large;
+    const show = selected || (numCountriesSelected === 0 && largeEnough);
+    if (!show) {
      elem.style.display = 'none';
      continue;
    }

    ...
```

ã“ã‚Œã§å›½ã‚’é¸æŠã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

{{{example url="../threejs-indexed-textures-picking.html" }}}

åœ°åŸŸã«åŸºã¥ã„ã¦å›½ã‚’è¡¨ç¤ºã—ã¾ã™ãŒã€1ã¤ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨1ã¤ã ã‘ãƒ©ãƒ™ãƒ«ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

å›½ã‚’é¸æŠã™ã‚‹åˆç†çš„ãªè§£æ±ºç­–ã®ã‚ˆã†ã«æ€ãˆã¾ã™ãŒã€é¸æŠã•ã‚ŒãŸå›½ã‚’å¼·èª¿è¡¨ç¤ºã™ã‚‹ã«ã¯ã©ã†ã§ã—ã‚‡ã†ã‹ï¼Ÿ

*ãƒ‘ãƒ¬ãƒƒãƒˆã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹* ã‹ã‚‰ã‚¤ãƒ³ã‚¹ãƒ”ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å¾—ã‚‹äº‹ãŒã§ãã¾ã™ã€‚

[ãƒ‘ãƒ¬ãƒƒãƒˆã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹](https://en.wikipedia.org/wiki/Palette_%28computing%29)ã‚„[ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚«ãƒ©ãƒ¼](https://en.wikipedia.org/wiki/Indexed_color)ã¯Atari 800ã€Amigaã€ãƒ•ã‚¡ãƒŸã‚³ãƒ³ã€ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒ•ã‚¡ãƒŸã‚³ãƒ³ã€IBMã®å¤ã„PCãªã©ã®å¤ã„ã‚·ã‚¹ãƒ†ãƒ ã§ä½¿ã‚ã‚Œã¦ã„ã¾ã—ãŸã€‚
ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ã‚’RGBã‚«ãƒ©ãƒ¼8ãƒ“ãƒƒãƒˆã€1ãƒ”ã‚¯ã‚»ãƒ«24ãƒã‚¤ãƒˆä»¥ä¸Šã§æ ¼ç´ã™ã‚‹ã®ã§ã¯ãªãã€ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ã‚’8ãƒ“ãƒƒãƒˆä»¥ä¸‹ã®å€¤ã§æ ¼ç´ã—ã¦ã„ã¾ã—ãŸã€‚
å„ãƒ”ã‚¯ã‚»ãƒ«ã®å€¤ã¯ãƒ‘ãƒ¬ãƒƒãƒˆã¸ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ã€‚
ãã®ãŸã‚ä¾‹ãˆã°ç”»åƒå†…ã®å€¤ãŒ3ã§ã‚ã‚Œã° "color 3ã‚’è¡¨ç¤ºã™ã‚‹" ã¨ã„ã†äº‹ã«ãªã‚Šã¾ã™ã€‚
color 3ãŒä½•è‰²ã‹ã¯ "ãƒ‘ãƒ¬ãƒƒãƒˆ" ã¨å‘¼ã°ã‚Œã‚‹åˆ¥ã®å ´æ‰€ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚

JavaScriptã§ã¯æ¬¡ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã«ã§ãã¾ã™ã€‚

```js
const face7x7PixelImageData = [
  0, 1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 
  1, 0, 2, 0, 2, 0, 1,
  1, 0, 0, 0, 0, 0, 1,
  1, 0, 3, 3, 3, 0, 1,
  1, 0, 0, 0, 0, 0, 1,
  0, 1, 1, 1, 1, 1, 1,
];

const palette = [
  [255, 255, 255],  // white
  [  0,   0,   0],  // black
  [  0, 255, 255],  // cyan
  [255,   0,   0],  // red
];
```

ç”»åƒãƒ‡ãƒ¼ã‚¿ã®å„ãƒ”ã‚¯ã‚»ãƒ«ãŒãƒ‘ãƒ¬ãƒƒãƒˆã¸ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ãªã‚Šã¾ã™ã€‚
ä¸Šè¨˜ã®ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ä½¿ã„ã€ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’è§£é‡ˆã™ã‚‹ã¨æ¬¡ã®ã‚ˆã†ãªç”»åƒãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚

<div class="threejs_center"><img src="resources/images/7x7-indexed-face.png"></div>

ã“ã®å ´åˆã€ä¸Šè¨˜ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¯å›½ã”ã¨ã«ç•°ãªã‚‹IDã‚’æŒã£ã¦ã„ã¾ã™ã€‚
ãã“ã§ãƒ‘ãƒ¬ãƒƒãƒˆã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’é€šã—ã¦åŒã˜ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½¿ã„ã€ãã‚Œãã‚Œã®å›½ã®ã‚«ãƒ©ãƒ¼ã‚’å‡ºã›ã°è‰¯ã„ã®ã§ã™ã€‚
ãƒ‘ãƒ¬ãƒƒãƒˆã®è³ªæ„Ÿã‚’å¤‰ãˆã‚‹äº‹ã§ãã‚Œãã‚Œã®å›½ã‚’å½©ã‚‹äº‹ãŒã§ãã¾ã™ã€‚
ä¾‹ãˆã°ãƒ‘ãƒ¬ãƒƒãƒˆãƒ†ã‚¯ã‚¹ãƒãƒ£å…¨ä½“ã‚’é»’ã«è¨­å®šã—ã€ãƒ‘ãƒ¬ãƒƒãƒˆå†…ã®ã‚ã‚‹å›½ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’åˆ¥ã®ã‚«ãƒ©ãƒ¼ã«ã™ã‚‹ã¨ãã®å›½ã ã‘ã‚’å¼·èª¿è¡¨ç¤ºã§ãã¾ã™ã€‚

ãƒ‘ãƒ¬ãƒƒãƒˆåŒ–ã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’è¡Œã†ã«ã¯ã‚«ã‚¹ã‚¿ãƒ ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ¼ãƒ‰ãŒå¿…è¦ã§ã™ã€‚
three.jsã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚’å¤‰æ›´ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚
ãã†ã™ã‚Œã°ã€å¿…è¦ã«å¿œã˜ã¦ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ãªã©ã®æ©Ÿèƒ½ã‚‚ä½¿ãˆã¾ã™ã€‚

[ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹å¤šãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æœ€é©åŒ–ã®è¨˜äº‹](threejs-optimize-lots-of-objects-animated.html)ã§è§£èª¬ã—ãŸã‚ˆã†ã«ã€
ãƒãƒ†ãƒªã‚¢ãƒ«ã® `onBeforeCompile` ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«é–¢æ•°ã‚’è¿½åŠ ã™ã‚‹ã¨ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚’å¤‰æ›´ã§ãã¾ã™ã€‚

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å‰ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚

```glsl
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
```

[ã“ã‚Œã‚‰ã®ã‚¹ãƒ‹ãƒšãƒƒãƒˆã‚’å…¨ã¦èª¿ã¹ã¦ã¿ã‚‹](https://github.com/mrdoob/three.js/tree/dev/src/renderers/shaders/ShaderChunk)ã¨three.jsã¯ãƒ™ãƒ¼ã‚¹ãƒãƒ†ãƒªã‚¢ãƒ«ã®ã‚«ãƒ©ãƒ¼ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã« `diffuseColor` ã¨ã„ã†å¤‰æ•°ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚
ã“ã‚Œã¯ `<color_fragment>` [ã‚¹ãƒ‹ãƒšãƒƒãƒˆ](https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/color_fragment.glsl.js) ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã®ã§ä¿®æ­£ã§ãã‚‹ã¯ãšã§ã™ã€‚

ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã§ `diffuseColor` ã¯æ—¢ã«ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ã‚«ãƒ©ãƒ¼ã«ãªã£ã¦ã„ã‚‹ã¯ãšãªã®ã§ã€ãƒ‘ãƒ¬ãƒƒãƒˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã‹ã‚‰ã‚«ãƒ©ãƒ¼ã‚’æ¢ã—ã¦æœ€çµ‚çš„ãªçµæœã«ãã‚Œã‚‰ã‚’ãƒŸãƒƒã‚¯ã‚¹ã—ã¾ã™ã€‚

[å‰ã«ã‚„ã£ãŸ](threejs-optimize-lots-of-objects-animated.html)ã‚ˆã†ã«æ¤œç´¢æ–‡å­—åˆ—ã¨ç½®æ›æ–‡å­—åˆ—ã®é…åˆ—ã‚’ä½œã‚Šã€`Material.onBeforeCompile` ã§ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«é©ç”¨ã—ã¾ã™ã€‚

```js
{
  const loader = new THREE.TextureLoader();
  const geometry = new THREE.SphereGeometry(1, 64, 32);

  const indexTexture = loader.load('resources/data/world/country-index-texture.png', render);
  indexTexture.minFilter = THREE.NearestFilter;
  indexTexture.magFilter = THREE.NearestFilter;

  const pickingMaterial = new THREE.MeshBasicMaterial({map: indexTexture});
  pickingScene.add(new THREE.Mesh(geometry, pickingMaterial));

+  const fragmentShaderReplacements = [
+    {
+      from: '#include <common>',
+      to: `
+        #include <common>
+        uniform sampler2D indexTexture;
+        uniform sampler2D paletteTexture;
+        uniform float paletteTextureWidth;
+      `,
+    },
+    {
+      from: '#include <color_fragment>',
+      to: `
+        #include <color_fragment>
+        {
+          vec4 indexColor = texture2D(indexTexture, vUv);
+          float index = indexColor.r * 255.0 + indexColor.g * 255.0 * 256.0;
+          vec2 paletteUV = vec2((index + 0.5) / paletteTextureWidth, 0.5);
+          vec4 paletteColor = texture2D(paletteTexture, paletteUV);
+          // diffuseColor.rgb += paletteColor.rgb;   // white outlines
+          diffuseColor.rgb = paletteColor.rgb - diffuseColor.rgb;  // black outlines
+        }
+      `,
+    },
+  ];

  const texture = loader.load('resources/data/world/country-outlines-4k.png', render);
  const material = new THREE.MeshBasicMaterial({map: texture});
+  material.onBeforeCompile = function(shader) {
+    fragmentShaderReplacements.forEach((rep) => {
+      shader.fragmentShader = shader.fragmentShader.replace(rep.from, rep.to);
+    });
+  };
  scene.add(new THREE.Mesh(geometry, material));
}
```

ä¸Šè¨˜ã®ã‚ˆã†ã« `indexTexture`ã€`paletteTexture`ã€`paletteTextureWidth` ã®3ã¤ã®ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ã‚’è¿½åŠ ã—ã¾ã™ã€‚
`indexTexture` ã‹ã‚‰ã‚«ãƒ©ãƒ¼ã‚’å–å¾—ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¤‰æ›ã—ã¾ã™ã€‚
`vUv` ã¯three.jsã§æä¾›ã•ã‚Œã¦ã„ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ã§ã™ã€‚
ãã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ã„ã€ãƒ‘ãƒ¬ãƒƒãƒˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã‹ã‚‰ã‚«ãƒ©ãƒ¼ã‚’å–ã‚Šå‡ºã—ã¾ã™ã€‚
ãã®çµæœã‚’ç¾åœ¨ã® `diffuseColor` ã¨ãƒŸãƒƒã‚¯ã‚¹ã—ã¾ã™ã€‚
`diffuseColor` ã¯é»’ã¨ç™½ã®ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ãƒ†ã‚¯ã‚¹ãƒãƒ£ãªã®ã§ã€2è‰²ã‚’åŠ ãˆã‚‹ã¨ç™½ã®ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã«ãªã‚Šã¾ã™ã€‚
ç¾åœ¨ã®æ‹¡æ•£è‰²ï¼ˆãƒ‡ã‚£ãƒ•ãƒ¥ãƒ¼ã‚ºã‚«ãƒ©ãƒ¼ï¼‰ã‚’å¼•ãã¨é»’ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã«ãªã‚Šã¾ã™ã€‚

ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å‰ã«ãƒ‘ãƒ¬ãƒƒãƒˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã¨3ã¤ã®ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ãƒ‘ãƒ¬ãƒƒãƒˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã¯ã€å›½ã”ã¨ã«1è‰² + æµ·ã®ãŸã‚ã®1è‰²ã‚’ä¿æŒã™ã‚‹ã®ã«ååˆ†ãªå¹…ãŒå¿…è¦ã§ã™(id = 0)ã€‚
240ã®å›½ãŒã‚ã‚Šã¾ã™ã€‚
å›½ã®ãƒªã‚¹ãƒˆãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã¾ã§å¾…ã¡ã€æ­£ç¢ºãªæ•°å­—ã‚’å¾—ã‚‹ã‹ã€ãã‚Œã‚’èª¿ã¹ã‚‹äº‹ãŒã§ãã¾ã™ã€‚
å°‘ã—å¤§ãã‚ã®æ•°å­—ã‚’é¸ã‚“ã§ã‚‚ã€ã‚ã¾ã‚Šå®³ã¯ãªã„ã®ã§512ã‚’é¸ã³ã¾ã—ã‚‡ã†ã€‚

ãƒ‘ãƒ¬ãƒƒãƒˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

```js
const maxNumCountries = 512;
const paletteTextureWidth = maxNumCountries;
const paletteTextureHeight = 1;
const palette = new Uint8Array(paletteTextureWidth * 3);
const paletteTexture = new THREE.DataTexture(
    palette, paletteTextureWidth, paletteTextureHeight, THREE.RGBFormat);
paletteTexture.minFilter = THREE.NearestFilter;
paletteTexture.magFilter = THREE.NearestFilter;
```

`DataTexture` ã¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç”Ÿãƒ‡ãƒ¼ã‚¿ã‚’ä¸ãˆã‚‹äº‹ãŒã§ãã¾ã™ã€‚
ä»Šå›ã¯ã¯512ã®RGBã‚«ãƒ©ãƒ¼ã‚’3ãƒã‚¤ãƒˆãšã¤ä¸ãˆã€ãã‚Œãã‚Œã®ãƒã‚¤ãƒˆãŒèµ¤ã€ç·‘ã€é’ã§0ã€œ255ã®å€¤ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

ãƒ©ãƒ³ãƒ€ãƒ ãªã‚«ãƒ©ãƒ¼ã§å¡—ã‚Šã¤ã¶ã—ã¾ã—ã‚‡ã†ï¼

```js
for (let i = 1; i < palette.length; ++i) {
  palette[i] = Math.random() * 256;
}
// set the ocean color (index #0)
palette.set([100, 200, 255], 0);
paletteTexture.needsUpdate = true;
```

ãƒ‘ãƒ¬ãƒƒãƒˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ `palette` é…åˆ—ã®å†…å®¹ã§æ›´æ–°ã—ãŸã„æ™‚ã¯ã€å¸¸ã«  `paletteTexture.needsUpdate` ã‚’ `true` ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã“ã‚Œã¯ãƒãƒ†ãƒªã‚¢ãƒ«ã®ãƒ¦ãƒ‹ãƒ•ã‚©ãƒ¼ãƒ ã«è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```js
const geometry = new THREE.SphereGeometry(1, 64, 32);
const material = new THREE.MeshBasicMaterial({map: texture});
material.onBeforeCompile = function(shader) {
  fragmentShaderReplacements.forEach((rep) => {
    shader.fragmentShader = shader.fragmentShader.replace(rep.from, rep.to);
  });
+  shader.uniforms.paletteTexture = {value: paletteTexture};
+  shader.uniforms.indexTexture = {value: indexTexture};
+  shader.uniforms.paletteTextureWidth = {value: paletteTextureWidth};
};
scene.add(new THREE.Mesh(geometry, material));
```

ãƒ©ãƒ³ãƒ€ãƒ ãªã‚«ãƒ©ãƒ¼ãŒã¤ã„ãŸå›½ã‚’æ‰‹ã«å…¥ã‚Œã‚‹äº‹ãŒã§ãã¾ã—ãŸã€‚

{{{example url="../threejs-indexed-textures-random-colors.html" }}}

ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ãƒ‘ãƒ¬ãƒƒãƒˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å‹•ä½œãŒç¢ºèªã§ããŸã®ã§ã€ãƒ‘ãƒ¬ãƒƒãƒˆã‚’æ“ä½œã—ã¦ãƒã‚¤ãƒ©ã‚¤ãƒˆã«ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

ã¾ãšã€three.jsã‚¹ã‚¿ã‚¤ãƒ«ã‚«ãƒ©ãƒ¼ã‚’æ¸¡ã—ã¦ãƒ‘ãƒ¬ãƒƒãƒˆã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã«å…¥ã‚Œã‚‹å€¤ã‚’ä¸ãˆã‚‹é–¢æ•°ã‚’ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```js
const tempColor = new THREE.Color();
function get255BasedColor(color) {
  tempColor.set(color);
  return tempColor.toArray().map(v => v * 255);
}
```

ã“ã®ã‚ˆã†ã« `color = get255BasedColor('red')` ã‚’å‘¼ã³å‡ºã™ã¨ `[255, 0, 0]` ã®ã‚ˆã†ãªé…åˆ—ãŒè¿”ã•ã‚Œã¾ã™ã€‚

æ¬¡ã¯ãã‚Œã‚’ä½¿ã£ã¦ã€ã„ãã¤ã‹ã®ã‚«ãƒ©ãƒ¼ã‚’ä½œã£ã¦ãƒ‘ãƒ¬ãƒƒãƒˆã‚’åŸ‹ã‚ã¦ã„ãã¾ã—ã‚‡ã†ã€‚

```js
const selectedColor = get255BasedColor('red');
const unselectedColor = get255BasedColor('#444');
const oceanColor = get255BasedColor('rgb(100,200,255)');
resetPalette();

function setPaletteColor(index, color) {
  palette.set(color, index * 3);
}

function resetPalette() {
  // make all colors the unselected color
  for (let i = 1; i < maxNumCountries; ++i) {
    setPaletteColor(i, unselectedColor);
  }

  // set the ocean color (index #0)
  setPaletteColor(0, oceanColor);
  paletteTexture.needsUpdate = true;
}
```

ã“ã‚Œã‚‰ã®é–¢æ•°ã‚’ä½¿ã„ã€å›½ãŒé¸æŠã•ã‚ŒãŸæ™‚ã«ãƒ‘ãƒ¬ãƒƒãƒˆã‚’æ›´æ–°ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```js
function getCanvasRelativePosition(event) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (event.clientX - rect.left) * canvas.width  / rect.width,
    y: (event.clientY - rect.top ) * canvas.height / rect.height,
  };
}

function pickCountry(event) {
  // exit if we have not loaded the data yet
  if (!countryInfos) {
    return;
  }

  const position = getCanvasRelativePosition(event);
  const id = pickHelper.pick(position, pickingScene, camera);
  if (id > 0) {
    const countryInfo = countryInfos[id - 1];
    const selected = !countryInfo.selected;
    if (selected && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
      unselectAllCountries();
    }
    numCountriesSelected += selected ? 1 : -1;
    countryInfo.selected = selected;
+    setPaletteColor(id, selected ? selectedColor : unselectedColor);
+    paletteTexture.needsUpdate = true;
  } else if (numCountriesSelected) {
    unselectAllCountries();
  }
  requestRenderIfNotRequested();
}

function unselectAllCountries() {
  numCountriesSelected = 0;
  countryInfos.forEach((countryInfo) => {
    countryInfo.selected = false;
  });
+  resetPalette();
}
```

1ã¤ä»¥ä¸Šã®å›½ã‚’å¼·èª¿ã™ã‚‹äº‹ãŒã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

{{{example url="../threejs-indexed-textures-picking-and-highlighting.html" }}}

ã“ã‚Œã§å‹•ä½œã—ã¾ã—ãŸï¼

ã¡ã‚‡ã£ã¨ã—ãŸäº‹ã§ã™ãŒã€é¸æŠçŠ¶æ…‹ã‚’å¤‰ãˆãªã„ã¨åœ°çƒå„€ã‚’å›ã›ãªã„ã§ã™ã€‚
å›½ã‚’é¸æŠã—ã¦ã‹ã‚‰åœ°çƒå„€ã‚’å›è»¢ã•ã›ã‚‹ã¨é¸æŠç¯„å›²ãŒå¤‰ã‚ã‚Šã¾ã™ã€‚

ä¿®æ­£ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚
æ€ã„ã¤ãé™ã‚Šã§ã¯2ã¤ã®äº‹ãŒç¢ºèªã§ãã¾ã™ã€‚
ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‹ã‚‰æ‰‹æ”¾ã™ã¾ã§ã«ã©ã‚Œã ã‘ã®æ™‚é–“ãŒçµŒéã—ãŸã‹ã€‚
ã‚‚ã†1ã¤ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå®Ÿéš›ã«ãƒã‚¦ã‚¹ã‚’å‹•ã‹ã—ãŸã‹ã©ã†ã‹ã§ã™ã€‚
æ™‚é–“ãŒçŸ­ã‹ã£ãŸã‚Šã€ãƒã‚¦ã‚¹ã‚’å‹•ã‹ã•ãªã‹ã£ãŸå ´åˆã¯ã‚¯ãƒªãƒƒã‚¯ã ã£ãŸã®ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ã€‚
ãã†ã§ãªã‘ã‚Œã°ã€åœ°çƒã‚’å¼•ã£å¼µã£ã¦ã„ã“ã†ã¨ã—ã¦ã„ãŸã®ã§ã—ã‚‡ã†ã€‚

```js
+const maxClickTimeMs = 200;
+const maxMoveDeltaSq = 5 * 5;
+const startPosition = {};
+let startTimeMs;
+
+function recordStartTimeAndPosition(event) {
+  startTimeMs = performance.now();
+  const pos = getCanvasRelativePosition(event);
+  startPosition.x = pos.x;
+  startPosition.y = pos.y;
+}

function getCanvasRelativePosition(event) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (event.clientX - rect.left) * canvas.width  / rect.width,
    y: (event.clientY - rect.top ) * canvas.height / rect.height,
  };
}

function pickCountry(event) {
  // exit if we have not loaded the data yet
  if (!countryInfos) {
    return;
  }

+  // if it's been a moment since the user started
+  // then assume it was a drag action, not a select action
+  const clickTimeMs = performance.now() - startTimeMs;
+  if (clickTimeMs > maxClickTimeMs) {
+    return;
+  }
+
+  // if they moved assume it was a drag action
+  const position = getCanvasRelativePosition(event);
+  const moveDeltaSq = (startPosition.x - position.x) ** 2 +
+                      (startPosition.y - position.y) ** 2;
+  if (moveDeltaSq > maxMoveDeltaSq) {
+    return;
+  }

-  const position = {x: event.clientX, y: event.clientY};
  const id = pickHelper.pick(position, pickingScene, camera);
  if (id > 0) {
    const countryInfo = countryInfos[id - 1];
    const selected = !countryInfo.selected;
    if (selected && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
      unselectAllCountries();
    }
    numCountriesSelected += selected ? 1 : -1;
    countryInfo.selected = selected;
    setPaletteColor(id, selected ? selectedColor : unselectedColor);
    paletteTexture.needsUpdate = true;
  } else if (numCountriesSelected) {
    unselectAllCountries();
  }
  requestRenderIfNotRequested();
}

function unselectAllCountries() {
  numCountriesSelected = 0;
  countryInfos.forEach((countryInfo) => {
    countryInfo.selected = false;
  });
  resetPalette();
}

+canvas.addEventListener('pointerdown', recordStartTimeAndPosition);
canvas.addEventListener('pointerup', pickCountry);
```

ã“ã‚Œã‚‰ã®å¤‰æ›´ã‚’åŠ ãˆã‚‹ã¨ç§ã«ã¯ãã‚ŒãŒæ©Ÿèƒ½ã—ã¦ã„ã‚‹ã‚ˆã†ã«*è¦‹ãˆã¾ã™*ã€‚

{{{example url="../threejs-indexed-textures-picking-debounced.html" }}}

ç§ã¯UXã®å°‚é–€å®¶ã§ã¯ãªã„ã®ã§ã€ã‚‚ã£ã¨è‰¯ã„è§£æ±ºç­–ãŒã‚ã‚Œã°æ•™ãˆã¦ä¸‹ã•ã„ã€‚

ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãŒã©ã®ã‚ˆã†ã«å½¹ç«‹ã¤ã®ã‹ã€ã¾ãŸã€three.jsãŒä½œã‚‹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚’å¤‰æ›´ã—ã¦ã‚·ãƒ³ãƒ—ãƒ«ãªæ©Ÿèƒ½ã‚’è¿½åŠ ã™ã‚‹æ–¹æ³•ãŒå°‘ã—ã§ã‚‚ç†è§£ã—ã¦ã‚‚ã‚‰ãˆãŸã¨æ€ã„ã¾ã™ã€‚
ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãŒæ›¸ã‹ã‚Œã¦ã„ã‚‹è¨€èªã®GLSLã®ä½¿ã„æ–¹ã¯ã€ã“ã®è¨˜äº‹ã§æ‰±ã†ã«ã¯å†…å®¹ãŒå¤§ãã™ãã¾ã™ã€‚
[ãƒã‚¹ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã®è¨˜äº‹](threejs-post-processing.html)ã«GLSLã®ãƒªãƒ³ã‚¯ãŒã‚ã‚‹ã®ã§ç¢ºèªã—ã¦ã¿ã¦ä¸‹ã•ã„ã€‚
