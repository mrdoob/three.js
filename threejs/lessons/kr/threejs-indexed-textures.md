Title: í”¼í‚¹ê³¼ ìƒ‰ìƒì— ì¸ë±ìŠ¤ í…ìŠ¤ì²˜ ì‚¬ìš©í•˜ê¸°
Description: ì¸ë±ìŠ¤ í…ìŠ¤ì²˜ë¥¼ ì‚¬ìš©í•´ í”¼í‚¹ì„ êµ¬í˜„í•˜ê³ , ìƒ‰ìƒì„ ì •í•˜ëŠ” ë²•ì„ ì•Œì•„ë´…ë‹ˆë‹¤
TOC: í”¼í‚¹ê³¼ ìƒ‰ìƒì— ì¸ë±ìŠ¤ í…ìŠ¤ì²˜ ì‚¬ìš©í•˜ê¸°

â€» ì´ ê¸€ì€ [HTML ìš”ì†Œë¥¼ 3Dë¡œ ì •ë ¬í•˜ê¸°](threejs-align-html-elements-to-3d.html)ì—ì„œ ì´ì–´ì§‘ë‹ˆë‹¤. ì´ì „ ê¸€ì„ ì½ì§€ ì•Šì•˜ë‹¤ë©´ ë¨¼ì € ì½ê³  ì˜¤ê¸° ë°”ëë‹ˆë‹¤.


Three.jsë¥¼ ì“°ë‹¤ë³´ë©´ ì°½ì˜ì ì¸ í•´ê²°ë²•ì´ í•„ìš”í•  ë•Œê°€ ìˆìŠµë‹ˆë‹¤. ì €ë„ ë‚˜ë¦„ ì‹œë¦¬ì¦ˆë¥¼ ì§„í–‰í•˜ë©° ë‚˜ë¦„ ë§ì€ í•´ê²°ë²•ì„ ì°¾ê³ , ì ì–´ ë†“ì•˜ì£ . í˜¹ í•„ìš”í•œ ê²Œ ìˆë‹¤ë©´ í™•ì¸í•´ë³´ê¸° ë°”ëë‹ˆë‹¤. ë¬¼ë¡  ê·¸ê²Œ ìµœì ì˜ í•´ê²°ë²•ì´ë¼ê³  ë‹¨ì–¸í•  ìˆ˜ëŠ” ì—†ì§€ë§Œìš”.

[ì´ì „ ê¸€](threejs-align-html-elements-to-3d.html)ì—ì„œëŠ” 3D ì§€êµ¬ë³¸ ì£¼ìœ„ì— ë‚˜ë¼ ì´ë¦„ì„ í‘œê¸°í–ˆìŠµë‹ˆë‹¤. ì—¬ê¸°ì„œ ë” ë‚˜ì•„ê°€ ì‚¬ìš©ìê°€ ë‚˜ë¼ë¥¼ ì„ íƒí•˜ê³  ìê¸°ê°€ ì„ íƒí•œ ë‚˜ë¼ë¥¼ ë³´ê²Œ í•œë‹¤ë©´ ì–´ë–¨ê¹Œìš”? ë˜ ì–´ë–»ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆì„ê¹Œìš”?

ê°€ì¥ ì‰½ê²Œ ë– ì˜¤ë¥´ëŠ” ë°©ë²•ì€ ê° ë‚˜ë¼ë§ˆë‹¤ geometryë¥¼ ë§Œë“œëŠ” ê²ë‹ˆë‹¤. ì´ì „ì— í–ˆë˜ ê²ƒì²˜ëŸ¼ [í”¼í‚¹(picking)](threejs-picking.html)ì„ ì¨ì„œ êµ¬í˜„í•  ìˆ˜ ìˆê² ì£ . ì´ë¯¸ ê° ë‚˜ë¼ì˜ 3D geometryëŠ” ë§Œë“¤ì—ˆìœ¼ë‹ˆ ì‚¬ìš©ìê°€ meshë¥¼ í´ë¦­í–ˆì„ ë•Œ ì–´ë–¤ ë‚˜ë¼ë¥¼ í´ë¦­í–ˆëŠ”ì§€ ì•Œ ìˆ˜ ìˆì„ ê²ë‹ˆë‹¤.

ì‹œí—˜ì‚¼ì•„ [ì´ì „ ê¸€](threejs-align-html-elements-to-3d.html)ì—ì„œ ìœ¤ê³½ì„ ì„ ë§Œë“¤ê¸° ìœ„í•´ ì‚¬ìš©í–ˆë˜ ë°ì´í„°ë¡œ ê° ë‚˜ë¼ë§ˆë‹¤ 3D meshë¥¼ ë§Œë“¤ì–´ë´¤ìŠµë‹ˆë‹¤. ê²°ê³¼ë¡œ 15.5MBì§œë¦¬ GLTF(.glb) íŒŒì¼ì´ ë‚˜ì™”ì£ . ì‚¬ìš©ìê°€ ê°„ë‹¨í•œ ì§€êµ¬ë³¸ì„ ë³´ë ¤ê³  15.5MBë‚˜ ë‹¤ìš´ ë°›ì•„ì•¼ í•œë‹¤ë‹ˆ, ê°œì¸ì ì¸ ì˜ê²¬ì´ì§€ë§Œ ë„ˆë¬´ ê³¼í•œ ë“¯í•©ë‹ˆë‹¤.

ë°ì´í„°ë¥¼ ì••ì¶•í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ì•¼ ë§ìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ íŠ¹ì • ì•Œê³ ë¦¬ì¦˜ì„ ë„ì…í•´ ìœ¤ê³½ì„ ì˜ í•´ìƒë„ë¥¼ ë‚®ì¶œ ìˆ˜ ìˆì£ . ì´ ê¸€ì—ì„œëŠ” ì‹œë„í•˜ì§€ ì•Šì„ í…ë°, ì´ìœ ëŠ” ë¯¸êµ­ì˜ ê²½ìš° ë°ì´í„°ë¥¼ ë§ì´ ì¤„ì¼ ìˆ˜ ìˆê² ì§€ë§Œ ìºë‚˜ë‹¤ë‚˜ ì„¬ì´ ë§ì€ ë‚˜ë¼ëŠ” ê·¸ë ‡ì§€ ì•Šì„ ê²ƒì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

ë‹¤ë¥¸ ë°©ë²•ì€ ì‹¤ì œ ë°ì´í„°ë¥¼ ì „ë¶€ ì••ì¶•í•˜ëŠ” ê²ë‹ˆë‹¤. ì••ì¶• í”„ë¡œê·¸ë¨ì„ ëŒë ¤ ì••ì¶•í•˜ë‹ˆ ìš©ëŸ‰ì´ 11MBê¹Œì§€ ì¤„ë”êµ°ìš”. 30% ì •ë„ ì¤„ê¸´ í–ˆì§€ë§Œ ì—¬ì „íˆ í° íŒŒì¼ì…ë‹ˆë‹¤.

32ë¹„íŠ¸ ë¶€ë™ ì†Œìˆ˜ ëŒ€ì‹  16ë¹„íŠ¸ ë°©ì‹ìœ¼ë¡œ ë°ì´í„°ë¥¼ ì €ì¥í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ë˜ëŠ” [ë“œë ˆì´ì½” ì••ì¶•ê¸°](https://google.github.io/draco/) ê°™ì€ í”„ë¡œê·¸ë¨ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒë§Œìœ¼ë¡œ ì¶©ë¶„íˆ ë°ì´í„°ë¥¼ ì¤„ì¼ ìˆ˜ ìˆì„ì§€ë„ ëª¨ë¥´ì£ . ì „ ë”°ë¡œ ë“œë ˆì´ì½” ì••ì¶•ê¸°ë¥¼ ì‚¬ìš©í•´ë³´ì§„ ì•Šì•˜ìœ¼ë‹ˆ ì—¬ëŸ¬ë¶„ì´ í•œ ë²ˆ ì¨ë³´ì‹œê³  ì•Œë ¤ì£¼ì‹ ë‹¤ë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤ ğŸ˜….

ì´ ê¸€ì—ì„œëŠ” [í”¼í‚¹ì— ê´€í•œ ê¸€](threejs-picking.html) ë§ˆì§€ë§‰ì—ì„œ ë‹¤ë¤˜ë˜ [GPU í”¼í‚¹](threejs-picking.html)ì„ ì‚¬ìš©í•´ë³´ê² ìŠµë‹ˆë‹¤. ê° meshì— id ì—­í• ì„ í•  ê³ ìœ í•œ ìƒ‰ì„ ë¶€ì—¬í•˜ê³  í•´ë‹¹ meshë¥¼ í´ë¦­í–ˆì„ ë•Œ í•´ë‹¹ í”½ì…€ì˜ ìƒ‰ìƒê°’ìœ¼ë¡œ ì‚¬ìš©ìê°€ ì–´ë–¤ meshë¥¼ í´ë¦­í–ˆëŠ”ì§€ ì•Œì•„ë‚´ëŠ” ë°©ë²•ì´ì£ .

ì¼ë‹¨ ê° ë‚˜ë¼ì— ê³ ìœ í•œ ìƒ‰ìƒì„ ë¶€ì—¬í•œ ë’¤, ì´ ìƒ‰ìƒê°’ì„ ì¸ë±ìŠ¤ë¡œ ë‚˜ë¼ ë°°ì—´ì„ ë§Œë“­ë‹ˆë‹¤. ê·¸ë¦¬ê³  í”¼í‚¹ìš© í…ìŠ¤ì²˜ë¥¼ ë§Œë“  ë’¤ ì´ê±¸ë¡œ ì§€êµ¬ë³¸ì„ ë Œë”ë§í•©ë‹ˆë‹¤. ì´ëŸ¬ë©´ ì‚¬ìš©ìê°€ í´ë¦­í•œ í”½ì…€ì„ í™•ì¸í•´ ì–´ë–¤ ë‚˜ë¼ë¥¼ í´ë¦­í–ˆëŠ”ì§€ ì•Œ ìˆ˜ ìˆê² ì£ .

ë¨¼ì € [ì•½ê°„ì˜ ì½”ë“œ](https://github.com/gfxfundamentals/threejsfundamentals/blob/master/threejs/lessons/tools/geo-picking/)ë¥¼ ì‘ì„±í•´ ì•„ë˜ì˜ í…ìŠ¤ì²˜ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.

<div class="threejs_center"><img src="../resources/data/world/country-index-texture.png" style="width: 700px;"></div>

> ì°¸ê³ : ì´ í…ìŠ¤íŠ¸ë¥¼ ë§Œë“œëŠ” ë° ì‚¬ìš©í•œ ë°ì´í„°ëŠ” ì´ [ì›¹ì‚¬ì´íŠ¸](http://thematicmapping.org/downloads/world_borders.php)ì´ë©°, ë¼ì´ì„ ìŠ¤ëŠ” [CC-BY-SA](http://creativecommons.org/licenses/by-sa/3.0/)ì…ë‹ˆë‹¤.

ì´ ì´ë¯¸ì§€ëŠ” 271KB ì •ë„ë°–ì— ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‚˜ë¼ë“¤ì˜ meshê°€ 14MBê°€ ë„˜ì—ˆë˜ ê²ƒì— ë¹„í•˜ë©´ í›¨ì”¬ ë‚«ë„¤ìš”. ë¬¼ë¡  í•´ìƒë„ë¥¼ ë” ë‚®ì¶œ ìˆ˜ë„ ìˆì§€ë§Œ ì´ ì •ë„ë©´ ì¶©ë¶„í•œ ê²ƒ ê°™ë„¤ìš”.

ì´ì œ ë‚˜ë¼ì— í”¼í‚¹ì„ ì ìš©í•´ ë´…ì‹œë‹¤.

[GPU í”¼í‚¹ ì˜ˆì œ](threejs-picking.html)ì˜ ì½”ë“œë¥¼ ê°€ì ¸ì™€ í”¼í‚¹ìš© ì¥ë©´(scene)ì„ ë”°ë¡œ ë§Œë“­ë‹ˆë‹¤.

```js
const pickingScene = new THREE.Scene();
pickingScene.background = new THREE.Color(0);
```

í”¼í‚¹ìš© ì¥ë©´ì— í”¼í‚¹ìš© í…ìŠ¤ì²˜ë¥¼ ì…íŒ ì§€êµ¬ë³¸ì„ ì¶”ê°€í•©ë‹ˆë‹¤.

```js
{
  const loader = new THREE.TextureLoader();
  const geometry = new THREE.SphereBufferGeometry(1, 64, 32);

+  const indexTexture = loader.load('resources/data/world/country-index-texture.png', render);
+  indexTexture.minFilter = THREE.NearestFilter;
+  indexTexture.magFilter = THREE.NearestFilter;
+
+  const pickingMaterial = new THREE.MeshBasicMaterial({ map: indexTexture });
+  pickingScene.add(new THREE.Mesh(geometry, pickingMaterial));

  const texture = loader.load('resources/data/world/country-outlines-4k.png', render);
  const material = new THREE.MeshBasicMaterial({ map: texture });
  scene.add(new THREE.Mesh(geometry, material));
}
```

ë‹¤ìŒìœ¼ë¡œ `GPUPickHelper`ë¥¼ í†µì§¸ë¡œ ê°€ì ¸ì™€ ëª‡ ê°€ì§€ ìˆ˜ì •í•©ë‹ˆë‹¤.

```js
class GPUPickHelper {
  constructor() {
    // 1x1 í”½ì…€ í¬ê¸°ì˜ ë Œë” íƒ€ê²Ÿì„ ìƒì„±í•©ë‹ˆë‹¤
    this.pickingTexture = new THREE.WebGLRenderTarget(1, 1);
    this.pixelBuffer = new Uint8Array(4);
-    this.pickedObject = null;
-    this.pickedObjectSavedColor = 0;
  }
  pick(cssPosition, scene, camera) {
    const { pickingTexture, pixelBuffer } = this;

    // view offsetì„ ë§ˆìš°ìŠ¤ í¬ì¸í„° ì•„ë˜ 1í”½ì…€ë¡œ ì„¤ì •í•©ë‹ˆë‹¤
    const pixelRatio = renderer.getPixelRatio();
    camera.setViewOffset(
      renderer.getContext().drawingBufferWidth,   // ì „ì²´ ë„ˆë¹„
      renderer.getContext().drawingBufferHeight,  // ì „ì²´ ë†’ì´
      cssPosition.x * pixelRatio | 0,             // ì‚¬ê° x ì¢Œí‘œ
      cssPosition.y * pixelRatio | 0,             // ì‚¬ê° y ì¢Œí‘œ
      1,                                          // ì‚¬ê° ì¢Œí‘œ width
      1,                                          // ì‚¬ê° ì¢Œí‘œ height
    );
    // ì¥ë©´ì„ ë Œë”ë§í•©ë‹ˆë‹¤
    renderer.setRenderTarget(pickingTexture);
    renderer.render(scene, camera);
    renderer.setRenderTarget(null);
    // view offsetì„ ì •ìƒìœ¼ë¡œ ëŒë ¤ ì›ë˜ì˜ í™”ë©´ì„ ë Œë”ë§í•˜ë„ë¡ í•©ë‹ˆë‹¤
    camera.clearViewOffset();
    // í”½ì…€ì„ ê°ì§€í•©ë‹ˆë‹¤
    renderer.readRenderTargetPixels(
        pickingTexture,
        0,   // x
        0,   // y
        1,   // width
        1,   // height
        pixelBuffer);

+    const id =
+        (pixelBuffer[0] << 16) |
+        (pixelBuffer[1] <<  8) |
+        (pixelBuffer[2] <<  0);
+
+    return id;
-    const id =
-        (pixelBuffer[0] << 16) |
-        (pixelBuffer[1] <<  8) |
-        (pixelBuffer[2]      );
-    const intersectedObject = idToObject[id];
-    if (intersectedObject) {
-      // ì²« ë²ˆì§¸ ë¬¼ì²´ê°€ ì œì¼ ê°€ê¹Œìš°ë¯€ë¡œ í•´ë‹¹ ë¬¼ì²´ë¥¼ ê³ ë¦…ë‹ˆë‹¤
-      this.pickedObject = intersectedObject;
-      // ê¸°ì¡´ ìƒ‰ì„ ì €ì¥í•´ë‘¡ë‹ˆë‹¤
-      this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
-      // emissive ìƒ‰ì„ ë¹¨ê°•/ë…¸ë‘ìœ¼ë¡œ ë¹›ë‚˜ê²Œ ë§Œë“­ë‹ˆë‹¤
-      this.pickedObject.material.emissive.setHex((time * 8) % 2 > 1 ? 0xFFFF00 : 0xFF0000);
-    }
  }
}
```

`GPUPickHelper`ë¥¼ ì´ìš©í•´ ë‚˜ë¼ë¥¼ ì„ íƒí•˜ë„ë¡ í•©ë‹ˆë‹¤.

```js
const pickHelper = new GPUPickHelper();

function getCanvasRelativePosition(event) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (event.clientX - rect.left) * canvas.width  / rect.width,
    y: (event.clientY - rect.top ) * canvas.height / rect.height,
  };
}

function pickCountry(event) {
  // ì•„ì§ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ì•Šì•˜ì„ ê²½ìš°
  if (!countryInfos) {
    return;
  }

  const position = getCanvasRelativePosition(event);
  const id = pickHelper.pick(position, pickingScene, camera);
  if (id > 0) {
    // ë‚˜ë¼ë¥¼ ì„ íƒí–ˆì„ ë•Œ í•´ë‹¹ ë‚˜ë¼ì˜ 'selected' ì†ì„±ì„ ë°”ê¿‰ë‹ˆë‹¤.
    const countryInfo = countryInfos[id - 1];
    const selected = !countryInfo.selected;
    // ë‚˜ë¼ë¥¼ í´ë¦­í–ˆì„ ë•Œ íŠ¹ìˆ˜í‚¤ë¥¼ ëˆ„ë¥´ì§€ ì•Šì•˜ë‹¤ë©´ ë‹¤ë¥¸ ë‚˜ë¼ì˜ 'selected'
    // ì†ì„±ì„ ì „ë¶€ ë•ë‹ˆë‹¤.
    if (selected && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
      unselectAllCountries();
    }
    numCountriesSelected += selected ? 1 : -1;
    countryInfo.selected = selected;
  } else if (numCountriesSelected) {
    // ë°”ë‹¤ë‚˜ í•˜ëŠ˜ì„ í´ë¦­í–ˆì„ ê²½ìš°
    unselectAllCountries();
  }
  requestRenderIfNotRequested();
}

function unselectAllCountries() {
  numCountriesSelected = 0;
  countryInfos.forEach((countryInfo) => {
    countryInfo.selected = false;
  });
}

canvas.addEventListener('mouseup', pickCountry);

let lastTouch;
canvas.addEventListener('touchstart', (event) => {
  // ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
  event.preventDefault();
  lastTouch = event.touches[0];
}, { passive: false });
canvas.addEventListener('touchmove', (event) => {
  lastTouch = event.touches[0];
});
canvas.addEventListener('touchend', () => {
  pickCountry(lastTouch);
});
```

ìœ„ ì½”ë“œëŠ” ë‚˜ë¼ ë°°ì—´ì— ì†í•œ ë‚˜ë¼ì˜ `selected` ì†ì„±ì„ ì¼œê³  ë•ë‹ˆë‹¤. `shift`, `ctrl`, `cmd` ì¤‘ í•˜ë‚˜ë¥¼ ëˆ„ë¥´ë©´ í•˜ë‚˜ ì´ìƒì˜ ë‚˜ë¼ë¥¼ ì„ íƒí•  ìˆ˜ ìˆì£ .

ì´ì œ ì„ íƒí•œ ë‚˜ë¼ë¥¼ ë³´ì—¬ì¤„ ì¼ë§Œ ë‚¨ì•˜ìŠµë‹ˆë‹¤. ì§€ê¸ˆì€ ì¼ë‹¨ í•´ë‹¹ ë‚˜ë¼ì˜ ì´ë¦„í‘œë¥¼ ë³´ì—¬ì£¼ê¸°ë¡œ í•˜ì£ .

```js
function updateLabels() {
  // ì•„ì§ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ì•Šì•˜ì„ ê²½ìš°
  if (!countryInfos) {
    return;
  }

  const large = settings.minArea * settings.minArea;
  // ì¹´ë©”ë¼ì˜ ìƒëŒ€ ë°©í–¥ì„ ë‚˜íƒ€ë‚´ëŠ” í–‰ë ¬ ì¢Œí‘œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
  normalMatrix.getNormalMatrix(camera.matrixWorldInverse);
  // ì¹´ë©”ë¼ì˜ ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
  camera.getWorldPosition(cameraPosition);
  for (const countryInfo of countryInfos) {
-    const { position, elem, area } = countryInfo;
-    // ì˜ì—­ì´ íŠ¹ì • ê°’ë³´ë‹¤ ì‘ë‹¤ë©´ ì´ë¦„í‘œë¥¼ í‘œì‹œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
-    if (area < large) {
+    const { position, elem, area, selected } = countryInfo;
+    const largeEnough = area >= large;
+    const show = selected || (numCountriesSelected === 0 && largeEnough);
+    if (!show) {
      elem.style.display = 'none';
      continue;
    }

    ...
```

ì´ì œ ë‚˜ë¼ë¥¼ ì„ íƒí•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

{{{example url="../threejs-indexed-textures-picking.html" }}}

ìœ„ ì˜ˆì œëŠ” ì—¬ì „íˆ ì˜ì—­ í¬ê¸°ì— ë”°ë¼ ë‚˜ë¼ ì´ë¦„ì„ ë³´ì—¬ì£¼ê¸´ í•˜ë‚˜, íŠ¹ì • ë‚˜ë¼ë¥¼ í´ë¦­í•˜ë©´ í•´ë‹¹ ë‚˜ë¼ì˜ ì´ë¦„ë§Œ ë³´ì—¬ì¤„ ê²ë‹ˆë‹¤.

ì´ë§Œí•˜ë©´ ê° ë‚˜ë¼ë¥¼ í”¼í‚¹í•˜ëŠ” ì˜ˆì œë¡œ ì¶©ë¶„í•´ ë³´ì´ì§€ë§Œ... ì„ íƒí•œ ë‚˜ë¼ì˜ ìƒ‰ì„ ë°”ê¾¸ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œìš”?

*ì»¬ëŸ¬ íŒ”ë ˆíŠ¸(color palette)*ë¥¼ ì‚¬ìš©í•˜ë©´ ì´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

[ì»¬ëŸ¬ íŒ”ë ˆíŠ¸](https://ko.wikipedia.org/wiki/%ED%8C%94%EB%A0%88%ED%8A%B8_(%EC%BB%B4%ED%93%A8%ED%8C%85)) í˜¹ì€ [ì¸ë±ìŠ¤ íŒ”ë ˆíŠ¸](https://en.wikipedia.org/wiki/Indexed_color)ëŠ” ì•„íƒ€ë¦¬ 800, Amiga, NES, ìŠˆí¼ ë‹Œí…ë„, êµ¬í˜• IBM PC ë“± êµ¬í˜• ì‹œìŠ¤í…œì—ì„œ ì‚¬ìš©í•˜ë˜ ê¸°ë²•ì…ë‹ˆë‹¤. ë¹„íŠ¸ë§µì„ ìƒ‰ìƒë‹¹ 8ë¹„íŠ¸ í˜¹ì€ 24ë°”ì´íŠ¸ ì´ìƒì˜ RGB ìƒ‰ìƒìœ¼ë¡œ ì ìš©í•˜ëŠ” ëŒ€ì‹  ë¹„íŠ¸ë§µì„ 8ë¹„íŠ¸ ì´í•˜ì˜ ê°’ìœ¼ë¡œ ì €ì¥í•˜ëŠ” ê¸°ë²•ì´ì£ . ê° í”½ì…€ì˜ ìƒ‰ìƒê°’ì€ íŒ”ë ˆíŠ¸ì˜ ì¸ë±ìŠ¤ ê°’ìœ¼ë¡œ, í”½ì…€ì˜ ìƒ‰ìƒê°’ì´ 3ì´ë¼ë©´ íŠ¹ì • "íŒ”ë ˆíŠ¸"ì˜ 3ë²ˆ ìƒ‰ìƒì„ ì‚¬ìš©í•œë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.

ìë°”ìŠ¤í¬ë¦½íŠ¸ë¡œ ì„¤ëª…í•˜ìë©´ ì•„ë˜ì™€ ê°™ì€ í˜•ì‹ì„ ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```js
const face7x7PixelImageData = [
  0, 1, 1, 1, 1, 1, 0,
  1, 0, 0, 0, 0, 0, 1, 
  1, 0, 2, 0, 2, 0, 1,
  1, 0, 0, 0, 0, 0, 1,
  1, 0, 3, 3, 3, 0, 1,
  1, 0, 0, 0, 0, 0, 1,
  0, 1, 1, 1, 1, 1, 1,
];

const palette = [
  [255, 255, 255],  // white
  [  0,   0,   0],  // black
  [  0, 255, 255],  // cyan
  [255,   0,   0],  // red
];
```

ì´ë¯¸ì§€ ë°ì´í„°ì˜ ê° í”½ì…€ì€ íŒ”ë ˆíŠ¸ì˜ ì¸ë±ìŠ¤ë¥¼ ê°€ë¦¬í‚µë‹ˆë‹¤. ìœ„ ë°ì´í„°ë¥¼ ìœ„ íŒ”ë ˆíŠ¸ë¡œ í•´ì„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ì´ë¯¸ì§€ê°€ ë‚˜ì˜¤ê² ì£ .

<div class="threejs_center"><img src="resources/images/7x7-indexed-face.png"></div>

ì˜ˆì œì˜ ê²½ìš° ì´ë¯¸ ê° ë‚˜ë¼ë³„ë¡œ ê³ ìœ  ìƒ‰ì„ ë¶€ì—¬í•œ í…ìŠ¤ì²˜ê°€ ìˆìŠµë‹ˆë‹¤. ì´ í…ìŠ¤ì²˜ì— íŒ”ë ˆíŠ¸ë¥¼ ì ìš©í•˜ë©´ ê° ë‚˜ë¼ì— ë‹¤ë¥¸ ìƒ‰ì„ ë¶€ì—¬í•  ìˆ˜ ìˆê² ì£ . ë˜ ì´ íŒ”ë ˆíŠ¸ì˜ ìƒ‰ì„ ë°”ê¾¸ë©´ ê° ë‚˜ë¼ì˜ ìƒ‰ë„ ë°”ë€” ê²ë‹ˆë‹¤. ê·¸ëŸ¬ë‹ˆ íŒ”ë ˆíŠ¸ì˜ ìƒ‰ì„ ì „ë¶€ ê²€ì •ìœ¼ë¡œ ë°”ê¾¼ ë’¤, ì„ íƒí•œ ë‚˜ë¼ë§Œ ë‹¤ë¥¸ ìƒ‰ìœ¼ë¡œ ë°”ê¾¸ë©´ í•´ë‹¹ ë‚˜ë¼ë¥¼ ì„ íƒí–ˆë‹¤ëŠ” ê²ƒì„ ì‹œê°ì ìœ¼ë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆì„ ê²ë‹ˆë‹¤.

ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ ê¸°ë²•ì„ ì‚¬ìš©í•˜ë ¤ë©´ ì‰ì´ë”ë¥¼ ì§ì ‘ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤. Three.jsì˜ ë‚´ì¥ ì‰ì´ë”ë¥¼ ìˆ˜ì •í•´ì„œ ì‚¬ìš©í•˜ë©´ ì¡°ëª…ì´ë‚˜ ë‹¤ë¥¸ ê¸°ëŠ¥ë„ ë‚˜ì¤‘ì— ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë‹ˆ ì´ ë°©ë²•ì„ ì‚¬ìš©í•˜ë„ë¡ í•˜ì£ .

[ë‹¤ì¤‘ ì• ë‹ˆë©”ì´ì…˜ ìš”ì†Œ ìµœì í™”í•˜ê¸°](threejs-optimize-lots-of-objects-animated.html)ì—ì„œ ë‹¤ë¤˜ë“¯ ì¬ì§ˆì˜ `onBeforeCompile` ì†ì„±ì— í•¨ìˆ˜ë¥¼ ì§€ì •í•˜ë©´ ë‚´ì¥ ì‰ì´ë”ë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì•„ë˜ëŠ” ë‚´ì¥ fragment ì‰ì´ë”ë¥¼ ìˆ˜ì •í•˜ê¸° ì „ì…ë‹ˆë‹¤.

```glsl
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}
```

[ìœ„ ì½”ë“œì˜ ì‰ì´ë” ì¡°ê°](https://github.com/mrdoob/three.js/tree/dev/src/renderers/shaders/ShaderChunk)ì„ ì¼ì¼ì´ ë’¤ì ¸ ë³´ë‹ˆ Three.jsëŠ” `diffuseColor`ë¼ëŠ” ë³€ìˆ˜ë¡œ ì¬ì§ˆ(material)ì˜ ìƒ‰ìƒê°’ì„ ì œì–´í•©ë‹ˆë‹¤. ì´ ë³€ìˆ˜ëŠ” `<color_fragment>`ë¼ëŠ” [ì‰ì´ë” ì¡°ê°](https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/color_fragment.glsl.js)ì—ì„œ ì„ ì–¸í•˜ë‹ˆ ë³€ìˆ˜ ì„ ì–¸ í›„ì— ìƒ‰ìƒê°’ì„ ìˆ˜ì •í•˜ë©´ ë˜ê² ë„¤ìš”.

ì € ë•Œ `diffuseColor`ëŠ” ì•„ê¹Œ ë§Œë“¤ì—ˆë˜ ìœ¤ê³½ì„  í…ìŠ¤ì²˜ì—ì„œ ìƒ‰ìƒì„ ê°€ì ¸ì˜¨ ìƒíƒœì¼ í…Œë‹ˆ, ì´ ìƒ‰ìƒê°’ìœ¼ë¡œ íŒ”ë ˆíŠ¸ í…ìŠ¤ì²˜ì—ì„œ ìƒˆë¡œìš´ ìƒ‰ìƒê°’ì„ ê°€ì ¸ ì˜¬ ìˆ˜ ìˆì„ ê²ë‹ˆë‹¤.

[ì´ì „ì— í–ˆë˜ ê²ƒ](threejs-optimize-lots-of-objects-animated.html)ì²˜ëŸ¼ ë°”ê¿€ ë¬¸ìì—´ ì •ë³´ë¥¼ ë°°ì—´ë¡œ ë§Œë“¤ì–´ `Material.onBeforeCompile`ì—ì„œ ì‰ì´ë”ë¥¼ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤.

```js
{
  const loader = new THREE.TextureLoader();
  const geometry = new THREE.SphereBufferGeometry(1, 64, 32);

  const indexTexture = loader.load('resources/data/world/country-index-texture.png', render);
  indexTexture.minFilter = THREE.NearestFilter;
  indexTexture.magFilter = THREE.NearestFilter;

  const pickingMaterial = new THREE.MeshBasicMaterial({ map: indexTexture });
  pickingScene.add(new THREE.Mesh(geometry, pickingMaterial));

+  const fragmentShaderReplacements = [
+    {
+      from: '#include <common>',
+      to: `
+        #include <common>
+        uniform sampler2D indexTexture;
+        uniform sampler2D paletteTexture;
+        uniform float paletteTextureWidth;
+      `,
+    },
+    {
+      from: '#include <color_fragment>',
+      to: `
+        #include <color_fragment>
+        {
+          vec4 indexColor = texture2D(indexTexture, vUv);
+          float index = indexColor.r * 255.0 + indexColor.g * 255.0 * 256.0;
+          vec2 paletteUV = vec2((index + 0.5) / paletteTextureWidth, 0.5);
+          vec4 paletteColor = texture2D(paletteTexture, paletteUV);
+          // diffuseColor.rgb += paletteColor.rgb;   // í•˜ì–€ ìœ¤ê³½ì„ 
+          diffuseColor.rgb = paletteColor.rgb - diffuseColor.rgb;  // ê²€ì€ ìœ¤ê³½ì„ 
+        }
+      `,
+    },
+  ];

  const texture = loader.load('resources/data/world/country-outlines-4k.png', render);
  const material = new THREE.MeshBasicMaterial({ map: texture });
+  material.onBeforeCompile = function(shader) {
+    fragmentShaderReplacements.forEach((rep) => {
+      shader.fragmentShader = shader.fragmentShader.replace(rep.from, rep.to);
+    });
+  };
  scene.add(new THREE.Mesh(geometry, material));
}
```

ìœ„ ì½”ë“œì—ì„œëŠ” `indexTexture`, `paletteTexture`, `paletteTextureWidth`, ì´ 3ê°œì˜ ê· ë“± ë³€ìˆ˜(uniform)ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. `indexTexture`ëŠ” ìƒ‰ìƒê°’ì„ ë¶ˆëŸ¬ì™€ ì¸ë±ìŠ¤ë¡œ ë³€í™˜í•˜ê¸° ìœ„í•œ ê²ƒìœ¼ë¡œ, ì´ë•Œ ì‚¬ìš©í•œ `vUv`ëŠ” Three.jsê°€ ë„˜ê²¨ì£¼ëŠ” í…ìŠ¤ì²˜ ì¢Œí‘œì´ì£ . ê·¸ë¦¬ê³  ì´ ì¸ë±ìŠ¤ ê°’ìœ¼ë¡œ ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ì—ì„œ ìƒˆë¡œìš´ ìƒ‰ìƒê°’ì„ ê°€ì ¸ ì™€ `diffuseColor`ì™€ ì„ì—ˆìŠµë‹ˆë‹¤. ì´ë•Œ `diffuseColor`ëŠ” ê²€ì€ë°”íƒ•ì— í•˜ì–€ìƒ‰ ìœ¤ê³½ì„  í…ìŠ¤ì²˜ì´ë‹ˆ ë‘ ìƒ‰ì„ ë”í•´ë„ í•˜ì–€ ìœ¤ê³½ì„ ì´ ë‚˜ì˜¬ ê²ë‹ˆë‹¤. ëŒ€ì‹  ìƒˆë¡œìš´ ìƒ‰ì—ì„œ `diffuseColor`ë¥¼ ëº€ë‹¤ë©´ ê²€ì€ ìœ¤ê³½ì„ ì´ ë‚˜ì˜¤ê² ì£ .

ë‹¤ìŒìœ¼ë¡œ ë Œë”ë§ ì „ì— íŒ”ë ˆíŠ¸ í…ìŠ¤ì²˜ì™€ 3ê°œì˜ ê· ë“± ë³€ìˆ˜ë¥¼ ì§€ì •í•´ì•¼ í•©ë‹ˆë‹¤.

íŒ”ë ˆíŠ¸ í…ìŠ¤ì²˜ì—ëŠ” ë‚˜ë¼ë‹¹ í•˜ë‚˜ì˜ ìƒ‰ìƒê³¼ ë°”ë‹¤ì˜ ìƒ‰ìƒ(id = 0) í•˜ë‚˜ë§Œ í•„ìš”í•©ë‹ˆë‹¤. ì „ ì„¸ê³„ì ìœ¼ë¡œ ì•½ 240ì—¬ ê°œì˜ ë‚˜ë¼ê°€ ìˆì£ . ë‚˜ë¼ ë°°ì—´ì„ ë¶ˆëŸ¬ì˜¬ ë•Œê¹Œì§€ ê¸°ë‹¤ë ¸ë‹¤ê°€ ì •í™•í•œ ê°œìˆ˜ë¥¼ ë°›ì•„ì˜¬ ìˆ˜ë„ ìˆì„ ê²ë‹ˆë‹¤. í•˜ì§€ë§Œ ë‹¹ì¥ ìˆ«ìê°€ í¬ë‹¤ê³  ë¬¸ì œê°€ ë  ê²ƒ ê°™ì§€ëŠ” ì•Šìœ¼ë‹ˆ 512 ì •ë„ì˜ í° ìˆ«ìë¥¼ ê³ ë¥´ê¸°ë¡œ í•©ì‹œë‹¤.

ì•„ë˜ëŠ” íŒ”ë ˆíŠ¸ í…ìŠ¤ì²˜ë¥¼ ë§Œë“œëŠ” ì½”ë“œì…ë‹ˆë‹¤.

```js
const maxNumCountries = 512;
const paletteTextureWidth = maxNumCountries;
const paletteTextureHeight = 1;
const palette = new Uint8Array(paletteTextureWidth * 3);
const paletteTexture = new THREE.DataTexture(
    palette, paletteTextureWidth, paletteTextureHeight, THREE.RGBFormat);
paletteTexture.minFilter = THREE.NearestFilter;
paletteTexture.magFilter = THREE.NearestFilter;
```

`DataTexture`ë¥¼ ì“°ë©´ í…ìŠ¤ì²˜ë¥¼ ë¡œìš°-ë°ì´í„°(raw data) í˜•ì‹ìœ¼ë¡œ ë„˜ê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆì œì˜ ê²½ìš°ì—ëŠ” 512 RGB ìƒ‰ìƒì„ ë„˜ê²¨ì£¼ë©´ ë˜ê² ì£ . ê° ê°’ì€ 3ë°”ì´íŠ¸ë¡œ, ì´ ë°”ì´íŠ¸ëŠ” ê°ê° red, green, blueì„ 0ë¶€í„° 255ê¹Œì§€ì˜ ìˆ«ìë¡œ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.

ì¼ë‹¨ì€ ë¬´ì‘ìœ„ë¡œ ìƒ‰ì„ ì§€ì •í•´ ì˜ ì‘ë™í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸í•´ë´…ì‹œë‹¤.

```js
for (let i = 1; i < palette.length; ++i) {
  palette[i] = Math.random() * 256;
}
// ë°”ë‹¤ì˜ ìƒ‰ì„ ì§€ì •í•©ë‹ˆë‹¤. (index #0)
palette.set([100, 200, 255], 0);
paletteTexture.needsUpdate = true;
```

`palette` ë°°ì—´ë¡œ íŒ”ë ˆíŠ¸ í…ìŠ¤ì²˜ë¥¼ ì—…ë°ì´íŠ¸í•  ë•Œë§ˆë‹¤ ì¥ë©´ì„ ì—…ë°ì´íŠ¸í•´ì•¼ í•˜ë‹ˆ `paletteTexture.needsUpdate`ë¥¼ `true`ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.

ë‹¤ìŒìœ¼ë¡œ ì¬ì§ˆì— ê· ë“± ë³€ìˆ˜ë¥¼ ì„¤ì •í•´ì¤ë‹ˆë‹¤.

```js
const geometry = new THREE.SphereBufferGeometry(1, 64, 32);
const material = new THREE.MeshBasicMaterial({ map: texture });
material.onBeforeCompile = function(shader) {
  fragmentShaderReplacements.forEach((rep) => {
    shader.fragmentShader = shader.fragmentShader.replace(rep.from, rep.to);
  });
+  shader.uniforms.paletteTexture = { value: paletteTexture };
+  shader.uniforms.indexTexture = { value: indexTexture };
+  shader.uniforms.paletteTextureWidth = { value: paletteTextureWidth };
};
scene.add(new THREE.Mesh(geometry, material));
```

ì´ì œ ì˜ˆì œë¥¼ ì‹¤í–‰í•˜ë©´ ê° ë‚˜ë¼ì˜ ìƒ‰ìƒì´ ë¬´ì‘ìœ„ë¡œ ì§€ì •ëœ ê²ƒì´ ë³´ì¼ ê²ë‹ˆë‹¤.

{{{example url="../threejs-indexed-textures-random-colors.html" }}}

ì¸ë±ì‹±ê³¼ íŒ”ë ˆíŠ¸ í…ìŠ¤ì²˜ê°€ ì˜ ì‘ë™í•˜ëŠ” ê²ƒì„ í™•ì¸í–ˆìœ¼ë‹ˆ, ì´ì œ íŒ”ë ˆíŠ¸ë¥¼ ì¡°ì‘í•´ ì„ íƒí•œ ë‚˜ë¼ì˜ ìƒ‰ìƒë§Œ ë°”ê¾¸ë„ë¡ í•´ë´…ì‹œë‹¤.

ë¨¼ì € í•¨ìˆ˜ë¥¼ í•˜ë‚˜ ë§Œë“­ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” Three.jsì˜ `Color`ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ì•„ íŒ”ë ˆíŠ¸ í…ìŠ¤ì²˜ì— ì§€ì •í•  ìˆ˜ ìˆëŠ” ê°’ì„ ë°˜í™˜í•  ê²ë‹ˆë‹¤.

```js
const tempColor = new THREE.Color();
function get255BasedColor(color) {
  tempColor.set(color);
  return tempColor.toArray().map(v => v * 255);
}
```

ìœ„ í•¨ìˆ˜ë¥¼ `color = get255BasedColor('red')`ì™€ ê°™ì€ ì‹ìœ¼ë¡œ í˜¸ì¶œí•˜ë©´ `[255, 0, 0]` ì´ëŸ° ì‹ì˜ ë°°ì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

ë‹¤ìŒìœ¼ë¡œ ìœ„ í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ëª‡ ê°€ì§€ ìƒ‰ì„ ë§Œë“¤ì–´ íŒ”ë ˆíŠ¸ë¥¼ ì±„ì›ë‹ˆë‹¤.

```js
const selectedColor = get255BasedColor('red');
const unselectedColor = get255BasedColor('#444');
const oceanColor = get255BasedColor('rgb(100,200,255)');
resetPalette();

function setPaletteColor(index, color) {
  palette.set(color, index * 3);
}

function resetPalette() {
  // ëª¨ë“  íŒ”ë ˆíŠ¸ì˜ ìƒ‰ìƒì„ unselectedColorë¡œ ë°”ê¿‰ë‹ˆë‹¤.
  for (let i = 1; i < maxNumCountries; ++i) {
    setPaletteColor(i, unselectedColor);
  }

  // ë°”ë‹¤ì˜ ìƒ‰ì„ ì§€ì •í•©ë‹ˆë‹¤. (index #0)
  setPaletteColor(0, oceanColor);
  paletteTexture.needsUpdate = true;
}
```

ì´ì œ `resetPalette` í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ë‚˜ë¼ë¥¼ ì„ íƒí–ˆì„ ë•Œ íŒ”ë ˆíŠ¸ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

```js
function getCanvasRelativePosition(event) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (event.clientX - rect.left) * canvas.width  / rect.width,
    y: (event.clientY - rect.top ) * canvas.height / rect.height,
  };
}

function pickCountry(event) {
  // ì•„ì§ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ì•Šì•˜ì„ ê²½ìš°
  if (!countryInfos) {
    return;
  }

  const position = getCanvasRelativePosition(event);
  const id = pickHelper.pick(position, pickingScene, camera);
  if (id > 0) {
    const countryInfo = countryInfos[id - 1];
    const selected = !countryInfo.selected;
    if (selected && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
      unselectAllCountries();
    }
    numCountriesSelected += selected ? 1 : -1;
    countryInfo.selected = selected;
+    setPaletteColor(id, selected ? selectedColor : unselectedColor);
+    paletteTexture.needsUpdate = true;
  } else if (numCountriesSelected) {
    unselectAllCountries();
  }
  requestRenderIfNotRequested();
}

function unselectAllCountries() {
  numCountriesSelected = 0;
  countryInfos.forEach((countryInfo) => {
    countryInfo.selected = false;
  });
+  resetPalette();
}
```

ì´ì œ ì„ íƒí•œ ë‚˜ë¼ê°€ ê°•ì¡°ë˜ì–´ ë³´ì¼ ê²ë‹ˆë‹¤.

{{{example url="../threejs-indexed-textures-picking-and-highlighting.html" }}}

ì˜ ì‘ë™í•˜ëŠ” ê²ƒ ê°™ë„¤ìš”!

ë‹¤ë§Œ ì§€êµ¬ë³¸ì„ ëŒë¦´ ë•Œë„ ë‚˜ë¼ê°€ ì„ íƒëœë‹¤ëŠ” ê²Œ ê±°ìŠ¬ë¦½ë‹ˆë‹¤. ë˜ ë‚˜ë¼ë¥¼ ì„ íƒí•˜ê³  ì§€êµ¬ë³¸ì„ ëŒë¦¬ë©´ í•´ë‹¹ ì„ íƒì´ í’€ë ¤ë²„ë¦¬ë„¤ìš”.

ë§ˆì§€ë§‰ìœ¼ë¡œ ì´ê²ƒê¹Œì§€ ê³ ì³ë´…ì‹œë‹¤. 2ê°€ì§€ ì •ë„ë¥¼ í™•ì¸í•˜ë©´ ì¶©ë¶„í•  ê²ƒ ê°™ë„¤ìš”. í•˜ë‚˜ëŠ” í¬ì¸í„°ë¥¼ ëˆ„ë¥¸ í›„ ë–¼ê¸°ê¹Œì§€ ì–¼ë§ˆë‚˜ ì‹œê°„ì´ í˜ë €ëŠ”ì§€ë¥¼ í™•ì´í•˜ëŠ” ê²ƒì´ê³ , ë‹¤ë¥¸ í•˜ë‚˜ëŠ” í¬ì¸í„°ê°€ ì›€ì§ì˜€ëŠ”ì§€ í™•ì¸í•˜ëŠ” ê²ë‹ˆë‹¤. ë§ˆìš°ìŠ¤ë¥¼ ë–¼ëŠ” ë° ì‹œê°„ì´ ì–¼ë§ˆ ì•ˆ ê±¸ë ¸ê³  í¬ì¸í„°ê°€ ì›€ì§ì´ì§€ ì•Šì•˜ë‹¤ë©´ í´ë¦­ìœ¼ë¡œ ê°„ì£¼í•˜ëŠ” ê²ƒì´ì£ .

```js
+const maxClickTimeMs = 200;
+const maxMoveDeltaSq = 5 * 5;
+const startPosition = {};
+let startTimeMs;
+
+function recordStartTimeAndPosition(event) {
+  startTimeMs = performance.now();
+  const pos = getCanvasRelativePosition(event);
+  startPosition.x = pos.x;
+  startPosition.y = pos.y;
+}

function getCanvasRelativePosition(event) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (event.clientX - rect.left) * canvas.width  / rect.width,
    y: (event.clientY - rect.top ) * canvas.height / rect.height,
  };
}

function pickCountry(event) {
  // ì•„ì§ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ì•Šì•˜ì„ ê²½ìš°
  if (!countryInfos) {
    return;
  }

+  // í¬ì¸í„°ë¥¼ ëˆ„ë¥¸ í›„ ë–¼ê¸°ê¹Œì§€ ì¼ì • ì‹œê°„ ì´ìƒ ê±¸ë ¸ë‹¤ë©´
+  // ì„ íƒ ì•¡ì…˜ì´ ì•„ë‹Œ ë“œë˜ê·¸ ì•¡ì…˜ìœ¼ë¡œ ê°„ì£¼í•©ë‹ˆë‹¤.
+  const clickTimeMs = performance.now() - startTimeMs;
+  if (clickTimeMs > maxClickTimeMs) {
+    return;
+  }
+
+  // í¬ì¸í„°ê°€ ì›€ì§ì˜€ë‹¤ë©´ ë“œë˜ê·¸ë¡œ ê°„ì£¼í•©ë‹ˆë‹¤.
+  const position = getCanvasRelativePosition(event);
+  const moveDeltaSq = (startPosition.x - position.x) ** 2 +
+                      (startPosition.y - position.y) ** 2;
+  if (moveDeltaSq > maxMoveDeltaSq) {
+    return;
+  }

-  const position = { x: event.clientX, y: event.clientY };
  const id = pickHelper.pick(position, pickingScene, camera);
  if (id > 0) {
    const countryInfo = countryInfos[id - 1];
    const selected = !countryInfo.selected;
    if (selected && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
      unselectAllCountries();
    }
    numCountriesSelected += selected ? 1 : -1;
    countryInfo.selected = selected;
    setPaletteColor(id, selected ? selectedColor : unselectedColor);
    paletteTexture.needsUpdate = true;
  } else if (numCountriesSelected) {
    unselectAllCountries();
  }
  requestRenderIfNotRequested();
}

function unselectAllCountries() {
  numCountriesSelected = 0;
  countryInfos.forEach((countryInfo) => {
    countryInfo.selected = false;
  });
  resetPalette();
}

+canvas.addEventListener('mousedown', recordStartTimeAndPosition);
canvas.addEventListener('mouseup', pickCountry);

let lastTouch;
canvas.addEventListener('touchstart', (event) => {
  // ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
  event.preventDefault();
  lastTouch = event.touches[0];
+  recordStartTimeAndPosition(event.touches[0]);
}, { passive: false });
canvas.addEventListener('touchmove', (event) => {
  lastTouch = event.touches[0];
});
```

ì œ ê¸°ì¤€ì—ì„œëŠ” ì´ ì •ë„ë©´ ì¶©ë¶„í•œ *ë“¯í•˜ë„¤ìš”*.

{{{example url="../threejs-indexed-textures-picking-debounced.html" }}}

ì €ëŠ” UX ì „ë¬¸ê°€ê°€ ì•„ë‹ˆë‹ˆ ë” ë‚˜ì€ ë°©ë²•ì´ ìˆì„ ê²½ìš° ì•Œë ¤ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤.

ì´ ê¸€ì´ ì¸ë±ìŠ¤(indexed) ê·¸ë˜í”½ì„ í™œìš©í•˜ê³ , Three.jsì˜ ì‰ì´ë”ë¥¼ ìˆ˜ì •í•´ ê°„ë‹¨í•œ íš¨ê³¼ë¥¼ êµ¬í˜„í•˜ëŠ” ë° ë„ì›€ì´ ë˜ì—ˆë‹¤ë©´ ì¢‹ê² ë„¤ìš”. ì‰ì´ë”ë¥¼ ì‘ì„±í•  ë•Œ ì“´ GLSLì— ëŒ€í•´ ë‹¤ë£¨ê¸°ì—ëŠ” ë„ˆë¬´ ë‚´ìš©ì´ ë°©ëŒ€í•˜ë‹ˆ [í›„ì²˜ë¦¬ì— ê´€í•œ ê¸€](threejs-post-processing.html)ì— ìˆëŠ” ë§í¬ë¥¼ ì°¸ê³ í•˜ê¸° ë°”ëë‹ˆë‹¤.
