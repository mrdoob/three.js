<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<base href="../../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>Как обновить предметы ([name])</h1>
		<div>
			<p>Все объекты по умолчанию автоматически обновляют свои матрицы, если они были добавлены
                           в сцену с помощью
                        </p>
			<code>
const object = new THREE.Object3D();
scene.add( object );
			</code>
			или если они являются дочерними элементами другого объекта, добавленного в сцену: 
			<code>
const object1 = new THREE.Object3D();
const object2 = new THREE.Object3D();

object1.add( object2 );
scene.add( object1 ); //object1 и object2 автоматически обновят свои матрицы
			</code>
		</div>

		<p>Однако если вы знаете, что объект будет статическим, вы можете отключить это и обновить
                   матрицу преобразования вручную только при необходимости.
                </p>
		<code>
object.matrixAutoUpdate = false;
object.updateMatrix();
		</code>

		<h2>BufferGeometry</h2>
		<div>
			<p>
				BufferGeometries хранит информацию (такую ​​как позиции вершин, индексы граней, нормали,
				цвета, UV и любые пользовательские атрибуты) в [page:BufferAttribute buffers] - то есть,
				[link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays typed arrays].
				Это делает их в целом более быстрыми, чем стандартные геометрии, но более сложную
				работу с ними.
			</p>
			<p>
				Что касается обновления BufferGeometries, самое важное, что нужно понять, это то, что
				вы не можете изменить размер буферов (это очень затратно, по сути, эквивалентно созданию новой геометрии).
				Однако вы можете обновить содержимое буферов.
			</p>
			<p>
				Это означает, что если вы знаете, что атрибут вашей BufferGeometry будет расти, скажем, количества вершин, 
				вы должны предварительно выделить буфер, достаточно большой для хранения любых новых вершин, которые могут быть созданы.
				Конечно, это также означает, что для вашей буферной геометрии будет установлен максимальный размер -  то есть
				невозможно создать буферную геометрию, которая могла бы эффективно расширяться бесконечно.
			</p>
			<p>
				Мы будем использовать пример строки, которая расширяется во время рендеринга. Мы выделим пространство
				в буфере для 500 вершин, но сначала нарисуйте только две, используя [page:BufferGeometry.drawRange].
			</p>
			<code>
const MAX_POINTS = 500;

// geometry
const geometry = new THREE.BufferGeometry();

// attributes
const positions = new Float32Array( MAX_POINTS * 3 ); // 3 числа (x, y и z) на точку
geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

// draw range
const drawCount = 2; // нарисуйте только первые 2 точки
geometry.setDrawRange( 0, drawCount );

// material
const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

// line
const line = new THREE.Line( geometry, material );
scene.add( line );
			</code>
		 	<p>
				Далее мы случайным образом добавим точки к линии, используя такой шаблон: 
			</p>
			<code>
const positionAttribute = line.geometry.getAttribute( 'position' );

let x = 0, y = 0, z = 0;

for ( let i = 0; i < positionAttribute.count; i ++ ) {

	positionAttribute.setXYZ( i, x, y, z );

    x += ( Math.random() - 0.5 ) * 30;
    y += ( Math.random() - 0.5 ) * 30;
    z += ( Math.random() - 0.5 ) * 30;

}
			</code>
			<p>
				Если вы хотите изменить <em>количество точек,</em> отображаемых после первого рендеринга, сделайте следующее:
			</p>
			<code>
line.geometry.setDrawRange( 0, newValue );
			</code>
			<p>
				Если вы хотите изменить значения данных о положении после первого рендеринга, вам необходимо
				установить needsUpdate флаг следующим образом: 
			</p>
			<code>
positionAttribute.needsUpdate = true; // требуется после первого рендеринга
			</code>

			<p>
				Если вы измените значения данных о положении после первоначального рендеринга, вам может потребоваться пересчитать
				ограничивающие объемы, чтобы другие функции движка, такие как отсечение усеченной пирамиды или помощники, работали правильно. 
			</p>
			<code>
line.geometry.computeBoundingBox();
line.geometry.computeBoundingSphere();
			</code>

			<p>
				[link:https://jsfiddle.net/t4m85pLr/1/ Here is a fiddle] показывающий анимированную строку, которую вы можете адаптировать к своему
                                варианту использования. 
			</p>

			<h3>Примеры</h3>

			<p>
				[example:webgl_custom_attributes WebGL / custom / attributes]<br />
				[example:webgl_buffergeometry_custom_attributes_particles WebGL / buffergeometry / custom / attributes / particles]
			</p>

		</div>

		<h2>Материалы</h2>
		<div>
			<p>Все значения униформы можно свободно менять (например, цвета, текстуры, непрозрачность и
                           т. д.), значения отправляются в шейдер каждый кадр.
                        </p>
			<p>Также параметры, связанные с GLstate, могут меняться в любое время (DepthTest, blending,
                           PolygonOffset и т.д.). 
                        </p>
			<p>Следующие свойства нелегко изменить во время выполнения (после того, как материал
                           визуализируется хотя бы один раз):
                        </p>
			<ul>
				<li>количество и типы униформы</li>
				<li>наличие или отсутствие 
					<ul>
						<li>текстур</li>
						<li>тумана</li>
						<li>цвета вершин</li>
						<li>морфинга</li>
						<li>карты теней</li>
						<li>альфа-теста</li>
						<li>прозрачности</li>
					</ul>
				</li>
			</ul>

			<p>Изменения в них требуют создания новой шейдерной программы. Вам нужно будет установить</p>
			<code>material.needsUpdate = true</code>

			<p>Имейте в виду, что это может быть довольно медленно и вызывать рывки в частоте кадров
                           (особенно в Windows, поскольку компиляция шейдеров в DirectX происходит медленнее, чем в
                           OpenGL). 
                        </p>
			<p>Для более плавного взаимодействия вы можете в некоторой степени имитировать изменения в
                           этих функциях, используя «фиктивные» значения, такие как освещение нулевой интенсивности,
                           белые текстуры или туман нулевой плотности. 
                        </p>
			<p>Вы можете свободно менять материал, используемый для фрагментов геометрии, однако вы не
                           можете изменить способ разделения объекта на фрагменты (в соответствии с материалами
                           грани). 
                        </p>
			<h3>Если вам нужно иметь разные конфигурации материалов во время 
                            выполнения:
                        </h3>
			<p>Если количество материалов/кусков небольшое, можно предварительно разделить объект
                           (например, волосы/лицо/тело/верхняя одежда/штаны для человека, перед/бока/верх/стекло/
                           покрышка/салон для автомобиля). 
                        </p>
			<p>Если число велико (например, каждое лицо потенциально может быть разным), рассмотрите
                           другое решение, например, использование атрибутов/текстур для создания различного вида
                           лица. 
                        </p>
			<h3>Примеры</h3>
			<p>
				[example:webgl_materials_car WebGL / materials / car]<br />
				[example:webgl_postprocessing_dof WebGL / webgl_postprocessing / dof]
			</p>
		</div>


		<h2>Текстуры</h2>
		<div>
			<p>Текстуры изображения, холста, видео и данных должны иметь следующий флаг, если они
                           изменяются:</p>
			<code>
				texture.needsUpdate = true;
			</code>
			<p>Цели рендеринга обновляются автоматически.</p>

			<h3>Примеры</h3>
			<p>
				[example:webgl_materials_video WebGL / materials / video]<br />
				[example:webgl_rtt WebGL / rtt]
			</p>

		</div>

		<h2>Камеры</h2>
		<div>
			<p>Положение камеры и цель обновляются автоматически. Если вам нужно изменить</p>
			<ul>
				<li>
					поле зрения 
				</li>
				<li>
					аспект 
				</li>
				<li>
					около 
				</li>
				<li>
					далеко  
				</li>
			</ul>
			<p>
				тогда вам нужно будет пересчитать матрицу проекции: 
			</p>
			<code>
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
			</code>
		</div>

		<h2>InstancedMesh</h2>
		<div>
			<p>
				`InstancedMesh` это класс для удобного доступа к рендерингу экземпляров в `three.js`. 
                                Некоторые функции библиотеки, такие как отсечение усеченного представления или
                                Приведение лучей основано на современных ограничивающих объемах (ограничивающей
                                сфере и ограничивающей рамке). Из-за того, как `InstancedMesh` работает, класс имеет свои
				собственные [page:InstancedMesh.boundingBox boundingBox] и [page:InstancedMesh.boundingSphere boundingSphere], которые заменяют ограничивающие 
				объемы на уровне геометрии. 
			</p>
			<p>
				Подобно геометрии, вам придется пересчитывать ограничивающую рамку и сферу всякий раз,
                                когда вы меняете базовые данные. В контексте `InstancedMesh`, что происходит, когда вы
                                преобразуете экземпляры с помощью [page:InstancedMesh.setMatrixAt setMatrixAt](). Вы можете использовать тот же шаблон,
                                что и для геометрии. 
			</p>
			<code>
instancedMesh.computeBoundingBox();
instancedMesh.computeBoundingSphere();
			</code>

		</div>

		<h2>SkinnedMesh</h2>
		<div>
			<p>
                                `SkinnedMesh` следует тем же принципам, что и `InstancedMesh` в контексте ограничивающих
                                объемов. Это означает, что класс имеет свою собственную версию [page:SkinnedMesh.boundingBox boundingBox] и
                                [page:SkinnedMesh.boundingSphere boundingSphere] для корректного размещения анимированных сеток. При вызове
                                `computeBoundingBox()` и `computeBoundingSphere()`, класс вычисляет соответствующие
                                ограничивающие объемы на основе текущего трансформации костей (или, другими словами,
                                текущее состояние анимации). 
			</p>
		</div>

	</body>
</html>
