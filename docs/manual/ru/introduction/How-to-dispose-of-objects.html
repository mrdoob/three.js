<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<base href="../../../" />
	<script src="page.js"></script>
	<link type="text/css" rel="stylesheet" href="page.css" />
</head>

<body>
	<h1>Как избавиться от объектов ([name])</h1>

	<p>
                Одним из важных аспектов повышения производительности и предотвращения утечек памяти в
                вашем приложении является удаление неиспользуемых объектов библиотеки. Всякий раз,
                когда вы создаете экземпляр типа *three.js*, вы выделяете определенный объем памяти.
                Однако *three.js* создает для конкретных объектов такие как геометрия или материалы,
                связанные с WebGL объекты, такие как буферы или программы шейдеров, необходимые для
                рендеринга. Важно подчеркнуть, что эти объекты не освобождаются автоматически. Вместо
                этого приложению приходится использовать специальный API для освобождения таких
                ресурсов. В этом руководстве представлен краткий обзор того, как используется этот API и
                какие объекты актуальны в этом контексте. 
	</p>

	<h2>Геометрии</h2>

	<p>
                Геометрия обычно представляет информацию о вершинах, определенную как набор атрибутов.
                *three.js* внутренне создает объект типа [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLBuffer WebGLBuffer] для каждого атрибута. Эти объекты
                удаляются только в том случае, если вы вызываете [page:BufferGeometry.dispose](). Если геометрия в
                вашем приложении устарела, выполните этот метод, чтобы освободить все связанные ресурсы. 
	</p>

	<h2>Материалы</h2>

	<p>
                Материал определяет, как визуализируются объекты. *three.js* использует информацию
                определения материала для создания программы шейдера для рендеринга. Шейдерные
                программы можно удалить только в том случае, если соответствующий материал удален. Из
                соображений производительности *three.js* пытается повторно использовать существующие
                шейдерные программы, если это возможно. Таким образом, шейдерная программа удаляется
                только в том случае, если удалены все связанные с ней материалы. Утилизацию материала
                можно указать с помощью выполнения [page:Material.dispose](). 
	</p>

	<h2>Текстуры</h2>

	<p>
	     Удаление материала не влияет на текстуры. Они обрабатываются отдельно, поскольку одна
	     текстура может использоваться несколькими материалами одновременно. Всякий раз, когда
	     вы создаете экземпляр [page:Texture], Three.js внутренне создает экземпляр [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture WebGLTexture]. Подобно
	     буферам, этот объект можно удалить только вызовом [page:Texture.dispose](). 
	</p>

	<p>
	     Если вы используете `ImageBitmap`, в качестве источника данных текстуры, вам необходимо
	     вызвать [link:https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap/close ImageBitmap.close]() на уровне приложения, чтобы избавиться от всех ресурсов
	     процессора. Автоматический вызов `ImageBitmap.close()` в [page:Texture.dispose]() невозможно, так
	     как растровое изображение становится непригодным для использования, и у движка нет
	     возможности узнать, используется ли растровое изображение где-либо ещё. 
	</p>

	<h2>Цели рендеринга</h2>

	<p>
	     Объекты типа [page:WebGLRenderTarget] не только выделяют экземпляр [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture WebGLTexture], но и
	     [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLFramebuffer WebGLFramebuffer]s и [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderbuffer WebGLRenderbuffer]s ​для реализации пользовательских направлений
	     рендеринга. Эти объекты освобождаются только путем выполнения [page:WebGLRenderTarget.dispose]().
	</p>

	<h2>Разнообразный</h2>

	<p>
	     В каталоге примеров есть и другие классы, такие как элементы управления или этапы
	     постобработки, которые предоставляют `dispose()` методы для удаления внутренних
	     прослушивателей событий или визуализировать цели. В общем, рекомендуется проверить API
	     или документацию класса и следить за `dispose()`. Если он есть, вам следует использовать его
	     при уборке. 
	</p>

	<h2>Часто задаваемые вопросы</h2>

	<h3>Почему не может *three.js* автоматически удалять объекты?</h3>

	<p>
           Сообщество задавало этот вопрос много раз, поэтому важно прояснить этот вопрос. Дело в
           том, что *three.js* не знает ни времени жизни, ни области действий созданных пользователем
           объектов, таких как геометрия или материалы. Это ответственность приложения. Например,
           даже если материал в настоящее время не используется для рендеринга, это может быть
           необходимо для следующего кадра. Поэтому, если приложение решает, что определенный
           объект может быть удален, оно должно уведомить об этом движок, вызвав соответствующий
           `dispose()` метод. 	
	</p>

	<h3>Удаление сетки из сцены также приводит к изменению ее геометрии и материала?</h3>

	<p>
           Нет, вам нужно явно удалить геометрию и материал с помощью *dispose()*. Имейте в виду, что
           геометрия и материалы могут быть общими для 3D-объектов, таких как сетки. 	
	</p>

	<h3>Предоставляет ли *three.js* информацию о количестве кешированных объектов?</h3>

	<p>
	     Да. Можно оценить [page:WebGLRenderer.info], специальное свойство средства рендеринга,
	     содержащее ряд статистической информации о памяти видеокарты и процесса рендеринга.
	     Помимо прочего, он сообщает вам, сколько текстур, геометрии и шейдерных программ
	     хранится внутри. Если вы заметили проблемы с производительностью в вашем приложении
	     рекомендуется отладить это свойство, чтобы легко выявить утечку памяти. 
	</p>

	<h3>Что происходит, когда вы вызоваете `dispose()` на текстуре, но изображение еще не загружено? </h3>

	<p>
	     Внутренние ресурсы для текстуры выделяются только в том случае, если изображение
	     полностью загружено. Если вы разместите текстуру до загрузки изображения, ничего не
	     произойдет. Ресурсы не были выделены, поэтому очистка также не требуется. 
	</p>

	<h3>Что происходит, когда я вызоваю `dispose()`, а затем использую соответствующий объект позже? </h3>

	<p>
           Это зависит. Для геометрии, материалов, текстур, целей рендеринга и проходов постобработки
           удаленные внутренние ресурсы могут быть созданы движком заново. Таким образом, ошибок
           во время выполнения не произойдет, но вы можете заметить негативное влияние на
           производительность текущего кадра, особенно когда необходимо скомпилировать программы
           шейдеров. Элементы управления и средства визуализации являются исключением. 
           Экземпляры этих классов нельзя использовать после `dispose()`, когда он был вызван. В этом
           случае вам придется создать новые экземпляры. 	
	</p>

	<h3>Как я должен управлять объектами *three.js* в моем приложении? Когда я 
	    узнаю, как распорядиться предметами?</h3>

	<p>
	     В общем, однозначных рекомендаций по этому поводу нет. Это сильно зависит от конкретного
	     варианта использования при вызове `dispose()` если это уместно. Важно это подчеркнуть не 
	     всегда необходимо постоянно удалять объекты. Хорошим примером является игра, состоящая 
	     из нескольких уровней. Хорошее место для утилизации объектов — это когда переключение
	     уровня приложения могло проходить через старую сцену и удалять все устаревшие материалы, 
	     геометрии и текстуры. Как упоминалось в предыдущем разделе, это не выдать ошибку
	     времени выполнения, если вы удалите объект, который на самом деле все еще используется.
	     Самое худшее, что может случиться, — это падение производительности на один кадр.
	</p>

	<h2>Примеры, демонстрирующие использование dispose()</h2>

	<p>
		[example:webgl_test_memory WebGL / test / memory]<br />
		[example:webgl_test_memory2 WebGL / test / memory2]<br />
	</p>

</body>

</html>
