<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="utf-8" />
		<base href="../../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		[page:Object3D] &rarr;

		<h1>网格（[name]）</h1>

		<p class="desc">
			表示基于以三角形为[link:https://en.wikipedia.org/wiki/Polygon_mesh polygon mesh]（多边形网格）的物体的类。
			同时也作为其他类的基类，例如[page:SkinnedMesh]。
		</p>


		<h2>代码示例</h2>

		<code>
		const geometry = new THREE.BoxGeometry( 1, 1, 1 );
		const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
		const mesh = new THREE.Mesh( geometry, material );
		scene.add( mesh );
		</code>


		<h2>构造器</h2>

		<h3>[name]( [param:BufferGeometry geometry], [param:Material material] )</h3>
		<p>
		[page:BufferGeometry geometry] —— （可选）[page:BufferGeometry]的实例，默认值是一个新的[page:BufferGeometry]。<br />
		[page:Material material] —— （可选）一个[page:Material]，或是一个包含有[page:Material]的数组，默认是一个新的[page:MeshBasicMaterial]。
		</p>


		<h2>属性</h2>
		<p>共有属性请参见其基类[page:Object3D]。</p>

		<h3>[property:BufferGeometry geometry]</h3>
		<p>
			[page:BufferGeometry] 的实例或者派生类，定义了物体的结构。
		</p>

		<h3>[property:Boolean isMesh]</h3>
		<p>
			只读属性，用于检查给定对象是否为[name]类型。
		</p>

		<h3>[property:Material material]</h3>
		<p>
			由[page:Material]基类或者一个包含材质的数组派生而来的材质实例，定义了物体的外观。默认值是一个[page:MeshBasicMaterial]。
		</p>

		<h3>[property:Array morphTargetInfluences]</h3>
		<p>
			一个包含有权重（值一般在0-1范围内）的数组，指定应用了多少变形。
			默认情况下是未定义的，但是会被[page:Mesh.updateMorphTargets updateMorphTargets]重置为一个空数组。
		</p>

		<h3>[property:Object morphTargetDictionary]</h3>
		<p>
			基于morphTarget.name属性的morphTargets字典。
			默认情况下是未定义的，但是会被[page:Mesh.updateMorphTargets updateMorphTargets]重建。
		</p>


		<h2>方法</h2>
		<p>共有方法请参见其基类[page:Object3D]。</p>

		<h3>
			[method:Vector3 getVertexPosition]( [param:Integer index], [param:Vector3 target] )
		</h3>
		<p>
			获取给定索引处顶点的局部空间位置，同时考虑变形目标和蒙皮的当前动画状态。
		</p>

		<h3>[method:undefined raycast]( [param:Raycaster raycaster], [param:Array intersects] )</h3>
		<p>
			在一条投射出去的[page:Ray]（射线）和这个网格之间产生交互。
			[page:Raycaster.intersectObject]将会调用这个方法。
		</p>

		<h3>[method:undefined updateMorphTargets]()</h3>
		<p>
			更新morphTargets，使其不对对象产生影响，重置[page:Mesh.morphTargetInfluences morphTargetInfluences] and
			[page:Mesh.morphTargetDictionary morphTargetDictionary]属性。
		</p>


		<h2>源代码</h2>

		<p>
			[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
		</p>
	</body>
</html>
