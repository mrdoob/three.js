<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<base href="../../../" />
		<script src="list.js"></script>
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>[name]</h1>

		<p class="desc">
			A class representing [link:http://en.wikipedia.org/wiki/Euler_angles Euler Angles].<br /><br />

			Euler angles describe a rotational transformation by rotating an object on its various
			axes in specified amounts per axis, and a specified axis order.
		</p>

		<h2>Example</h2>

		<code>var a = new THREE.Euler( 0, 1, 1.57, 'XYZ' );
		var b = new THREE.Vector3( 1, 0, 1 );
		b.applyEuler(a);
		</code>


		<h2>Constructor</h2>


		<h3>[name]( [param:Float x], [param:Float y], [param:Float z], [param:String order] )</h3>
		<p>
		[page:Float x] - (optional) the angle of the x axis in radians. Default is *0*.<br />
		[page:Float y] - (optional) the angle of the y axis in radians. Default is *0*.<br />
		[page:Float z] - (optional) the angle of the z axis in radians. Default is *0*.<br />
		[page:String order] - (optional) a string representing the order that the rotations are applied,
		defaults to 'XYZ' (must be upper case).<br /><br />

		</p>


		<h2>Properties</h2>

		<h3>[property:Boolean isEuler]</h3>
		<p>
			Used to check whether this or derived classes are Eulers. Default is *true*.<br /><br />

			You should not change this, as it used internally for optimisation.
		</p>

		<h3>[property:String order]</h3>
		<p>
			The order in which to apply rotations. Default is 'XYZ', which means that the object will first be
			rotated around its X axis, then its Y axis and finally its Z axis. Other possibilities are:
			'YZX', 'ZXY', 'XZY', 'YXZ' and 'ZYX'. These must be in upper case.<br /><br />

			Three.js uses <em>intrinsic</em> Tait-Bryan angles. This means that rotations are performed with respect
			to the <em>local</em> coordinate system. That is, for order 'XYZ', the rotation is first around the local-X
			axis (which is the same as the world-X axis), then around local-Y (which may now be different from the
			world Y-axis), then local-Z (which may be different from the world Z-axis).<br /><br />

			If the order is changed, [page:.onChangeCallback onChangeCallback] will be called.
		</p>

		<h3>[property:Float x]</h3>
		<p>
			The current value of the x component.<br /><br />

			If this is changed, [page:.onChangeCallback onChangeCallback] will be called.
		</p>

		<h3>[property:Float y]</h3>
		<p>
			The current value of the y component.<br /><br />

			If this is changed, [page:.onChangeCallback onChangeCallback] will be called.
		</p>

		<h3>[property:Float z]</h3>
		<p>
			The current value of the z component.<br /><br />

			If this is changed, [page:.onChangeCallback onChangeCallback] will be called.
		</p>

		<h2>Methods</h2>

		<h3>[method:Euler copy]( [param:Euler euler] )</h3>
		<p>Copies value of [page:Euler euler] to this euler.</p>

		<h3>[method:Euler clone]()</h3>
		<p>Returns a new Euler with the same parameters as this one.</p>

		<h3>[method:Boolean equals]( [param:Euler euler] )</h3>
		<p>Checks for strict equality of this euler and [page:Euler euler].</p>

		<h3>[method:Euler fromArray]( [param:Array array] )</h3>
		<p>
		[page:Array array] of length 3 or 4. The optional 4th argument corresponds to the [page:.order order].<br /><br />

		Assigns this euler's [page:.x x] angle to array[0]. <br />
		Assigns this euler's [page:.y y] angle to array[1]. <br />
		Assigns this euler's [page:.z z] angle to array[2]. <br />
		Optionally assigns this euler's [page:.order order] to array[3].
		</p>

		<h3>[method:Euler onChange]( [param:Function onChangeCallback] )</h3>
		<p>
			[page:Function onChangeCallback] - set the value of the onChangeCallback() function.
		</p>

		<h3>[method:Euler onChangeCallback](  )</h3>
		<p>
			By default this is an empty function, however it can be set via [page:.onChange onChange]().<br />
			It gets called after changing the [page:.x x], [page:.y y], [page:.z z] or [page:.order order] properties,
			and also after calling most setter functions (see those for details).
		</p>

		<h3>[method:Euler reorder]( [param:String newOrder] )</h3>
		<p>
		Resets the euler angle with a new order by creating a quaternion from this euler angle
		and then setting this euler angle with the quaternion and the new order. <br /><br />

		<em>WARNING</em>: this discards revolution information.
		</p>

		<h3>[method:Euler set]( [param:Float x], [param:Float y], [param:Float z], [param:String order] )</h3>
		<p>
			[page:.x x] - the angle of the x axis in radians.<br />
			[page:.y y] - the angle of the y axis in radians.<br />
			[page:.z z] - the angle of the z axis in radians.<br />
			[page:.order order] - (optional) a string representing the order that the rotations are applied.<br /><br />

			Sets the angles of this euler transform and optionally the [page:.order order] and then call [page:.onChangeCallback onChangeCallback]().
		</p>

		<h3>[method:Euler setFromRotationMatrix]( [param:Matrix4 m], [param:String order], [param:Boolean update] )</h3>
		<p>
		[page:Matrix4 m] - a [page:Matrix4] of which the upper 3x3 of matrix is a pure
		[link:https://en.wikipedia.org/wiki/Rotation_matrix rotation matrix] (i.e. unscaled).<br />
		[page:.order order] - (optional) a string representing the order that the rotations are applied.<br />
		[page:Boolean update] - (optional) whether to call [page:.onChangeCallback onChangeCallback]() after applying
		the matrix.<br /><br />

		Sets the angles of this euler transform from a pure rotation matrix based on the orientation
		specified by order.
		</p>

		<h3>[method:Euler setFromQuaternion]( [param:Quaternion q], [param:String order], [param:Boolean update] )</h3>
		<p>
		[page:Quaternion q] - a normalized quaternion.<br />
		[page:.order order] - (optional) a string representing the order that the rotations are applied.<br />
		[page:Boolean update] - (optional) whether to call [page:.onChangeCallback onChangeCallback]() after applying
		the matrix.<br /><br />

		Sets the angles of this euler transform from a normalized quaternion based on the orientation
		specified by [page:.order order].
		</p>


		<h3>[method:Euler setFromVector3]( [param:Vector3 vector], [param:String order] )</h3>
		<p>
		[page:Vector3 vector] - [page:Vector3].<br />
		[page:.order order] - (optional) a string representing the order that the rotations are applied.<br /><br />

		Set the [page:.x x], [page:.y y] and [page:.z z], and optionally update the [page:.order order]. [page:.onChangeCallback onChangeCallback]()
		is called after these changes are made.
		</p>


		<h3>[method:Array toArray]( [param:Array array], [param:Integer offset] )</h3>
		<p>
		[page:Array array] - (optional) array to store the euler in.<br />
		[page:Integer offset] (optional) offset in the array.<br />

		Returns an array of the form [[page:.x x], [page:.y y], [page:.z z], [page:.order order ]].
		</p>

		<h3>[method:Vector3 toVector3]( [param:Vector3 optionalResult] )</h3>
		<p>
			[page:Vector3 optionalResult] â€” (optional) If specified, the result will be copied into this Vector,
			otherwise a new one will be created. <br /><br />

			Returns the Euler's [page:.x x], [page:.y y] and [page:.z z] properties as a [page:Vector3].
		</p>


		<h2>Source</h2>

		[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
	</body>
</html>
