<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="utf-8" />
		<base href="../../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>四元数（[name]）</h1>

		<p class="desc">
			该类实现了 [link:http://en.wikipedia.org/wiki/Quaternion quaternion] 。<br/>
			四元数在three.js中用于表示 [link:https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation rotation] （旋转）。
		</p>

		<p>
			对 [name] 实例进行遍历将按相应的顺序生成它的分量 (x, y, z, w)。
		</p>

		<p>
			请注意，three.js 期望四元数被归一化。
		</p>

		<h2>代码示例</h2>

		<code>
		const quaternion = new THREE.Quaternion();
		quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );

		const vector = new THREE.Vector3( 1, 0, 0 );
		vector.applyQuaternion( quaternion );
		</code>


		<h2>构造函数</h2>


		<h3>[name]( [param:Float x], [param:Float y], [param:Float z], [param:Float w] )</h3>
		<p>
		[page:Float x] - x 坐标<br />
		[page:Float y] - y 坐标<br />
		[page:Float z] - z 坐标<br />
		[page:Float w] - w 坐标
		</p>


		<h2>属性</h2>

		<h3>[property:Boolean isQuaternion]</h3>
		<p>
			只读属性，用于检查给定对象是否为[name]类型。
		</p>

		<h3>[property:Float x]</h3>

		<h3>[property:Float y]</h3>

		<h3>[property:Float z]</h3>

		<h3>[property:Float w]</h3>


		<h2>方法</h2>

		<h3>[method:Float angleTo]( [param:Quaternion q] )</h3>
		<p>
			以弧度返回该四元数与四元数 [page:Quaternion q] 之间的夹角。
		</p>

		<h3>[method:Quaternion clone]()</h3>
		<p>
			创建一个与该四元数具有相同[page:.x x]、[page:.y y]、[page:.z z]和[page:.w w]
			属性的四元数。
		</p>

		<h3>[method:this conjugate]()</h3>
		<p>
			返回该四元数的旋转共轭。
			四元数的共轭表示的是，围绕旋转轴在相反方向上的相同旋转。
		</p>

		<h3>[method:this copy]( [param:Quaternion q] )</h3>
		<p>
			复制四元数 [page:Quaternion q] 的 [page:.x x]、[page:.y y]、[page:.z z] 和 [page:.w w]
			属性到该四元数中。
		</p>

		<h3>[method:Boolean equals]( [param:Quaternion v] )</h3>
		<p>
		[page:Quaternion v] - 用于进行比较的四元数。<br /><br />

		将四元数 [page:Quaternion v] 的 [page:.x x]、 [page:.y y]、	[page:.z z] 和 [page:.w w] 的属性
		与当前四元数的对应属性相比较，以确定它们是否表示相同的旋转。
		</p>

		<h3>[method:Float dot]( [param:Quaternion v] )</h3>
		<p>
			计算四元数 [page:Quaternion v] 与当前四元数的[link:https://en.wikipedia.org/wiki/Dot_product dot product]（点积）。
		</p>

		<h3>[method:this fromArray]( [param:Array array], [param:Integer offset] )</h3>
		<p>
		[page:Array array] - 用于构造四元数的形如(x, y, z, w)的数组。<br />
		[page:Integer offset] - （可选）数组的偏移量。（译者注：使用数组中从第offset元素算起的四个元素）<br /><br />

		从一个数组来设置四元数的 [page:.x x]、 [page:.y y]、[page:.z z] 和 [page:.w w] 的属性。
		</p>

		<h3>[method:this identity]()</h3>
		<p>
			设置该四元数为 identity 四元数，即表示“不旋转”的四元数。
		</p>

		<h3>[method:this invert]()</h3>
		<p>
			翻转该四元数 —— 计算 [page:.conjugate conjugate] 。假定该四元数具有单位长度。
		</p>

		<h3>[method:Float length]()</h3>
		<p>计算四元数的 [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length]
		（欧几里得长度，直线长度），视为一个四维向量。</p>

		<h3>[method:Float lengthSq]()</h3>
		<p>
			计算四元数 [link:https://en.wikipedia.org/wiki/Euclidean_distance Euclidean length]
			（欧几里得长度，直线长度）的平方，视为一个四维向量。
			如果要比较两个四元数的长度，这可能会十分有用，
			因为这比 [page:.length length]() 的效率稍高一些。
		</p>

		<h3>[method:this normalize]()</h3>
		<p>
			[link:https://en.wikipedia.org/wiki/Normalized_vector Normalizes]（归一化）四元数 ——
			即计算与该四元数具有相同旋转、但长度为*1*的四元数。
		</p>

		<h3>[method:this multiply]( [param:Quaternion q] )</h3>
		<p>将该四元数与[page:Quaternion q]相乘。</p>

		<h3>[method:this multiplyQuaternions]( [param:Quaternion a], [param:Quaternion b] )</h3>
		<p>
		将该四元数设为 [page:Quaternion a] x [page:Quaternion b] 。<br />
		改编自 [link:http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm here] 所概述的方法。
		</p>

		<h3>[method:this premultiply]( [param:Quaternion q] )</h3>
		<p>使用 [page:Quaternion q] 乘以该四元数。</p>

		<h3>[method:this rotateTowards]( [param:Quaternion q], [param:Float step] )</h3>
		<p>
			[page:Quaternion q] - 目标四元数<br />
			[page:Float step] - 以弧度为单位的角度步长<br /><br />

			将该四元数按照步长 step 向目标 *q* 进行旋转。该方法确保最终的四元数不会超过 *q*。
		</p>

		<h3>[method:this slerp]( [param:Quaternion qb], [param:Float t] )</h3>
		<p>
			[page:Quaternion qb] - 另一个四元数旋转<br />
			[page:Float t] - 闭区间 [0, 1] 中的插值因子<br /><br />

			处理四元数之间的球面线性插值。[page:Float t] 表示该四元数(其中 [page:Float t] 为 0) 和 [page:Quaternion qb] (其中 [page:Float t] 为1) 之间的旋转量。
			该四元数会被设置为上述计算的结果。另请参阅下面 *slerp* 的静态版本。

			<code>
			// rotate a mesh towards a target quaternion
			mesh.quaternion.slerp( endQuaternion, 0.01 );
			</code>
		</p>

		<h3>[method:this slerpQuaternions]( [param:Quaternion qa], [param:Quaternion qb], [param:Float t] )</h3>
		<p>在给定的四元数之间执行球面线性插值，并将结果存储在这个四元数中</p>

		<h3>[method:this set]( [param:Float x], [param:Float y], [param:Float z], [param:Float w] )</h3>
		<p>设置该四元数的 [page:.x x]、[page:.y y]、[page:.z z]和[page:.w w]属性。</p>

		<h3>[method:this setFromAxisAngle]( [param:Vector3 axis], [param:Float angle] )</h3>
		<p>
		从由 [page:Vector3 axis]（轴） 和 [page:Float angle]（角度）所给定的旋转来设置该四元数。<br />
		改编自 [link:http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm here] 所述的方法。<br />
		假定*Axis*已被归一化，*angle*以弧度来表示。
		</p>

		<h3>[method:this setFromEuler]( [param:Euler euler] )</h3>
		<p>从由 [page:Euler] 角所给定的旋转来设置该四元数。</p>

		<h3>[method:this setFromRotationMatrix]( [param:Matrix4 m] )</h3>
		<p>
		从[page:Matrix4 m]的旋转分量中来设置该四元数。<br />
		改编自 [link:http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm here] 所概述的方法。
		</p>

		<h3>[method:this setFromUnitVectors]( [param:Vector3 vFrom], [param:Vector3 vTo] )</h3>
		<p>
		将该四元数设置为从方向向量 [page:Vector3 vFrom] 旋转到方向向量 [page:Vector3 vTo] 所需的旋转。<br />
		改编自方法 [link:http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors here]。<br />
		假设 [page:Vector3 vFrom] 和 [page:Vector3 vTo] 都已归一化。
		</p>

		<h3>[method:Array toArray]( [param:Array array], [param:Integer offset] )</h3>
		<p>
		[page:Array array] - （可选）存储该四元数的数组。若未指定该参数，则将创建一个新数组。<br/>
		[page:Integer offset] - （可选）若指定了该值，结果将会被拷贝到该
		[page:Array]。<br /><br />

		在形如[x, y, z, w]的数组中，返回四元数中的数字元素。
		</p>

		<h3>[method:Array toJSON]()</h3>
		<p>
		This methods defines the serialization result of [name]. 在形如[x, y, z, w]的数组中，返回四元数中的数字元素。
		</p>

		<h3>[method:this fromBufferAttribute]( [param:BufferAttribute attribute], [param:Integer index] )</h3>
		<p>
		[page:BufferAttribute attribute] - 源 attribute。<br />
		[page:Integer index] - attribute 中的索引。<br /><br />

		从 [page:BufferAttribute attribute] 中设置该四元数的[page:.x x]、 [page:.y y]、 [page:.z z]、 [page:.w w]属性。
		</p>

		<h2>静态方法</h2>

		<h3>[method:undefined slerpFlat]( [param:Array dst], [param:Integer dstOffset], [param:Array src0], [param:Integer srcOffset0], [param:Array src1], [param:Integer srcOffset1], [param:Float t] )</h3>
		<p>
		[page:Array dst] - 输出数组<br />
		[page:Integer dstOffset] - 输出数组的偏移量<br />
		[page:Array src0] - 起始四元数的源数组<br />
		[page:Integer srcOffset0] - 数组 *src0* 的偏移量<br />
		[page:Array src1] - 目标四元数的源数组<br />
		[page:Integer srcOffset1] - 数组 *src1* 的偏移量<br />
		[page:Float t] - 归一化插值因子(介于 0 和 1 之间)<br /><br />

		This SLERP implementation assumes the quaternion data are managed in flat arrays.
		</p>

		<h3>[method:Array multiplyQuaternionsFlat]( [param:Array dst], [param:Integer dstOffset], [param:Array src0], [param:Integer srcOffset0], [param:Array src1], [param:Integer srcOffset1] )</h3>
		<p>
		[page:Array dst] - The output array.<br />
		[page:Integer dstOffset] - An offset into the output array.<br />
		[page:Array src0] - The source array of the starting quaternion.<br />
		[page:Integer srcOffset0] - An offset into the array *src0*.<br />
		[page:Array src1] - The source array of the target quaternion.<br />
		[page:Integer srcOffset1] - An offset into the array *src1*.<br /><br />

		This multiplication implementation assumes the quaternion data are managed in flat arrays.
		</p>

		<!-- Note: Do not add non-static methods to the bottom of this page. Put them above the <h2>Static Methods</h2> -->

		<h2>源码</h2>

		<p>
			[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
		</p>
	</body>
</html>
