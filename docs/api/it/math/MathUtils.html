<!DOCTYPE html>
<html lang="it">
	<head>
		<meta charset="utf-8" />
		<base href="../../../" />
		<script src="page.js"></script>
		<link type="text/css" rel="stylesheet" href="page.css" />
	</head>
	<body>
		<h1>[name]</h1>

		<p class="desc">Un oggetto con molte funzioni matematiche di utilità.</p>

		<h2>Funzioni</h2>

		<h3>[method:Float clamp]( [param:Float value], [param:Float min], [param:Float max] )</h3>
		<p>
		[page:Float value] — Valore che deve essere fissato.<br />
		[page:Float min] — Valore minimo.<br />
		[page:Float max] — Valore massimo.<br /><br />

		Fissa il [page:Float value] tra il [page:Float min] e il [page:Float max].
		</p>

		<h3>[method:Float degToRad]( [param:Float degrees] )</h3>
		<p>Converte i gradi in radianti.</p>

		<h3>[method:Integer euclideanModulo]( [param:Integer n], [param:Integer m] )</h3>
		<p>
		[page:Integer n], [page:Integer m] - Interi<br /><br />

		Calcola il modulo Euclideo di [page:Integer m] % [page:Integer n], che è:
		<code>( ( n % m ) + m ) % m</code>
		</p>

		<h3>[method:UUID generateUUID]( )</h3>
		<p>
		Genera un'[link:https://en.wikipedia.org/wiki/Universally_unique_identifier UUID]
		(universally unique identifier).
		</p>

		<h3>[method:Boolean isPowerOfTwo]( [param:Number n] )</h3>
		<p>Restituisce `true` se [page:Number n] è una potenza di 2.</p>

		<h3>[method:Float inverseLerp]( [param:Float x], [param:Float y], [param:Float value] )</h3>
		<p>
		[page:Float x] - Punto di inizio.<br />
		[page:Float y] - Punto di fine.<br />
		[page:Float value] - Un valore tra l'inizio e la fine.<br><br />

		Restituisce la percentuale nell'intervallo chiuso `[0, 1]` del valore dato tra il punto di inizio e di fine.
		</p>

		<h3>[method:Float lerp]( [param:Float x], [param:Float y], [param:Float t] )</h3>
		<p>
		[page:Float x] - Punto di inizio. <br />
		[page:Float y] - Punto di fine. <br />
		[page:Float t] - Fattore di interpolazione nell'intervallo chiuso `[0, 1]`.<br><br />

		Restituisce un valore [link:https://en.wikipedia.org/wiki/Linear_interpolation interpolato linearmente]
		da due punti noti in base all'intervallo dato - [page:Float t] = 0 restituirà [page:Float x]
		e [page:Float t] = 1 restituirà [page:Float y].
		</p>

		<h3>[method:Float damp]( [param:Float x], [param:Float y], [param:Float lambda], [param:Float dt] )</h3>
		<p>
		[page:Float x] - Punto corrente. <br />
		[page:Float y] - Punto target. <br />
		[page:Float lambda] - Un valore lambda più alto renderà il movimento più improvviso, e un valore più basso renderà il movimento più graduale. <br />
		[page:Float dt] - Il tempo delta in secondi.<br><br />

		Interpola in modo fluido un numero da [page:Float x] a [page:Float y] in modo simile ad una molla usando [page:Float dt]
		per mantenere il movimento indipendente dalla frequenza dei fotogrammi. Per i dettagli, vedere 
		[link:http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/ Smorzamento indipendente dalla frequenza dei fotogrammi mediante lerp].
		</p>

		<h3>[method:Float mapLinear]( [param:Float x], [param:Float a1], [param:Float a2], [param:Float b1], [param:Float b2] )</h3>
		<p>
		[page:Float x] — Valore da mappare.<br />
		[page:Float a1] — Minimo valore per il range A.<br />
		[page:Float a2] — Massimo valore per il range A.<br />
		[page:Float b1] — Minimo valore per il range B.<br />
		[page:Float b2] — Massimo valore per il range B.<br /><br />

		Mappa lineare di [page:Float x] dall'intervallo [[page:Float a1], [page:Float a2]] all'intervallo [[page:Float b1], [page:Float b2]].
		</p>

		<h3>[method:Float pingpong]( [param:Float x], [param:Float length] )</h3>
		<p>
		[page:Float x] — Il valore del pingpong.<br />
		[page:Float length] — Il valore positivo a cui la funzione farà pingpong. Il valore predefinito è 1.<br /><br />

		Restituisce un valore che alterna tra 0 e [param:Float length].
		</p>

		<h3>[method:Integer ceilPowerOfTwo]( [param:Number n] )</h3>
		<p>Restituisce la potenza di 2 più piccola, maggiore o uguale a [page:Number n].</p>

		<h3>[method:Integer floorPowerOfTwo]( [param:Number n] )</h3>
		<p>Restituisce la massima potenza di 2, minore o uguale a [page:Number n].</p>

		<h3>[method:Float radToDeg]( [param:Float radians] )</h3>
		<p>Coverte i radianti in gradi.</p>

		<h3>[method:Float randFloat]( [param:Float low], [param:Float high] )</h3>
		<p>Float casuale nell'intervallo [[page:Float low], [page:Float high]].</p>

		<h3>[method:Float randFloatSpread]( [param:Float range] )</h3>
		<p>Float casuale nell'intervallo [- [page:Float range] / 2, [page:Float range] / 2].</p>

		<h3>[method:Integer randInt]( [param:Integer low], [param:Integer high] )</h3>
		<p>Intero casuale nell'intervallo [[page:Float low], [page:Float high]].</p>

		<h3>[method:Float seededRandom]( [param:Integer seed] )</h3>
		<p>Float pseudocasuale deterministico nell'intervallo `[0, 1]`. L'intero [page:Integer seed] è opzionale.</p>

		<h3>[method:Float smoothstep]( [param:Float x], [param:Float min], [param:Float max] )</h3>
		<p>
		[page:Float x] - Il valore da valutare in base alla sua posizione tra il min e il max. <br />
		[page:Float min] - Qualsiasi valore di x sotto il min sarà 0.<br />
		[page:Float max] - Qualsiasi valore di x sopra il max sarà 1.<br /><br />

		Restituisce un valore compreso tra 0-1 che rappresenta la percentuale di spostamento di x tra il min e il max,
		ma attenuata o rallentata quanto più X si avvicina al minimo e al massimo.<br/><br/>

		Vedi [link:http://en.wikipedia.org/wiki/Smoothstep Smoothstep] per i dettagli.
		</p>

		<h3>[method:Float smootherstep]( [param:Float x], [param:Float min], [param:Float max] )</h3>
		<p>
		[page:Float x] - Il valore da valutare in base alla sua posizione tra il min e il max. <br />
		[page:Float min] - Qualsiasi valore di x sotto il min sarà 0.<br />
		[page:Float max] - Qualsiasi valore di x sopra il max sarà 1.<br /><br />

		Restituisce un valore compreso tra 0-1. Una [link:https://en.wikipedia.org/wiki/Smoothstep#Variations variazione su smoothstep]
		che ha zero derivare di primo e secondo ordine a x=0 e x=1.
		</p>

		<h3>[method:undefined setQuaternionFromProperEuler]( [param:Quaternion q], [param:Float a], [param:Float b], [param:Float c], [param:String order] )</h3>
		<p>
		[page:Quaternion q] - Il quaternione da impostare.<br />
		[page:Float a] - La rotazione applicata al primo asse, in radianti.<br />
		[page:Float b] - La rotazione applicata al secondo asse, in radianti.<br />
		[page:Float c] - La rotazione applicata al terzo asse, in radianti.<br />
		[page:String order] - una stringa che specifica l'ordine degli assi: 'XYX', 'XZX', 'YXY', 'YZY', 'ZXZ', o 'ZYZ'<br /><br />

		Imposta il quaternione [page:Quaternion q] dagli [link:http://en.wikipedia.org/wiki/Euler_angles angoli di Eulero propri intrinseci] definiti 
		dagli angoli [page:Float a], [page:Float b], e [page:Float c], e dall'ordine [page:String order].<br />

		Le rotazioni vengono applicate agli assi nell'ordine specificato da [page:String order]:
		la rotazione per l'angolo [page:Float a] viene applicata per prima, poi l'angolo [page:Float b], infine l'angolo [page:Float c].
		Gli angoli sono in radianti.
		</p>

		<h2>Source</h2>

		<p>
			[link:https://github.com/mrdoob/three.js/blob/master/src/[path].js src/[path].js]
		</p>
	</body>
</html>
