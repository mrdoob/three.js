<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="utf-8">
	<title>ä½“ç´ ï¼ˆç±»ä¼¼ã€Šæˆ‘çš„ä¸–ç•Œã€‹ï¼‰å‡ ä½•ä½“</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:site" content="@threejs">
	<meta name="twitter:title" content="Three.js â€“ ä½“ç´ ï¼ˆç±»ä¼¼ã€Šæˆ‘çš„ä¸–ç•Œã€‹ï¼‰å‡ ä½•ä½“">
	<meta property="og:image" content="https://threejs.org/files/share.png">
	<link rel="shortcut icon" href="../../files/favicon_white.ico" media="(prefers-color-scheme: dark)">
	<link rel="shortcut icon" href="../../files/favicon.ico" media="(prefers-color-scheme: light)">

	<link rel="stylesheet" href="../resources/lesson.css">
	<link rel="stylesheet" href="../resources/lang.css">
	<script type="importmap">
		{
		  "imports": {
			"three": "../../build/three.module.js"
		  }
		}
	</script>
</head>
<body>
<div class="container">
	<div class="lesson-title">
		<h1>ä½“ç´ ï¼ˆç±»ä¼¼ã€Šæˆ‘çš„ä¸–ç•Œã€‹ï¼‰å‡ ä½•ä½“</h1>
	</div>
	<div class="lesson">
		<div class="lesson-main">
			<p>æˆ‘åœ¨å¤šä¸ªåœ°æ–¹éƒ½çœ‹åˆ°è¿‡è¿™ä¸ªè¯é¢˜ï¼šâ€œå¦‚ä½•å®ç°åƒã€Šæˆ‘çš„ä¸–ç•Œã€‹é‚£æ ·çš„ä½“ç´ æ˜¾ç¤ºâ€ã€‚</p>

			<p>å¤§å¤šæ•°äººåˆæ¬¡å°è¯•æ—¶ï¼Œä¼šä¸ºæ¯ä¸ªä½“ç´ ä½ç½®åˆ›å»ºä¸€ä¸ªç«‹æ–¹ä½“å‡ ä½•ä½“ï¼Œç„¶åç”Ÿæˆä¸€ä¸ªç½‘æ ¼ï¼ˆmeshï¼‰ã€‚å‡ºäºå¥½å¥‡ï¼Œæˆ‘ä¹Ÿè¯•äº†ä¸€ä¸‹ã€‚æˆ‘åˆ›å»ºäº†ä¸€ä¸ªåŒ…å« 16777216 ä¸ªå…ƒç´ çš„ <code class="notranslate" translate="no">Uint8Array</code> æ•°ç»„ï¼Œç”¨æ¥è¡¨ç¤ºä¸€ä¸ª 256x256x256 çš„ä½“ç´ ç«‹æ–¹ä½“ã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const cellSize = 256;
const cell = new Uint8Array(cellSize * cellSize * cellSize);
</pre>

			<p>ç„¶åæˆ‘ç”¨æ­£å¼¦æ³¢ç”Ÿæˆäº†ä¸€å±‚ç±»ä¼¼å°å±±ä¸˜çš„åœ°å½¢ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const height = (Math.sin(x / cellSize * Math.PI * 4) + Math.sin(z / cellSize * Math.PI * 6)) * 20 + cellSize / 2;
      if (height &gt; y &amp;&amp; height &lt; y + 1) {
        const offset = y * cellSize * cellSize +
                       z * cellSize +
                       x;
        cell[offset] = 1;
      }
    }
  }
}
</pre>

			<p>æ¥ç€æˆ‘éå†æ‰€æœ‰ä½“ç´ ï¼Œåªè¦å€¼ä¸ä¸º 0ï¼Œå°±åˆ›å»ºä¸€ä¸ªç«‹æ–¹ä½“ç½‘æ ¼ï¼š</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshPhongMaterial({color: 'green'});

for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const offset = y * cellSize * cellSize +
                     z * cellSize +
                     x;
      const block = cell[offset];
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, y, z);
      scene.add(mesh);
    }
  }
}
</pre>

			<p>å…¶ä½™ä»£ç åŸºäº <a href="rendering-on-demand.html">â€œæŒ‰éœ€æ¸²æŸ“â€</a>ä¸€æ–‡ä¸­çš„ç¤ºä¾‹ã€‚</p>

			<p></p>
			<div translate="no" class="threejs_example_container notranslate">
				<div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/voxel-geometry-separate-cubes.html"></iframe></div>
				<a class="threejs_center" href="/manual/examples/voxel-geometry-separate-cubes.html" target="_blank">ç‚¹å‡»æ­¤å¤„ï¼Œåœ¨æ–°çª—å£ä¸­æ‰“å¼€ç¤ºä¾‹</a>
			</div>
			<p></p>

			<p>é¡µé¢åŠ è½½éœ€è¦è¾ƒé•¿æ—¶é—´ï¼Œå¦‚æœä½ å°è¯•ç§»åŠ¨æ‘„åƒæœºï¼Œå¾ˆå¯èƒ½éå¸¸å¡é¡¿ã€‚å°±åƒ <a href="optimize-lots-of-objects.html">â€œå¦‚ä½•ä¼˜åŒ–å¤§é‡å¯¹è±¡â€</a>ä¸€æ–‡ä¸­æåˆ°çš„ï¼Œé—®é¢˜åœ¨äºå¯¹è±¡æ•°é‡å¤ªå¤šâ€”â€”ä»… 256x256 å°±æœ‰ 65536 ä¸ªæ–¹å—ï¼</p>

			<p>ä½¿ç”¨ <a href="rendering-on-demand.html">â€œåˆå¹¶å‡ ä½•ä½“â€</a> æŠ€æœ¯å¯ä»¥è§£å†³æœ¬ä¾‹çš„é—®é¢˜ã€‚ä½†å¦‚æœä¸ä»…ä»…æ˜¯ç”Ÿæˆå•å±‚åœ°å½¢ï¼Œè€Œæ˜¯å°†åœ°é¢ä»¥ä¸‹çš„æ‰€æœ‰ç©ºé—´éƒ½ç”¨ä½“ç´ å¡«å……å‘¢ï¼Ÿæ¢å¥è¯è¯´ï¼Œå°†å¡«å……ä½“ç´ çš„å¾ªç¯ä¿®æ”¹å¦‚ä¸‹ï¼š</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const height = (Math.sin(x / cellSize * Math.PI * 4) + Math.sin(z / cellSize * Math.PI * 6)) * 20 + cellSize / 2;
-      if (height &gt; y &amp;&amp; height &lt; y + 1) {
+      if (height &lt; y + 1) {
        const offset = y * cellSize * cellSize +
                       z * cellSize +
                       x;
        cell[offset] = 1;
      }
    }
  }
}
</pre>
			<p>æˆ‘å°è¯•è¿è¡Œäº†ä¸€æ¬¡ï¼Œåªæ˜¯ä¸ºäº†çœ‹çœ‹ç»“æœã€‚ç¨‹åºè¿è¡Œäº†å¤§çº¦ä¸€åˆ†é’Ÿï¼Œç„¶åå›  <em>å†…å­˜ä¸è¶³</em> è€Œå´©æºƒäº† ğŸ˜…</p>

			<p>è¿™é‡Œå­˜åœ¨å¤šä¸ªé—®é¢˜ï¼Œä½†æœ€ä¸¥é‡çš„æ˜¯ï¼šæˆ‘ä»¬ç”Ÿæˆäº†å¤§é‡ç«‹æ–¹ä½“å†…éƒ¨çš„é¢ç‰‡ï¼ˆfacesï¼‰ï¼Œè€Œè¿™äº›é¢å®é™…ä¸Šæ°¸è¿œä¸å¯è§ã€‚</p>

			<p>æ¢å¥è¯è¯´ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ª 3x2x2 çš„ä½“ç´ æ–¹å—ã€‚å¦‚æœæˆ‘ä»¬åªæ˜¯ç®€å•åˆå¹¶ç«‹æ–¹ä½“ï¼Œä¼šå¾—åˆ°å¦‚ä¸‹ç»“æ„ï¼š</p>

			<div class="spread">
				<div data-diagram="mergedCubes" style="height: 300px;"></div>
			</div>

			<p>ä½†å®é™…ä¸Šæˆ‘ä»¬æƒ³è¦çš„æ˜¯è¿™ä¸ªï¼š</p>

			<div class="spread">
				<div data-diagram="culledCubes" style="height: 300px;"></div>
			</div>

			<p>åœ¨ä¸Šæ–¹çš„ç›’å­ä¸­ï¼Œä½“ç´ ä¹‹é—´å­˜åœ¨é¢ç‰‡ã€‚è¿™äº›é¢æ˜¯å®Œå…¨æµªè´¹çš„ï¼Œå› ä¸ºå®ƒä»¬æ°¸è¿œä¸å¯è§ã€‚è€Œä¸”ä¸åªæ˜¯æ¯ä¸ªä½“ç´ ä¹‹é—´ä¸€ä¸ªé¢ï¼Œå®é™…ä¸Šæ˜¯ä¸¤ä¸ªé¢â€”â€”æ¯ä¸ªä½“ç´ æœå‘å…¶é‚»å±…çš„é‚£ä¸ªé¢éƒ½æ˜¯å¤šä½™çš„ã€‚å¯¹äºå¤§é‡ä½“ç´ æ¥è¯´ï¼Œè¿™äº›é¢å¤–çš„é¢ä¼šä¸¥é‡æ‹–ç´¯æ€§èƒ½ã€‚</p>

			<p>æ˜¾ç„¶ï¼Œæˆ‘ä»¬ä¸èƒ½ç®€å•åœ°åˆå¹¶å‡ ä½•ä½“ã€‚æˆ‘ä»¬å¿…é¡»è‡ªå·±æ„å»ºå‡ ä½•ä½“ï¼Œå¹¶è€ƒè™‘ï¼šå¦‚æœä¸€ä¸ªä½“ç´ æœ‰ç›¸é‚»çš„é‚»å±…ï¼Œé‚£ä¹ˆå®ƒå°±ä¸éœ€è¦æœå‘è¯¥é‚»å±…çš„é‚£ä¸ªé¢ã€‚</p>

			<p>ä¸‹ä¸€ä¸ªé—®é¢˜æ˜¯ï¼š256x256x256 å¤ªå¤§äº†ã€‚16 å…†å­—èŠ‚çš„å†…å­˜å ç”¨å·²ç»å¾ˆé«˜ï¼Œè€Œä¸”å¤§éƒ¨åˆ†ç©ºé—´å…¶å®æ˜¯ç©ºçš„ï¼Œé€ æˆäº†å¤§é‡å†…å­˜æµªè´¹ã€‚åŒæ—¶ä½“ç´ æ€»æ•°é«˜è¾¾ 1600 ä¸‡ä¸ªï¼ä¸€æ¬¡æ€§å¤„ç†è¿™ä¹ˆå¤šæ•°æ®æ˜¯ä¸ç°å®çš„ã€‚</p>

			<p>è§£å†³æ–¹æ¡ˆæ˜¯å°†åŒºåŸŸåˆ’åˆ†ä¸ºæ›´å°çš„åŒºåŸŸã€‚ä»»ä½•å®Œå…¨ä¸ºç©ºçš„åŒºåŸŸéƒ½ä¸éœ€è¦å­˜å‚¨ã€‚æˆ‘ä»¬ä½¿ç”¨ 32x32x32 çš„å°åŒºåŸŸï¼ˆæ¯ä¸ªçº¦ 32KBï¼‰ï¼Œä»…åœ¨å…¶ä¸­æœ‰æ•°æ®æ—¶æ‰åˆ›å»ºã€‚æˆ‘ä»¬å°†è¿™ç§ 32x32x32 çš„åŒºåŸŸç§°ä¸ºä¸€ä¸ªâ€œå•å…ƒâ€ï¼ˆcellï¼‰ã€‚</p>

			<p>è®©æˆ‘ä»¬é€æ­¥å®ç°ã€‚é¦–å…ˆåˆ›å»ºä¸€ä¸ªç±»æ¥ç®¡ç†ä½“ç´ æ•°æ®ï¼š</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
  }
}
</pre>

			<p>æ¥ä¸‹æ¥ç¼–å†™ä¸€ä¸ªä¸ºâ€œå•å…ƒâ€ç”Ÿæˆå‡ ä½•ä½“çš„å‡½æ•°ã€‚å‡è®¾ä½ ä¼ å…¥ä¸€ä¸ªå•å…ƒçš„åæ ‡ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ æƒ³è·å–è¦†ç›–ä½“ç´  (0-31x, 0-31y, 0-31z) çš„å•å…ƒçš„å‡ ä½•ä½“ï¼Œå°±ä¼ å…¥ 0,0,0ï¼›å¦‚æœæƒ³è·å–è¦†ç›– (32-63x, 0-31y, 0-31z) çš„å•å…ƒï¼Œåˆ™ä¼ å…¥ 1,0,0ã€‚</p>

			<p>æˆ‘ä»¬éœ€è¦èƒ½å¤Ÿæ£€æŸ¥ç›¸é‚»ä½“ç´ ï¼Œå› æ­¤å‡è®¾æˆ‘ä»¬çš„ç±»æœ‰ä¸€ä¸ª <code class="notranslate" translate="no">getVoxel</code> æ–¹æ³•ï¼Œå®ƒæ¥æ”¶ä½“ç´ åæ ‡å¹¶è¿”å›è¯¥ä½ç½®çš„ä½“ç´ å€¼ã€‚ä¾‹å¦‚ï¼Œä¼ å…¥ 35,0,0 ä¸” cellSize ä¸º 32 æ—¶ï¼Œå®ƒä¼šæŸ¥æ‰¾å•å…ƒ (1,0,0)ï¼Œå¹¶åœ¨è¯¥å•å…ƒä¸­è®¿é—®ä½“ç´  (3,0,0)ã€‚é€šè¿‡è¿™ä¸ªæ–¹æ³•ï¼Œå³ä½¿ç›¸é‚»ä½“ç´ ä½äºå…¶ä»–å•å…ƒä¸­ï¼Œæˆ‘ä»¬ä¹Ÿèƒ½æ­£ç¡®è®¿é—®ã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
  }
+  generateGeometryDataForCell(cellX, cellY, cellZ) {
+    const {cellSize} = this;
+    const startX = cellX * cellSize;
+    const startY = cellY * cellSize;
+    const startZ = cellZ * cellSize;
+
+    for (let y = 0; y &lt; cellSize; ++y) {
+      const voxelY = startY + y;
+      for (let z = 0; z &lt; cellSize; ++z) {
+        const voxelZ = startZ + z;
+        for (let x = 0; x &lt; cellSize; ++x) {
+          const voxelX = startX + x;
+          const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
+          if (voxel) {
+            for (const {dir} of VoxelWorld.faces) {
+              const neighbor = this.getVoxel(
+                  voxelX + dir[0],
+                  voxelY + dir[1],
+                  voxelZ + dir[2]);
+              if (!neighbor) {
+                // è¯¥ä½“ç´ åœ¨æ­¤æ–¹å‘ä¸Šæ²¡æœ‰é‚»å±…ï¼Œå› æ­¤éœ€è¦ç”Ÿæˆä¸€ä¸ªé¢
+              }
+            }
+          }
+        }
+      }
+    }
+  }
}

+VoxelWorld.faces = [
+  { // å·¦ä¾§
+    dir: [ -1,  0,  0 ],
+  },
+  { // å³ä¾§
+    dir: [  1,  0,  0 ],
+  },
+  { // åº•éƒ¨
+    dir: [  0, -1,  0 ],
+  },
+  { // é¡¶éƒ¨
+    dir: [  0,  1,  0 ],
+  },
+  { // èƒŒé¢
+    dir: [  0,  0, -1 ],
+  },
+  { // å‰é¢
+    dir: [  0,  0,  1 ],
+  },
+];
</pre>

			<p>é€šè¿‡ä¸Šè¿°ä»£ç ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“ä½•æ—¶éœ€è¦ç”Ÿæˆä¸€ä¸ªé¢ã€‚ç°åœ¨æ¥å®é™…ç”Ÿæˆè¿™äº›é¢ã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
  }
  generateGeometryDataForCell(cellX, cellY, cellZ) {
    const {cellSize} = this;
+    const positions = [];
+    const normals = [];
+    const indices = [];
    const startX = cellX * cellSize;
    const startY = cellY * cellSize;
    const startZ = cellZ * cellSize;

    for (let y = 0; y &lt; cellSize; ++y) {
      const voxelY = startY + y;
      for (let z = 0; z &lt; cellSize; ++z) {
        const voxelZ = startZ + z;
        for (let x = 0; x &lt; cellSize; ++x) {
          const voxelX = startX + x;
          const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
          if (voxel) {
-            for (const {dir} of VoxelWorld.faces) {
+            for (const {dir, corners} of VoxelWorld.faces) {
              const neighbor = this.getVoxel(
                  voxelX + dir[0],
                  voxelY + dir[1],
                  voxelZ + dir[2]);
              if (!neighbor) {
                // è¯¥ä½“ç´ åœ¨æ­¤æ–¹å‘ä¸Šæ²¡æœ‰é‚»å±…ï¼Œå› æ­¤éœ€è¦ç”Ÿæˆä¸€ä¸ªé¢
+                const ndx = positions.length / 3;
+                for (const pos of corners) {
+                  positions.push(pos[0] + x, pos[1] + y, pos[2] + z);
+                  normals.push(...dir);
+                }
+                indices.push(
+                  ndx, ndx + 1, ndx + 2,
+                  ndx + 2, ndx + 1, ndx + 3
+                );
              }
            }
          }
        }
      }
    }
+    return {
+      positions,
+      normals,
+      indices
+    };
  }
}

VoxelWorld.faces = [
  { // å·¦ä¾§
    dir: [ -1,  0,  0 ],
+    corners: [
+      [ 0, 1, 0 ],
+      [ 0, 0, 0 ],
+      [ 0, 1, 1 ],
+      [ 0, 0, 1 ]
+    ]
  },
  { // å³ä¾§
    dir: [  1,  0,  0 ],
+    corners: [
+      [ 1, 1, 1 ],
+      [ 1, 0, 1 ],
+      [ 1, 1, 0 ],
+      [ 1, 0, 0 ]
+    ]
  },
  { // åº•éƒ¨
    dir: [  0, -1,  0 ],
+    corners: [
+      [ 1, 0, 1 ],
+      [ 0, 0, 1 ],
+      [ 1, 0, 0 ],
+      [ 0, 0, 0 ]
+    ]
  },
  { // é¡¶éƒ¨
    dir: [  0,  1,  0 ],
+    corners: [
+      [ 0, 1, 1 ],
+      [ 1, 1, 1 ],
+      [ 0, 1, 0 ],
+      [ 1, 1, 0 ]
+    ]
  },
  { // èƒŒé¢
    dir: [  0,  0, -1 ],
+    corners: [
+      [ 1, 0, 0 ],
+      [ 0, 0, 0 ],
+      [ 1, 1, 0 ],
+      [ 0, 1, 0 ]
+    ]
  },
  { // å‰é¢
    dir: [  0,  0,  1 ],
+    corners: [
+      [ 0, 0, 1 ],
+      [ 1, 0, 1 ],
+      [ 0, 1, 1 ],
+      [ 1, 1, 1 ]
+    ]
  }
];
</pre>
			<p>ä¸Šé¢çš„ä»£ç å·²ç»å¯ä»¥ä¸ºæˆ‘ä»¬ç”ŸæˆåŸºæœ¬çš„å‡ ä½•æ•°æ®ï¼Œæˆ‘ä»¬åªéœ€è¦æä¾› <code class="notranslate" translate="no">getVoxel</code> å‡½æ•°å³å¯ã€‚æˆ‘ä»¬å…ˆä»ä¸€ä¸ªç¡¬ç¼–ç çš„å•å…ƒå¼€å§‹å®ç°ã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
+    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
  }
+  getCellForVoxel(x, y, z) {
+    const {cellSize} = this;
+    const cellX = Math.floor(x / cellSize);
+    const cellY = Math.floor(y / cellSize);
+    const cellZ = Math.floor(z / cellSize);
+    if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
+      return null;
+    }
+    return this.cell;
+  }
+  getVoxel(x, y, z) {
+    const cell = this.getCellForVoxel(x, y, z);
+    if (!cell) {
+      return 0;
+    }
+    const {cellSize} = this;
+    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
+    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
+    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
+    const voxelOffset = voxelY * cellSize * cellSize +
+                        voxelZ * cellSize +
+                        voxelX;
+    return cell[voxelOffset];
+  }
  generateGeometryDataForCell(cellX, cellY, cellZ) {

  ...
}
</pre>

			<p>è¿™æ®µä»£ç çœ‹èµ·æ¥å¯ä»¥æ­£å¸¸å·¥ä½œäº†ã€‚æˆ‘ä»¬å†æ·»åŠ ä¸€ä¸ª <code class="notranslate" translate="no">setVoxel</code> å‡½æ•°ï¼Œä»¥ä¾¿å¯ä»¥è®¾ç½®ä¸€äº›ä½“ç´ æ•°æ®ã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
  }
  getCellForVoxel(x, y, z) {
    const {cellSize} = this;
    const cellX = Math.floor(x / cellSize);
    const cellY = Math.floor(y / cellSize);
    const cellZ = Math.floor(z / cellSize);    if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
      return null;
    }
    return this.cell;
  }
+  setVoxel(x, y, z, v) {
+    let cell = this.getCellForVoxel(x, y, z);
+    if (!cell) {
+      return;  // TODO: æ˜¯å¦åº”æ·»åŠ ä¸€ä¸ªæ–°å•å…ƒï¼Ÿ
+    }
+    const {cellSize} = this;
+    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
+    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
+    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
+    const voxelOffset = voxelY * cellSize * cellSize +
+                        voxelZ * cellSize +
+                        voxelX;
+    cell[voxelOffset] = v;
+  }
  getVoxel(x, y, z) {
    const cell = this.getCellForVoxel(x, y, z);
    if (!cell) {
      return 0;
    }
    const {cellSize} = this;
    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
    const voxelOffset = voxelY * cellSize * cellSize +
                        voxelZ * cellSize +
                        voxelX;
    return cell[voxelOffset];
  }
  generateGeometryDataForCell(cellX, cellY, cellZ) {

  ...
}
</pre>

			<p>å—¯â€¦â€¦æˆ‘æ³¨æ„åˆ°æœ‰å¾ˆå¤šé‡å¤çš„ä»£ç ã€‚è®©æˆ‘ä»¬é‡æ„ä¸€ä¸‹ï¼Œæé«˜ä»£ç å¤ç”¨æ€§ã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
+    this.cellSliceSize = cellSize * cellSize;
    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
  }
  getCellForVoxel(x, y, z) {
    const {cellSize} = this;
    const cellX = Math.floor(x / cellSize);
    const cellY = Math.floor(y / cellSize);
    const cellZ = Math.floor(z / cellSize);
    if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
      return null;
    }
    return this.cell;
  }
+  computeVoxelOffset(x, y, z) {
+    const {cellSize, cellSliceSize} = this;
+    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
+    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
+    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
+    return voxelY * cellSliceSize +
+           voxelZ * cellSize +
+           voxelX;
+  }
  setVoxel(x, y, z, v) {
    const cell = this.getCellForVoxel(x, y, z);
    if (!cell) {
      return;  // TODO: æ˜¯å¦åº”æ·»åŠ ä¸€ä¸ªæ–°å•å…ƒï¼Ÿ
    }
-    const {cellSize} = this;
-    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
-    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
-    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
-    const voxelOffset = voxelY * cellSize * cellSize +
-                        voxelZ * cellSize +
-                        voxelX;
+    const voxelOffset = this.computeVoxelOffset(x, y, z);
    cell[voxelOffset] = v;
  }
  getVoxel(x, y, z) {
    const cell = this.getCellForVoxel(x, y, z);
    if (!cell) {
      return 0;
    }
-    const {cellSize} = this;
-    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
-    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
-    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
-    const voxelOffset = voxelY * cellSize * cellSize +
-                        voxelZ * cellSize +
-                        voxelX;
+    const voxelOffset = this.computeVoxelOffset(x, y, z);
    return cell[voxelOffset];
  }
  generateGeometryDataForCell(cellX, cellY, cellZ) {

  ...
}
</pre>

			<p>ç°åœ¨æˆ‘ä»¬æ¥ç¼–å†™ä»£ç ï¼Œç”¨ä½“ç´ å¡«å……ç¬¬ä¸€ä¸ªå•å…ƒã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const cellSize = 32;

const world = new VoxelWorld(cellSize);

for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const height = (Math.sin(x / cellSize * Math.PI * 2) + Math.sin(z / cellSize * Math.PI * 3)) * (cellSize / 6) + (cellSize / 2);
      if (y &lt; height) {
        world.setVoxel(x, y, z, 1);
      }
    }
  }
}
</pre>
			<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ç¼–å†™å®é™…ç”Ÿæˆå‡ ä½•ä½“çš„ä»£ç ï¼Œå°±åƒæˆ‘ä»¬åœ¨ <a href="custom-buffergeometry.html">è‡ªå®šä¹‰ BufferGeometry æ•™ç¨‹</a>ä¸­ä»‹ç»çš„é‚£æ ·ã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const {positions, normals, indices} = world.generateGeometryDataForCell(0, 0, 0);
const geometry = new THREE.BufferGeometry();
const material = new THREE.MeshLambertMaterial({color: 'green'});

const positionNumComponents = 3;
const normalNumComponents = 3;
geometry.setAttribute(
    'position',
    new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
geometry.setAttribute(
    'normal',
    new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
geometry.setIndex(indices);
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);
</pre>

			<p>è®©æˆ‘ä»¬è¯•è¯•æ•ˆæœï¼š</p>

			<p></p><div translate="no" class="threejs_example_container notranslate">
			<div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/editor.html?url=/manual/examples/voxel-geometry-culled-faces.html"></iframe></div>
			<a class="threejs_center" href="/manual/examples/voxel-geometry-culled-faces.html" target="_blank">ç‚¹å‡»æ­¤å¤„ï¼Œåœ¨æ–°çª—å£ä¸­æ‰“å¼€ç¤ºä¾‹</a>
		</div>

			<p></p>

			<p>çœ‹èµ·æ¥å·²ç»æ­£å¸¸å·¥ä½œäº†ï¼æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ·»åŠ çº¹ç†æ”¯æŒã€‚</p>

			<p>åœ¨ç½‘ä¸Šæœç´¢åï¼Œæˆ‘æ‰¾åˆ°äº†ä¸€ç»„ç”± <a href="https://www.minecraftforum.net/members/Joshtimus">Joshtimus</a> åˆ¶ä½œçš„ã€é‡‡ç”¨ <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA</a> è®¸å¯åè®®çš„ <a href="https://www.minecraftforum.net/forums/mapping-and-modding-java-edition/resource-packs/1245961-16x-1-7-4-wip-flourish">Minecraft çº¹ç†èµ„æºåŒ…</a>ã€‚æˆ‘éšæœºæŒ‘é€‰äº†å‡ å¼ è´´å›¾ï¼Œå¹¶åˆ¶ä½œäº†å¦‚ä¸‹çš„ <a href="https://www.google.com/search?q=texture+atlas">çº¹ç†å›¾é›†ï¼ˆtexture atlasï¼‰</a>ã€‚</p>

			<div class="threejs_center"><img class="checkerboard" src="../examples/resources/images/minecraft/flourish-cc-by-nc-sa.png" style="width: 512px; image-rendering: pixelated;"></div>

			<p>ä¸ºäº†ç®€åŒ–ä½¿ç”¨ï¼Œè¿™äº›çº¹ç†æŒ‰â€œä½“ç´ ç±»å‹â€æ’åˆ—æˆåˆ—ï¼Œå…¶ä¸­ï¼š</p>
			<ul>
				<li><strong>ç¬¬ä¸€è¡Œ</strong>ï¼šä½“ç´ çš„ä¾§é¢ï¼ˆleft/right/front/backï¼‰</li>
				<li><strong>ç¬¬äºŒè¡Œ</strong>ï¼šä½“ç´ çš„é¡¶éƒ¨ï¼ˆtopï¼‰</li>
				<li><strong>ç¬¬ä¸‰è¡Œ</strong>ï¼šä½“ç´ çš„åº•éƒ¨ï¼ˆbottomï¼‰</li>
			</ul>

			<p>äº†è§£äº†å›¾é›†ç»“æ„åï¼Œæˆ‘ä»¬å¯ä»¥å‘ <code class="notranslate" translate="no">VoxelWorld.faces</code> æ•°æ®ä¸­æ·»åŠ ä¿¡æ¯ï¼ŒæŒ‡å®šæ¯ä¸ªé¢åº”ä½¿ç”¨çš„è¡Œï¼ˆuvRowï¼‰ä»¥åŠå¯¹åº”çš„ UV åæ ‡ã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">VoxelWorld.faces = [
  { // å·¦é¢
+    uvRow: 0,
    dir: [ -1,  0,  0 ],
    corners: [
-      [ 0, 1, 0 ],
-      [ 0, 0, 0 ],
-      [ 0, 1, 1 ],
-      [ 0, 0, 1 ],
+      { pos: [ 0, 1, 0 ], uv: [ 0, 1 ] },
+      { pos: [ 0, 0, 0 ], uv: [ 0, 0 ] },
+      { pos: [ 0, 1, 1 ], uv: [ 1, 1 ] },
+      { pos: [ 0, 0, 1 ], uv: [ 1, 0 ] },
    ],
  },
  { // å³é¢
+    uvRow: 0,
    dir: [  1,  0,  0 ],
    corners: [
-      [ 1, 1, 1 ],
-      [ 1, 0, 1 ],
-      [ 1, 1, 0 ],
-      [ 1, 0, 0 ],
+      { pos: [ 1, 1, 1 ], uv: [ 0, 1 ] },
+      { pos: [ 1, 0, 1 ], uv: [ 0, 0 ] },
+      { pos: [ 1, 1, 0 ], uv: [ 1, 1 ] },
+      { pos: [ 1, 0, 0 ], uv: [ 1, 0 ] },
    ],
  },
  { // åº•é¢
+    uvRow: 1,
    dir: [  0, -1,  0 ],
    corners: [
-      [ 1, 0, 1 ],
-      [ 0, 0, 1 ],
-      [ 1, 0, 0 ],
-      [ 0, 0, 0 ],
+      { pos: [ 1, 0, 1 ], uv: [ 1, 0 ] },
+      { pos: [ 0, 0, 1 ], uv: [ 0, 0 ] },
+      { pos: [ 1, 0, 0 ], uv: [ 1, 1 ] },
+      { pos: [ 0, 0, 0 ], uv: [ 0, 1 ] },
    ],
  },
  { // é¡¶é¢
+    uvRow: 2,
    dir: [  0,  1,  0 ],
    corners: [
-      [ 0, 1, 1 ],
-      [ 1, 1, 1 ],
-      [ 0, 1, 0 ],
-      [ 1, 1, 0 ],
+      { pos: [ 0, 1, 1 ], uv: [ 1, 1 ] },
+      { pos: [ 1, 1, 1 ], uv: [ 0, 1 ] },
+      { pos: [ 0, 1, 0 ], uv: [ 1, 0 ] },
+      { pos: [ 1, 1, 0 ], uv: [ 0, 0 ] },
    ],
  },
  { // èƒŒé¢
+    uvRow: 0,
    dir: [  0,  0, -1 ],
    corners: [
-      [ 1, 0, 0 ],
-      [ 0, 0, 0 ],
-      [ 1, 1, 0 ],
-      [ 0, 1, 0 ],
+      { pos: [ 1, 0, 0 ], uv: [ 0, 0 ] },
+      { pos: [ 0, 0, 0 ], uv: [ 1, 0 ] },
+      { pos: [ 1, 1, 0 ], uv: [ 0, 1 ] },
+      { pos: [ 0, 1, 0 ], uv: [ 1, 1 ] },
    ],
  },
  { // å‰é¢
+    uvRow: 0,
    dir: [  0,  0,  1 ],
    corners: [
-      [ 0, 0, 1 ],
-      [ 1, 0, 1 ],
-      [ 0, 1, 1 ],
-      [ 1, 1, 1 ],
+      { pos: [ 0, 0, 1 ], uv: [ 0, 0 ] },
+      { pos: [ 1, 0, 1 ], uv: [ 1, 0 ] },
+      { pos: [ 0, 1, 1 ], uv: [ 0, 1 ] },
+      { pos: [ 1, 1, 1 ], uv: [ 1, 1 ] },
    ],
  },
];
</pre>

			<p>ç„¶åæˆ‘ä»¬æ›´æ–°ç”Ÿæˆå‡ ä½•ä½“çš„ä»£ç ï¼Œä»¥ä½¿ç”¨è¿™äº› UV æ•°æ®ã€‚æˆ‘ä»¬éœ€è¦çŸ¥é“å›¾é›†ä¸­æ¯ä¸ªçº¹ç†å—çš„å¤§å°ä»¥åŠæ•´ä¸ªçº¹ç†å›¾é›†çš„å°ºå¯¸ã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
-  constructor(cellSize) {
-    this.cellSize = cellSize;
+  constructor(options) {
+    this.cellSize = options.cellSize;
+    this.tileSize = options.tileSize;
+    this.tileTextureWidth = options.tileTextureWidth;
+    this.tileTextureHeight = options.tileTextureHeight;
+    const {cellSize} = this;
+    this.cellSliceSize = cellSize * cellSize;
+    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
  }

  ...

  generateGeometryDataForCell(cellX, cellY, cellZ) {
-    const {cellSize} = this;
+    const {cellSize, tileSize, tileTextureWidth, tileTextureHeight} = this;
    const positions = [];
    const normals = [];
+    const uvs = [];
    const indices = [];
    const startX = cellX * cellSize;
    const startY = cellY * cellSize;
    const startZ = cellZ * cellSize;

    for (let y = 0; y &lt; cellSize; ++y) {
      const voxelY = startY + y;
      for (let z = 0; z &lt; cellSize; ++z) {
        const voxelZ = startZ + z;
        for (let x = 0; x &lt; cellSize; ++x) {
          const voxelX = startX + x;
          const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
          if (voxel) {
            const uvVoxel = voxel - 1;  // ä½“ç´  0 ä»£è¡¨å¤©ç©ºï¼Œå› æ­¤ UV ä» 0 å¼€å§‹
            // è¿™é‡Œæœ‰ä½“ç´ ï¼Œä½†éœ€è¦ä¸ºå…¶ç”Ÿæˆé¢å—ï¼Ÿ
-            for (const {dir, corners} of VoxelWorld.faces) {
+            for (const {dir, corners, uvRow} of VoxelWorld.faces) {
              const neighbor = this.getVoxel(
                  voxelX + dir[0],
                  voxelY + dir[1],
                  voxelZ + dir[2]);
              if (!neighbor) {
                // è¯¥æ–¹å‘æ— ç›¸é‚»ä½“ç´ ï¼Œå› æ­¤éœ€è¦æ·»åŠ ä¸€ä¸ªé¢
                const ndx = positions.length / 3;
-                for (const pos of corners) {
+                for (const {pos, uv} of corners) {
                  positions.push(pos[0] + x, pos[1] + y, pos[2] + z);
                  normals.push(...dir);
+                  uvs.push(
+                        (uvVoxel +   uv[0]) * tileSize / tileTextureWidth,
+                    1 - (uvRow + 1 - uv[1]) * tileSize / tileTextureHeight);
                }
                indices.push(
                  ndx, ndx + 1, ndx + 2,
                  ndx + 2, ndx + 1, ndx + 3
                );
              }
            }
          }
        }
      }
    }

    return {
      positions,
      normals,
      uvs,
      indices
    };
  }
}
</pre>
			<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦ <a href="textures.html">åŠ è½½çº¹ç†</a>ã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const loader = new THREE.TextureLoader();
const texture = loader.load('resources/images/minecraft/flourish-cc-by-nc-sa.png', render);
texture.magFilter = THREE.NearestFilter;
texture.minFilter = THREE.NearestFilter;
texture.colorSpace = THREE.SRGBColorSpace;
</pre>

			<p>ç„¶åå°†ç›¸å…³å‚æ•°ä¼ é€’ç»™ <code class="notranslate" translate="no">VoxelWorld</code> ç±»</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const tileSize = 16;
+const tileTextureWidth = 256;
+const tileTextureHeight = 64;
-const world = new VoxelWorld(cellSize);
+const world = new VoxelWorld({
+  cellSize,
+  tileSize,
+  tileTextureWidth,
+  tileTextureHeight,
+});
</pre>

			<p>ç°åœ¨ï¼Œæˆ‘ä»¬å®é™…åœ¨åˆ›å»ºå‡ ä½•ä½“æ—¶ä½¿ç”¨ UV åæ ‡ï¼Œå¹¶åœ¨åˆ›å»ºæè´¨æ—¶ä½¿ç”¨çº¹ç†</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const {positions, normals, indices} = world.generateGeometryDataForCell(0, 0, 0);
+const {positions, normals, uvs, indices} = world.generateGeometryDataForCell(0, 0, 0);
const geometry = new THREE.BufferGeometry();
-const material = new THREE.MeshLambertMaterial({color: 'green'});
+const material = new THREE.MeshLambertMaterial({
+  map: texture,
+  side: THREE.DoubleSide,
+  alphaTest: 0.1,
+  transparent: true,
+});

const positionNumComponents = 3;
const normalNumComponents = 3;
+const uvNumComponents = 2;
geometry.setAttribute(
    'position',
    new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
geometry.setAttribute(
    'normal',
    new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
+geometry.setAttribute(
+    'uv',
+    new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
geometry.setIndex(indices);
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);
</pre>

			<p>æœ€åä¸€ä»¶äº‹ï¼šæˆ‘ä»¬éœ€è¦è®¾ç½®ä¸€äº›ä½“ç´ ï¼Œä½¿ç”¨ä¸åŒçš„çº¹ç†ã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const height = (Math.sin(x / cellSize * Math.PI * 2) + Math.sin(z / cellSize * Math.PI * 3)) * (cellSize / 6) + (cellSize / 2);
      if (y &lt; height) {
-        world.setVoxel(x, y, z, 1);
+        world.setVoxel(x, y, z, randInt(1, 17));
      }
    }
  }
}

+function randInt(min, max) {
+  return Math.floor(Math.random() * (max - min) + min);
+}
</pre>

			<p>è¿™æ ·ï¼Œæˆ‘ä»¬å°±æˆåŠŸåº”ç”¨äº†çº¹ç†ï¼</p>

			<p></p><div translate="no" class="threejs_example_container notranslate">
			<div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/voxel-geometry-culled-faces-with-textures.html"></iframe></div>
			<a class="threejs_center" href="/manual/examples/voxel-geometry-culled-faces-with-textures.html" target="_blank">ç‚¹å‡»æ­¤å¤„ï¼Œåœ¨æ–°çª—å£ä¸­æ‰“å¼€ç¤ºä¾‹</a>
		</div>

			<p></p>

			<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è®©ç¨‹åºæ”¯æŒå¤šä¸ªä½“ç´ å•å…ƒï¼ˆcellï¼‰ã€‚</p>

			<p>ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨â€œå•å…ƒ IDâ€æ¥å­˜å‚¨å•å…ƒã€‚å•å…ƒ ID å°±æ˜¯å•å…ƒåæ ‡çš„å­—ç¬¦ä¸²è¡¨ç¤ºï¼Œç”¨é€—å·åˆ†éš”ã€‚ä¾‹å¦‚ï¼Œä½“ç´ åæ ‡ (35, 0, 0) å±äºå•å…ƒ (1, 0, 0)ï¼Œå…¶ ID ä¸º <code class="notranslate" translate="no">"1,0,0"</code>ã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(options) {
    this.cellSize = options.cellSize;
    this.tileSize = options.tileSize;
    this.tileTextureWidth = options.tileTextureWidth;
    this.tileTextureHeight = options.tileTextureHeight;
    const {cellSize} = this;
    this.cellSliceSize = cellSize * cellSize;
-    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
+    this.cells = {};
  }
+  computeCellId(x, y, z) {
+    const {cellSize} = this;
+    const cellX = Math.floor(x / cellSize);
+    const cellY = Math.floor(y / cellSize);
+    const cellZ = Math.floor(z / cellSize);
+    return `${cellX},${cellY},${cellZ}`;
+  }
+  getCellForVoxel(x, y, z) {
-    const cellX = Math.floor(x / cellSize);
-    const cellY = Math.floor(y / cellSize);
-    const cellZ = Math.floor(z / cellSize);
-    if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
-      return null;
-    }
-    return this.cell;
+    return this.cells[this.computeCellId(x, y, z)];
  }

   ...
}
</pre>

			<p>ç°åœ¨æˆ‘ä»¬å¯ä»¥ä¿®æ”¹ <code class="notranslate" translate="no">setVoxel</code> æ–¹æ³•ï¼šå½“å°è¯•è®¾ç½®ä¸€ä¸ªå°šæœªå­˜åœ¨çš„å•å…ƒä¸­çš„ä½“ç´ æ—¶ï¼Œè‡ªåŠ¨åˆ›å»ºè¯¥å•å…ƒã€‚</p>

			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  setVoxel(x, y, z, v) {
-    const cell = this.getCellForVoxel(x, y, z);
+    let cell = this.getCellForVoxel(x, y, z);
    if (!cell) {
-      return 0;
+      cell = this.addCellForVoxel(x, y, z);
    }
    const voxelOffset = this.computeVoxelOffset(x, y, z);
    cell[voxelOffset] = v;
  }
+  addCellForVoxel(x, y, z) {
+    const cellId = this.computeCellId(x, y, z);
+    let cell = this.cells[cellId];
+    if (!cell) {
+      const {cellSize} = this;
+      cell = new Uint8Array(cellSize * cellSize * cellSize);
+      this.cells[cellId] = cell;
+    }
+    return cell;
+  }
</pre>

			<p>è®©æˆ‘ä»¬ä¸ºåœºæ™¯æ·»åŠ å¯ç¼–è¾‘åŠŸèƒ½ã€‚</p>

			<p>é¦–å…ˆï¼Œæˆ‘ä»¬æ·»åŠ ä¸€ä¸ªç”¨æˆ·ç•Œé¢ï¼ˆUIï¼‰ã€‚ä½¿ç”¨å•é€‰æŒ‰é’®ï¼ˆradio buttonsï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ª 8Ã—2 çš„çº¹ç†é€‰æ‹©é¢æ¿ï¼š</p>

			<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;body&gt;
  &lt;canvas id="c"&gt;&lt;/canvas&gt;
+  &lt;div id="ui"&gt;
+    &lt;div class="tiles"&gt;
+      &lt;input type="radio" name="voxel" id="voxel1" value="1"&gt;&lt;label for="voxel1" style="background-position:   -0% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel2" value="2"&gt;&lt;label for="voxel2" style="background-position: -100% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel3" value="3"&gt;&lt;label for="voxel3" style="background-position: -200% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel4" value="4"&gt;&lt;label for="voxel4" style="background-position: -300% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel5" value="5"&gt;&lt;label for="voxel5" style="background-position: -400% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel6" value="6"&gt;&lt;label for="voxel6" style="background-position: -500% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel7" value="7"&gt;&lt;label for="voxel7" style="background-position: -600% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel8" value="8"&gt;&lt;label for="voxel8" style="background-position: -700% -0%"&gt;&lt;/label&gt;
+    &lt;/div&gt;
+    &lt;div class="tiles"&gt;
+      &lt;input type="radio" name="voxel" id="voxel9"  value="9" &gt;&lt;label for="voxel9"  style="background-position:  -800% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel10" value="10"&gt;&lt;label for="voxel10" style="background-position:  -900% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel11" value="11"&gt;&lt;label for="voxel11" style="background-position: -1000% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel12" value="12"&gt;&lt;label for="voxel12" style="background-position: -1100% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel13" value="13"&gt;&lt;label for="voxel13" style="background-position: -1200% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel14" value="14"&gt;&lt;label for="voxel14" style="background-position: -1300% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel15" value="15"&gt;&lt;label for="voxel15" style="background-position: -1400% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel16" value="16"&gt;&lt;label for="voxel16" style="background-position: -1500% -0%"&gt;&lt;/label&gt;
+    &lt;/div&gt;
+  &lt;/div&gt;
&lt;/body&gt;
</pre>

			<p>å†æ·»åŠ ä¸€äº› CSS æ ·å¼ï¼Œç”¨äºç¾åŒ– UIã€æ˜¾ç¤ºçº¹ç†å›¾å—ï¼Œå¹¶é«˜äº®å½“å‰é€‰ä¸­çš„é¡¹ï¼š</p>
			<pre class="prettyprint showlinemods notranslate lang-css" translate="no">body {
    margin: 0;
}
#c {
    width: 100%;
    height: 100%;
    display: block;
}
+#ui {
+    position: absolute;
+    left: 10px;
+    top: 10px;
+    background: rgba(0, 0, 0, 0.8);
+    padding: 5px;
+}
+#ui input[type=radio] {
+  width: 0;
+  height: 0;
+  display: none;
+}
+#ui input[type=radio] + label {
+  background-image: url('resources/images/minecraft/flourish-cc-by-nc-sa.png');
+  background-size: 1600% 400%;
+  image-rendering: pixelated;
+  width: 64px;
+  height: 64px;
+  display: inline-block;
+}
+#ui input[type=radio]:checked + label {
+  outline: 3px solid red;
+}
+@media (max-width: 600px), (max-height: 600px) {
+  #ui input[type=radio] + label {
+    width: 32px;
+    height: 32px;
+  }
+}
</pre>
			<p>ç”¨æˆ·ä½“éªŒå°†å¦‚ä¸‹æ‰€ç¤ºï¼šå¦‚æœæ²¡æœ‰é€‰æ‹©ä»»ä½•æ–¹å—å¹¶ç‚¹å‡»ä¸€ä¸ªä½“ç´ ï¼Œè¯¥ä½“ç´ å°†è¢«åˆ é™¤ï¼›æˆ–è€…ï¼Œå¦‚æœç‚¹å‡»ä¸€ä¸ªä½“ç´ å¹¶æŒ‰ä½ Shift é”®ï¼Œå®ƒä¹Ÿä¼šè¢«åˆ é™¤ã€‚å¦åˆ™ï¼Œå¦‚æœé€‰æ‹©äº†ä¸€ä¸ªæ–¹å—ï¼Œå®ƒå°†è¢«æ·»åŠ ã€‚ä½ å¯ä»¥å†æ¬¡ç‚¹å‡»å·²é€‰ä¸­çš„æ–¹å—ç±»å‹æ¥å–æ¶ˆé€‰æ‹©ã€‚</p>
			<p>ä¸‹é¢çš„ä»£ç å¯ä»¥è®©ç”¨æˆ·å–æ¶ˆé€‰ä¸­çš„å•é€‰æŒ‰é’®ã€‚</p>
			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">let currentVoxel = 0;
let currentId;

document.querySelectorAll('#ui .tiles input[type=radio][name=voxel]').forEach((elem) =&gt; {
  elem.addEventListener('click', allowUncheck);
});

function allowUncheck() {
  if (this.id === currentId) {
    this.checked = false;
    currentId = undefined;
    currentVoxel = 0;
  } else {
    currentId = this.id;
    currentVoxel = parseInt(this.value);
  }
}
</pre>
			<p>ä¸‹é¢çš„ä»£ç ä¼šæ ¹æ®ç”¨æˆ·ç‚¹å‡»çš„ä½ç½®æ”¾ç½®ä½“ç´ ã€‚å®ƒä½¿ç”¨äº†ç±»ä¼¼æˆ‘ä»¬åœ¨ <a href="picking.html">æ‹¾å–é‚£ç¯‡æ–‡ç« </a> ä¸­çš„ä»£ç ï¼Œä½†ä¸æ˜¯ç”¨å†…ç½®çš„ <code class="notranslate" translate="no">RayCaster</code>ï¼Œè€Œæ˜¯ç”¨ <code class="notranslate" translate="no">VoxelWorld.intersectRay</code>ï¼Œå®ƒè¿”å›äº¤ç‚¹çš„ä½ç½®å’Œè¢«å‡»ä¸­çš„é¢çš„æ³•çº¿ã€‚</p>
			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function getCanvasRelativePosition(event) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (event.clientX - rect.left) * canvas.width  / rect.width,
    y: (event.clientY - rect.top ) * canvas.height / rect.height,
  };
}

function placeVoxel(event) {
  const pos = getCanvasRelativePosition(event);
  const x = (pos.x / canvas.width ) *  2 - 1;
  const y = (pos.y / canvas.height) * -2 + 1;  // æ³¨æ„è¿™é‡Œ Y è¦ç¿»è½¬

  const start = new THREE.Vector3();
  const end = new THREE.Vector3();
  start.setFromMatrixPosition(camera.matrixWorld);
  end.set(x, y, 1).unproject(camera);

  const intersection = world.intersectRay(start, end);
  if (intersection) {
    const voxelId = event.shiftKey ? 0 : currentVoxel;
    // äº¤ç‚¹ä½äºé¢ä¸Šï¼Œè¿™æ„å‘³ç€æ•°å­¦ç²¾åº¦é—®é¢˜å¯èƒ½ä¼šè®©æˆ‘ä»¬ä½äºé¢çš„ä»»ä¸€ä¾§
    // å¦‚æœæ˜¯åˆ é™¤ï¼ˆcurrentVoxel = 0ï¼‰ï¼Œåˆ™æ²¿æ³•çº¿æ–¹å‘è¿›å…¥ä½“ç´ ä¸€åŠ
    // å¦‚æœæ˜¯æ·»åŠ ï¼ˆcurrentVoxel > 0ï¼‰ï¼Œåˆ™æ²¿æ³•çº¿æ–¹å‘ç¦»å¼€ä½“ç´ ä¸€åŠ
    const pos = intersection.position.map((v, ndx) =&gt; {
      return v + intersection.normal[ndx] * (voxelId &gt; 0 ? 0.5 : -0.5);
    });
    world.setVoxel(...pos, voxelId);
    updateVoxelGeometry(...pos);
    requestRenderIfNotRequested();
  }
}

const mouse = {
  x: 0,
  y: 0,
};

function recordStartPosition(event) {
  mouse.x = event.clientX;
  mouse.y = event.clientY;
  mouse.moveX = 0;
  mouse.moveY = 0;
}
function recordMovement(event) {
  mouse.moveX += Math.abs(mouse.x - event.clientX);
  mouse.moveY += Math.abs(mouse.y - event.clientY);
}
function placeVoxelIfNoMovement(event) {
  if (mouse.moveX &lt; 5 &amp;&amp; mouse.moveY &lt; 5) {
    placeVoxel(event);
  }
  window.removeEventListener('pointermove', recordMovement);
  window.removeEventListener('pointerup', placeVoxelIfNoMovement);
}
canvas.addEventListener('pointerdown', (event) =&gt; {
  event.preventDefault();
  recordStartPosition(event);
  window.addEventListener('pointermove', recordMovement);
  window.addEventListener('pointerup', placeVoxelIfNoMovement);
}, {passive: false});
canvas.addEventListener('touchstart', (event) =&gt; {
  // é˜»æ­¢æ»šåŠ¨
  event.preventDefault();
}, {passive: false});
</pre>
			<p>ä¸Šé¢çš„ä»£ç åšäº†å¾ˆå¤šäº‹ã€‚åŸºæœ¬ä¸Šï¼Œé¼ æ ‡æœ‰åŒé‡ç”¨é€”ï¼šä¸€æ˜¯ç§»åŠ¨ç›¸æœºï¼ŒäºŒæ˜¯ç¼–è¾‘ä¸–ç•Œã€‚å½“ä½ æ¾å¼€é¼ æ ‡æ—¶ï¼Œå¦‚æœåœ¨æŒ‰ä¸‹é¼ æ ‡åæ²¡æœ‰ç§»åŠ¨å®ƒï¼Œå°±ä¼šæ”¾ç½®/åˆ é™¤ä¸€ä¸ªä½“ç´ ã€‚è¿™æ˜¯å‡è®¾å¦‚æœä½ ç§»åŠ¨äº†é¼ æ ‡ï¼Œä½ æ˜¯æƒ³ç§»åŠ¨ç›¸æœºè€Œä¸æ˜¯æ”¾ç½®æ–¹å—ã€‚<code class="notranslate" translate="no">moveX</code> å’Œ <code class="notranslate" translate="no">moveY</code> æ˜¯ç»å¯¹ç§»åŠ¨è·ç¦»ï¼Œæ‰€ä»¥å¦‚æœä½ å‘å·¦ç§»åŠ¨ 10 ç„¶åå†å‘å³ç§»åŠ¨ 10ï¼Œæ€»å…±ç§»åŠ¨äº† 20 ä¸ªå•ä½ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œç”¨æˆ·å¾ˆå¯èƒ½åªæ˜¯æ¥å›æ—‹è½¬æ¨¡å‹ï¼Œè€Œä¸æƒ³æ”¾ç½®æ–¹å—ã€‚æˆ‘æ²¡æœ‰æµ‹è¯• <code class="notranslate" translate="no">5</code> è¿™ä¸ªèŒƒå›´æ˜¯å¦åˆé€‚ã€‚</p>
			<p>åœ¨ä»£ç ä¸­æˆ‘ä»¬è°ƒç”¨ <code class="notranslate" translate="no">world.setVoxel</code> æ¥è®¾ç½®ä¸€ä¸ªä½“ç´ ï¼Œç„¶åè°ƒç”¨ <code class="notranslate" translate="no">updateVoxelGeometry</code> æ¥æ ¹æ®å˜åŒ–æ›´æ–° three.js çš„å‡ ä½•ä½“ã€‚</p>
			<p>æˆ‘ä»¬ç°åœ¨æ¥å®ç°å®ƒã€‚å¦‚æœç”¨æˆ·ç‚¹å‡»äº†å•å…ƒæ ¼è¾¹ç¼˜çš„ä½“ç´ ï¼Œé‚£ä¹ˆç›¸é‚»å•å…ƒæ ¼çš„å‡ ä½•ä½“å¯èƒ½ä¹Ÿéœ€è¦æ›´æ–°ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬éœ€è¦æ£€æŸ¥åˆšåˆšç¼–è¾‘çš„ä½“ç´ æ‰€åœ¨çš„å•å…ƒæ ¼ï¼Œä»¥åŠè¯¥å•å…ƒæ ¼åœ¨ 6 ä¸ªæ–¹å‘ä¸Šçš„ç›¸é‚»å•å…ƒæ ¼ã€‚</p>
			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const neighborOffsets = [
  [ 0,  0,  0], // è‡ªèº«
  [-1,  0,  0], // å·¦
  [ 1,  0,  0], // å³
  [ 0, -1,  0], // ä¸‹
  [ 0,  1,  0], // ä¸Š
  [ 0,  0, -1], // å
  [ 0,  0,  1], // å‰
];
function updateVoxelGeometry(x, y, z) {
  const updatedCellIds = {};
  for (const offset of neighborOffsets) {
    const ox = x + offset[0];
    const oy = y + offset[1];
    const oz = z + offset[2];
    const cellId = world.computeCellId(ox, oy, oz);
    if (!updatedCellIds[cellId]) {
      updatedCellIds[cellId] = true;
      updateCellGeometry(ox, oy, oz);
    }
  }
}
</pre>
			<p>æˆ‘æœ¬æ¥æ‰“ç®—è¿™æ ·æ£€æŸ¥ç›¸é‚»å•å…ƒæ ¼ï¼š</p>
			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
if (voxelX === 0) {
  // æ›´æ–°å·¦è¾¹çš„å•å…ƒæ ¼
} else if (voxelX === cellSize - 1) {
  // æ›´æ–°å³è¾¹çš„å•å…ƒæ ¼
}
</pre>
			<p>å¹¶ä¸”ä¸ºå¦å¤– 4 ä¸ªæ–¹å‘å†åŠ  4 æ¬¡æ£€æŸ¥ï¼Œä½†æˆ‘æƒ³åˆ°ç›´æ¥ç”¨ä¸€ä¸ªåç§»æ•°ç»„ï¼Œå¹¶ä¿å­˜å·²æ›´æ–°è¿‡çš„å•å…ƒæ ¼ IDï¼Œä»£ç ä¼šæ›´ç®€å•ã€‚å¦‚æœæ›´æ–°çš„ä½“ç´ ä¸åœ¨å•å…ƒæ ¼è¾¹ç¼˜ï¼Œæµ‹è¯•ä¼šå¾ˆå¿«è·³è¿‡æ›´æ–°åŒä¸€ä¸ªå•å…ƒæ ¼ã€‚</p>
			<p>å¯¹äº <code class="notranslate" translate="no">updateCellGeometry</code>ï¼Œæˆ‘ä»¬å°†ç›´æ¥ä½¿ç”¨ä¹‹å‰ç”Ÿæˆä¸€ä¸ªå•å…ƒæ ¼å‡ ä½•ä½“çš„ä»£ç ï¼Œå¹¶è®©å®ƒæ”¯æŒå¤„ç†å¤šä¸ªå•å…ƒæ ¼ã€‚</p>
			<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const cellIdToMesh = {};
function updateCellGeometry(x, y, z) {
  const cellX = Math.floor(x / cellSize);
  const cellY = Math.floor(y / cellSize);
  const cellZ = Math.floor(z / cellSize);
  const cellId = world.computeCellId(x, y, z);
  let mesh = cellIdToMesh[cellId];
  const geometry = mesh ? mesh.geometry : new THREE.BufferGeometry();

  const {positions, normals, uvs, indices} = world.generateGeometryDataForCell(cellX, cellY, cellZ);
  const positionNumComponents = 3;
  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
  const normalNumComponents = 3;
  geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
  const uvNumComponents = 2;
  geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
  geometry.setIndex(indices);
  geometry.computeBoundingSphere();

  if (!mesh) {
    mesh = new THREE.Mesh(geometry, material);
    mesh.name = cellId;
    cellIdToMesh[cellId] = mesh;
    scene.add(mesh);
    mesh.position.set(cellX * cellSize, cellY * cellSize, cellZ * cellSize);
  }
}
</pre>
			<p>ä¸Šé¢çš„ä»£ç ä¼šæ£€æŸ¥å•å…ƒæ ¼ ID åˆ°ç½‘æ ¼çš„æ˜ å°„ã€‚å¦‚æœæˆ‘ä»¬è¯·æ±‚çš„å•å…ƒæ ¼ä¸å­˜åœ¨ï¼Œå°±ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ <a href="/docs/#api/en/objects/Mesh"><code class="notranslate" translate="no">Mesh</code></a> å¹¶æ”¾åˆ°ä¸–ç•Œç©ºé—´çš„æ­£ç¡®ä½ç½®ã€‚æœ€åï¼Œæˆ‘ä»¬ç”¨æ–°æ•°æ®æ›´æ–°å±æ€§å’Œç´¢å¼•ã€‚</p>
			<div translate="no" class="threejs_example_container notranslate">
				<div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/voxel-geometry-culled-faces-ui.html"></iframe></div>
				<a class="threejs_center" href="/manual/examples/voxel-geometry-culled-faces-ui.html" target="_blank">ç‚¹å‡»è¿™é‡Œåœ¨æ–°çª—å£ä¸­æ‰“å¼€</a>
			</div>

			<p>ä¸€äº›æ³¨æ„äº‹é¡¹ï¼š</p>
			<p><code class="notranslate" translate="no">RayCaster</code> å¯èƒ½ä¹Ÿèƒ½å¾ˆå¥½åœ°å·¥ä½œï¼Œæˆ‘æ²¡è¯•è¿‡ã€‚æˆ‘æ‰¾åˆ°çš„æ˜¯ä¸€ä¸ª<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.42.3443&rep=rep1&type=pdf">é’ˆå¯¹ä½“ç´ ä¼˜åŒ–çš„å…‰çº¿æŠ•å°„å™¨</a>ã€‚</p>
			<p>æˆ‘æŠŠ <code class="notranslate" translate="no">intersectRay</code> åšæˆäº† VoxelWorld çš„ä¸€éƒ¨åˆ†ï¼Œå› ä¸ºå¦‚æœå®ƒå¤ªæ…¢ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆå¯¹å•å…ƒæ ¼è¿›è¡Œå…‰çº¿æŠ•å°„ï¼Œå†å¯¹ä½“ç´ è¿›è¡Œå…‰çº¿æŠ•å°„ï¼Œä½œä¸ºä¸€ç§ç®€å•çš„åŠ é€Ÿæ–¹å¼ã€‚</p>
			<p>ä½ å¯èƒ½éœ€è¦ä¿®æ”¹å…‰çº¿æŠ•å°„çš„é•¿åº¦ï¼Œå› ä¸ºç›®å‰å®ƒä¼šä¸€ç›´åˆ° Z-farã€‚æˆ‘çŒœå¦‚æœç”¨æˆ·ç‚¹å‡»äº†å¾ˆè¿œçš„åœ°æ–¹ï¼Œä»–ä»¬å¹¶ä¸æ˜¯çœŸçš„æƒ³åœ¨ä¸–ç•Œå¦ä¸€ç«¯çš„ 1ã€2 åƒç´ å¤§çš„ä½ç½®æ”¾æ–¹å—ã€‚</p>
			<p>è°ƒç”¨ <code class="notranslate" translate="no">geometry.computeBoundingSphere</code> å¯èƒ½ä¼šæ¯”è¾ƒæ…¢ã€‚æˆ‘ä»¬å¯ä»¥ç›´æ¥æ‰‹åŠ¨è®¾ç½®åŒ…å›´çƒä»¥é€‚é…æ•´ä¸ªå•å…ƒæ ¼ã€‚</p>
			<p>å½“ä¸€ä¸ªå•å…ƒæ ¼é‡Œçš„æ‰€æœ‰ä½“ç´ éƒ½æ˜¯ 0 æ—¶ï¼Œæˆ‘ä»¬æ˜¯å¦è¦ç§»é™¤è¿™ä¸ªå•å…ƒæ ¼ï¼Ÿå¦‚æœè¦å‘å¸ƒè¿™ä¸ªåŠŸèƒ½ï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªåˆç†çš„ä¼˜åŒ–ã€‚</p>
			<p>è€ƒè™‘è¿™ä¸ªå·¥ä½œçš„æ–¹å¼ï¼Œæœ€ç³Ÿç³•çš„æƒ…å†µæ˜¯ä¸€ä¸ªå¼€å…³ä½“ç´ äº¤é”™çš„æ£‹ç›˜æ ¼ã€‚æˆ‘æš‚æ—¶ä¸çŸ¥é“åœ¨æ€§èƒ½å¤ªæ…¢æ—¶å¯ä»¥ç”¨ä»€ä¹ˆå…¶ä»–ç­–ç•¥ã€‚ä¹Ÿè®¸æ€§èƒ½æ…¢äº†ä¼šä¿ƒä½¿ç”¨æˆ·ä¸è¦å»åšè¶…å¤§æ£‹ç›˜æ ¼ã€‚</p>
			<p>ä¸ºäº†ç®€å•èµ·è§ï¼Œçº¹ç†å›¾é›†æ˜¯æ¯ç§æ–¹å—ç±»å‹å ç”¨ 1 åˆ—ã€‚æ›´å¥½çš„åšæ³•æ˜¯åˆ¶ä½œä¸€ä¸ªæ›´çµæ´»çš„ç»“æ„ï¼Œè®©æ¯ç§æ–¹å—ç±»å‹å¯ä»¥æŒ‡å®šå®ƒçš„é¢çº¹ç†åœ¨å›¾é›†ä¸­çš„ä½ç½®ã€‚ç°åœ¨è¿™ç§æ–¹å¼æµªè´¹äº†å¾ˆå¤šç©ºé—´ã€‚</p>
			<p>çœ‹çœ‹çœŸæ­£çš„ Minecraftï¼Œä¼šå‘ç°æœ‰äº›æ–¹å—ä¸æ˜¯ç«‹æ–¹ä½“ï¼Œæ¯”å¦‚æ …æ æˆ–èŠ±ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–¹å—ç±»å‹è¡¨ï¼Œæ¯ç§æ–¹å—è¦è®°å½•å®ƒæ˜¯ç«‹æ–¹ä½“è¿˜æ˜¯å…¶ä»–å‡ ä½•å½¢çŠ¶ã€‚å¦‚æœä¸æ˜¯ç«‹æ–¹ä½“ï¼Œé‚£ä¹ˆåœ¨ç”Ÿæˆå‡ ä½•ä½“æ—¶çš„é‚»å±…æ£€æµ‹ä¹Ÿéœ€è¦æ”¹å˜ã€‚ä¾‹å¦‚èŠ±æ–¹å—æ—è¾¹çš„å¦ä¸€ä¸ªæ–¹å—ä¸åº”è¯¥ç§»é™¤å®ƒä»¬ä¹‹é—´çš„é¢ã€‚</p>
			<p>å¦‚æœä½ æƒ³ç”¨ three.js åšä¸€ä¸ªç±» Minecraft çš„ä¸œè¥¿ï¼Œå¸Œæœ›è¿™äº›å†…å®¹èƒ½ç»™ä½ ä¸€äº›èµ·æ­¥æ€è·¯ï¼Œä»¥åŠå¦‚ä½•ç”Ÿæˆç›¸å¯¹é«˜æ•ˆçš„å‡ ä½•ä½“ã€‚</p>
			<p><canvas id="c"></canvas></p>
			<script type="module" src="../resources/threejs-voxel-geometry.js"></script>



		</div>
	</div>
</div>

<script src="../resources/prettify.js"></script>
<script src="../resources/lesson.js"></script>




</body></html>
