<!DOCTYPE html><html lang="fr"><head>
    <meta charset="utf-8">
    <title>Three.js et Shadertoy</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@threejs">
    <meta name="twitter:title" content="Three.js ‚Äì et Shadertoy">
    <meta property="og:image" content="https://threejs.org/files/share.png">
    <link rel="shortcut icon" href="../../files/favicon_white.ico" media="(prefers-color-scheme: dark)">
    <link rel="shortcut icon" href="../../files/favicon.ico" media="(prefers-color-scheme: light)">

    <link rel="stylesheet" href="../resources/lesson.css">
    <link rel="stylesheet" href="../resources/lang.css">
<script type="importmap">
{
  "imports": {
    "three": "../../build/three.module.js"
  }
}
</script>
  </head>
  <body>
    <div class="container">
      <div class="lesson-title">
        <h1>Three.js et Shadertoy</h1>
      </div>
      <div class="lesson">
        <div class="lesson-main">
          <p><a href="https://shadertoy.com">Shadertoy</a> est un site web c√©l√®bre qui h√©berge des exp√©riences de shaders incroyables. Les gens demandent souvent comment ils peuvent utiliser ces shaders avec Three.js.</p>
<p>Il est important de reconna√Ætre que cela s'appelle Shader<strong>TOY</strong> pour une raison. En g√©n√©ral, les shaders shadertoy ne sont pas ax√©s sur les meilleures pratiques. Il s'agit plut√¥t d'un d√©fi amusant, similaire √† dwitter (√©crire du code en 140 caract√®res) ou js13kGames (faire un jeu en 13k ou moins).</p>
<p>Dans le cas de Shadertoy, le d√©fi est : <em>√©crire une fonction qui, pour une position de pixel donn√©e, produit une couleur qui dessine quelque chose d'int√©ressant</em>. C'est un d√©fi amusant et de nombreux r√©sultats sont incroyables. Mais ce n'est pas la meilleure pratique.</p>
<p>Comparez <a href="https://www.shadertoy.com/view/XtsSWs">ce shader shadertoy incroyable qui dessine une ville enti√®re</a></p>
<div class="threejs_center"><img src="../resources/images/shadertoy-skyline.png"></div>

<p>En plein √©cran sur mon GPU, il tourne √† environ 5 images par seconde. Comparez cela √† <a href="https://store.steampowered.com/app/255710/Cities_Skylines/">un jeu comme Cities: Skylines</a></p>
<div class="threejs_center"><img src="../resources/images/cities-skylines.jpg" style="width: 600px;"></div>

<p>Ce jeu tourne √† 30-60 images par seconde sur la m√™me machine car il utilise des techniques plus traditionnelles, dessinant des b√¢timents faits de triangles avec des textures, etc...</p>
<p>N√©anmoins, passons en revue l'utilisation d'un shader Shadertoy avec three.js.</p>
<p>C'est le shader shadertoy par d√©faut si vous <a href="https://www.shadertoy.com/new">choisissez "New" sur shadertoy.com</a>, du moins en janvier 2019.</p>
<pre class="prettyprint showlinemods notranslate lang-glsl" translate="no">// Par iq: https://www.shadertoy.com/user/iq
// licence: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Coordonn√©es normalis√©es des pixels (de 0 √† 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Couleur variable des pixels avec le temps
    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Sortie √† l'√©cran
    fragColor = vec4(col,1.0);
}
</pre>
<p>Une chose importante √† comprendre √† propos des shaders est qu'ils sont √©crits dans un langage appel√© GLSL (Graphics Library Shading Language) con√ßu pour les math√©matiques 3D qui inclut des types sp√©ciaux. Ci-dessus, nous voyons <code class="notranslate" translate="no">vec4</code>, <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code> comme 3 de ces types sp√©ciaux. Un <code class="notranslate" translate="no">vec2</code> a 2 valeurs, un <code class="notranslate" translate="no">vec3</code> 3, un <code class="notranslate" translate="no">vec4</code> 4 valeurs. Ils peuvent √™tre adress√©s de plusieurs mani√®res. Les mani√®res les plus courantes sont avec <code class="notranslate" translate="no">x</code>, <code class="notranslate" translate="no">y</code>, <code class="notranslate" translate="no">z</code> et <code class="notranslate" translate="no">w</code> comme dans</p>
<pre class="prettyprint showlinemods notranslate lang-glsl" translate="no">vec4 v1 = vec4(1.0, 2.0, 3.0, 4.0);
float v2 = v1.x + v1.y;  // adds 1.0 + 2.0
</pre>
<p>Contrairement √† JavaScript, GLSL ressemble plus √† C/C++ o√π les variables doivent avoir leur type d√©clar√©, donc au lieu de <code class="notranslate" translate="no">var v = 1.2;</code> c'est <code class="notranslate" translate="no">float v = 1.2;</code> d√©clarant <code class="notranslate" translate="no">v</code> comme un nombre √† virgule flottante.</p>
<p>Expliquer GLSL en d√©tail d√©passe le cadre de cet article. Pour un aper√ßu rapide, consultez <a href="https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html">cet article</a> et peut-√™tre poursuivez avec <a href="https://thebookofshaders.com/">cette s√©rie</a>.</p>
<p>Il convient de noter que, du moins en janvier 2019, <a href="https://shadertoy.com">shadertoy.com</a> ne s'occupe que des <em>fragment shaders</em>. La responsabilit√© d'un fragment shader est, √©tant donn√© une position de pixel, de produire une couleur pour ce pixel.</p>
<p>En regardant la fonction ci-dessus, nous pouvons voir que le shader a un param√®tre <code class="notranslate" translate="no">out</code> appel√© <code class="notranslate" translate="no">fragColor</code>. <code class="notranslate" translate="no">out</code> signifie <code class="notranslate" translate="no">output</code> (sortie). C'est un param√®tre pour lequel la fonction est cens√©e fournir une valeur. Nous devons le d√©finir √† une certaine couleur.</p>
<p>Il a √©galement un param√®tre <code class="notranslate" translate="no">in</code> (pour input, entr√©e) appel√© <code class="notranslate" translate="no">fragCoord</code>. C'est la coordonn√©e du pixel qui est sur le point d'√™tre dessin√©e. Nous pouvons utiliser cette coordonn√©e pour d√©cider d'une couleur. Si le canevas sur lequel nous dessinons est de 400x300 pixels, alors la fonction sera appel√©e 400x300 fois, soit 120 000 fois. √Ä chaque fois, <code class="notranslate" translate="no">fragCoord</code> sera une coordonn√©e de pixel diff√©rente.</p>
<p>Il y a 2 autres variables utilis√©es qui ne sont pas d√©finies dans le code. L'une est <code class="notranslate" translate="no">iResolution</code>. Elle est d√©finie √† la r√©solution du canevas. Si le canevas est de 400x300, alors <code class="notranslate" translate="no">iResolution</code> serait 400,300, donc au fur et √† mesure que les coordonn√©es des pixels changent, cela fait passer <code class="notranslate" translate="no">uv</code> de 0.0 √† 1.0 en travers et vers le haut de la texture. Travailler avec des valeurs <em>normalis√©es</em> rend souvent les choses plus faciles, c'est pourquoi la majorit√© des shaders shadertoy commencent par quelque chose comme √ßa.</p>
<p>L'autre variable non d√©finie dans le shader est <code class="notranslate" translate="no">iTime</code>. C'est le temps √©coul√© depuis le chargement de la page en secondes.</p>
<p>Dans le jargon des shaders, ces variables globales sont appel√©es variables <em>uniformes</em>. Elles sont appel√©es <em>uniformes</em> car elles ne changent pas, elles restent uniformes d'une it√©ration du shader √† la suivante. Il est important de noter qu'elles sont toutes sp√©cifiques √† shadertoy. Ce ne sont pas des variables GLSL <em>officielles</em>. Ce sont des variables que les cr√©ateurs de shadertoy ont invent√©es.</p>
<p>La <a href="https://www.shadertoy.com/howto">documentation de Shadertoy en d√©finit plusieurs autres</a>. Pour l'instant, √©crivons quelque chose qui g√®re les deux utilis√©es dans le shader ci-dessus.</p>
<p>La premi√®re chose √† faire est de cr√©er un simple plan qui remplit le canevas. Si vous ne l'avez pas encore lu, nous l'avons fait dans <a href="backgrounds.html">l'article sur les arri√®re-plans</a>, alors prenons cet exemple mais retirons les cubes. C'est assez court, voici donc l'int√©gralit√© :</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function main() {
  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
  renderer.autoClearColor = false;

  const camera = new THREE.OrthographicCamera(
    -1, // left
     1, // right
     1, // top
    -1, // bottom
    -1, // near,
     1, // far
  );
  const scene = new THREE.Scene();
  const plane = new THREE.PlaneGeometry(2, 2);
  const material = new THREE.MeshBasicMaterial({
      color: 'red',
  });
  scene.add(new THREE.Mesh(plane, material));

  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render() {
    resizeRendererToDisplaySize(renderer);

    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}

main();
</pre>
<p>Comme <a href="backgrounds.html">expliqu√© dans l'article sur les arri√®re-plans</a>, une <a href="/docs/#api/en/cameras/OrthographicCamera"><code class="notranslate" translate="no">OrthographicCamera</code></a> avec ces param√®tres et un plan de 2 unit√©s remplira le canevas. Pour l'instant, tout ce que nous obtiendrons est un canevas rouge car notre plan utilise un <a href="/docs/#api/en/materials/MeshBasicMaterial"><code class="notranslate" translate="no">MeshBasicMaterial</code></a> rouge.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/shadertoy-prep.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/shadertoy-prep.html" target="_blank">cliquer ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Maintenant que nous avons quelque chose qui fonctionne, ajoutons le shader shadertoy. </p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const fragmentShader = `
#include &lt;common&gt;

uniform vec3 iResolution;
uniform float iTime;

// Par iq: https://www.shadertoy.com/user/iq
// licence: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Coordonn√©es normalis√©es des pixels (de 0 √† 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Couleur variable des pixels avec le temps
    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Sortie √† l'√©cran
    fragColor = vec4(col,1.0);
}

void main() {
  mainImage(gl_FragColor, gl_FragCoord.xy);
}
`;
</pre>
<p>Ci-dessus, nous avons d√©clar√© les 2 variables uniformes dont nous avons parl√©. Ensuite, nous avons ins√©r√© le code GLSL du shader de shadertoy. Enfin, nous avons appel√© <code class="notranslate" translate="no">mainImage</code> en lui passant <code class="notranslate" translate="no">gl_FragColor</code> et <code class="notranslate" translate="no">gl_FragCoord.xy</code>. <code class="notranslate" translate="no">gl_FragColor</code> est une variable globale WebGL officielle que le shader est responsable de d√©finir √† la couleur qu'il souhaite pour le pixel actuel. <code class="notranslate" translate="no">gl_FragCoord</code> est une autre variable globale WebGL officielle qui nous indique la coordonn√©e du pixel pour lequel nous choisissons actuellement une couleur.</p>
<p>Nous devons ensuite configurer les uniformes de three.js afin de pouvoir fournir des valeurs au shader.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const uniforms = {
  iTime: { value: 0 },
  iResolution:  { value: new THREE.Vector3() },
};
</pre>
<p>Chaque uniforme dans THREE.js a un param√®tre <code class="notranslate" translate="no">value</code>. Cette valeur doit correspondre au type de l'uniforme.</p>
<p>Ensuite, nous passons le fragment shader et les uniformes √† un <a href="/docs/#api/en/materials/ShaderMaterial"><code class="notranslate" translate="no">ShaderMaterial</code></a>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const material = new THREE.MeshBasicMaterial({
-    color: 'red',
-});
+const material = new THREE.ShaderMaterial({
+  fragmentShader,
+  uniforms,
+});
</pre>
<p>et avant de rendre, nous devons d√©finir les valeurs des uniformes</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-function render() {
+function render(time) {
+  time *= 0.001;  // convertir en secondes

  resizeRendererToDisplaySize(renderer);

+  const canvas = renderer.domElement;
+  uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
+  uniforms.iTime.value = time;

  renderer.render(scene, camera);

  requestAnimationFrame(render);
}
</pre>
<blockquote>
<p>Note : Je n'ai aucune id√©e pourquoi <code class="notranslate" translate="no">iResolution</code> est un <code class="notranslate" translate="no">vec3</code> et ce que contient la 3√®me valeur <a href="https://www.shadertoy.com/howto">n'est pas document√© sur shadertoy.com</a>. Elle n'est pas utilis√©e ci-dessus, donc je la d√©finis juste √† 1 pour l'instant. ¬Ø\_(„ÉÑ)_/¬Ø</p>
</blockquote>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/shadertoy-basic.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/shadertoy-basic.html" target="_blank">cliquer ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Cela <a href="https://www.shadertoy.com/new">correspond √† ce que nous voyons sur Shadertoy pour un nouveau shader</a>, du moins en janvier 2019 üòâ. Que fait le shader ci-dessus ? </p>
<ul>
<li><code class="notranslate" translate="no">uv</code> va de 0 √† 1. </li>
<li><code class="notranslate" translate="no">cos(uv.xyx)</code> nous donne 3 valeurs de cosinus sous forme de <code class="notranslate" translate="no">vec3</code>. Une pour <code class="notranslate" translate="no">uv.x</code>, une autre pour <code class="notranslate" translate="no">uv.y</code> et une autre pour <code class="notranslate" translate="no">uv.x</code> √† nouveau.</li>
<li>L'ajout du temps, <code class="notranslate" translate="no">cos(iTime+uv.xyx)</code>, les rend anim√©s.</li>
<li>L'ajout de <code class="notranslate" translate="no">vec3(0,2,4)</code> comme dans <code class="notranslate" translate="no">cos(iTime+uv.xyx+vec3(0,2,4))</code> d√©cale les ondes cosinuso√Ødales</li>
<li><code class="notranslate" translate="no">cos</code> va de -1 √† 1, donc <code class="notranslate" translate="no">0.5 * 0.5 + cos(...)</code> convertit de -1 &lt;-&gt; 1 √† 0.0 &lt;-&gt; 1.0</li>
<li>les r√©sultats sont ensuite utilis√©s comme couleur RVB pour le pixel actuel</li>
</ul>
<p>Un petit changement facilitera la visualisation des ondes cosinuso√Ødales. Actuellement, <code class="notranslate" translate="no">uv</code> ne va que de 0 √† 1. Un cosinus se r√©p√®te √† 2œÄ, alors faisons-le aller de 0 √† 40 en multipliant par 40.0. Cela devrait le faire se r√©p√©ter environ 6,3 fois.</p>
<pre class="prettyprint showlinemods notranslate lang-glsl" translate="no">-vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));
+vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx*40.0+vec3(0,2,4));
</pre>
<p>En comptant ci-dessous, je vois environ 6,3 r√©p√©titions. Nous pouvons voir le bleu entre le rouge car il est d√©cal√© de 4 via le <code class="notranslate" translate="no">+vec3(0,2,4)</code>. Sans cela, le bleu et le rouge se chevaucheraient parfaitement, cr√©ant du violet.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/shadertoy-basic-x40.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/shadertoy-basic-x40.html" target="_blank">cliquer ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Savoir √† quel point les entr√©es sont simples et ensuite voir des r√©sultats comme <a href="https://www.shadertoy.com/view/MdXGW2">un canal urbain</a>, <a href="https://www.shadertoy.com/view/4ttSWf">une for√™t</a>, <a href="https://www.shadertoy.com/view/ld3Gz2">un escargot</a>, <a href="https://www.shadertoy.com/view/4tBXR1">un champignon</a> rend le d√©fi d'autant plus impressionnant. Esp√©rons qu'ils expliquent √©galement clairement pourquoi ce n'est g√©n√©ralement pas la bonne approche par rapport aux m√©thodes plus traditionnelles de cr√©ation de sc√®nes √† partir de triangles. Le fait qu'il faille faire autant de calculs pour d√©terminer la couleur de chaque pixel signifie que ces exemples tournent tr√®s lentement.</p>
<p>Certains shaders shadertoy prennent des textures en entr√©e, comme <a href="https://www.shadertoy.com/view/MsXSzM">celui-ci</a>. </p>
<pre class="prettyprint showlinemods notranslate lang-glsl" translate="no">// Par Daedelus: https://www.shadertoy.com/user/Daedelus
// licence: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
#define TIMESCALE 0.25
#define TILES 8
#define COLOR 0.7, 1.6, 2.8

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord.xy / iResolution.xy;
    uv.x *= iResolution.x / iResolution.y;

    vec4 noise = texture2D(iChannel0, floor(uv * float(TILES)) / float(TILES));
    float p = 1.0 - mod(noise.r + noise.g + noise.b + iTime * float(TIMESCALE), 1.0);
    p = min(max(p * 3.0 - 1.8, 0.1), 2.0);

    vec2 r = mod(uv * float(TILES), 1.0);
    r = vec2(pow(r.x - 0.5, 2.0), pow(r.y - 0.5, 2.0));
    p *= 1.0 - pow(min(1.0, 12.0 * dot(r, r)), 2.0);

    fragColor = vec4(COLOR, 1.0) * p;
}
</pre>
<p>Passer une texture √† un shader est similaire √† <a href="textures.html">en passer une √† un mat√©riau normal</a>, mais nous devons configurer la texture sur les uniformes.</p>
<p>Tout d'abord, ajoutons l'uniforme pour la texture au shader. Ils sont appel√©s <code class="notranslate" translate="no">sampler2D</code> en GLSL.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const fragmentShader = `
#include &lt;common&gt;

uniform vec3 iResolution;
uniform float iTime;
+uniform sampler2D iChannel0;

...
</pre>
<p>Ensuite, nous pouvons charger une texture comme nous l'avons vu <a href="textures.html">ici</a> et affecter la valeur de l'uniforme.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const loader = new THREE.TextureLoader();
+const texture = loader.load('resources/images/bayer.png');
+texture.minFilter = THREE.NearestFilter;
+texture.magFilter = THREE.NearestFilter;
+texture.wrapS = THREE.RepeatWrapping;
+texture.wrapT = THREE.RepeatWrapping;
const uniforms = {
  iTime: { value: 0 },
  iResolution:  { value: new THREE.Vector3() },
+  iChannel0: { value: texture },
};
</pre>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/shadertoy-bleepy-blocks.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/shadertoy-bleepy-blocks.html" target="_blank">cliquer ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Jusqu'√† pr√©sent, nous avons utilis√© les shaders Shadertoy tels qu'ils sont utilis√©s sur <a href="https://shadertoy.com">Shadertoy.com</a>, √† savoir pour couvrir le canevas. Il n'y a cependant aucune raison de nous limiter √† ce cas d'utilisation. L'important √† retenir est que les fonctions que les gens √©crivent sur shadertoy prennent g√©n√©ralement juste une entr√©e <code class="notranslate" translate="no">fragCoord</code> et une <code class="notranslate" translate="no">iResolution</code>. <code class="notranslate" translate="no">fragCoord</code> n'a pas √† provenir des coordonn√©es de pixels ; nous pourrions utiliser autre chose, comme des coordonn√©es de texture, et les utiliser ensuite un peu comme d'autres textures. Cette technique d'utilisation d'une fonction pour g√©n√©rer des textures est souvent appel√©e une <a href="https://www.google.com/search?q=procedural+texture"><em>texture proc√©durale</em></a>.</p>
<p>Modifions le shader ci-dessus pour faire cela. La chose la plus simple √† faire pourrait √™tre de prendre les coordonn√©es de texture que three.js fournit normalement, de les multiplier par <code class="notranslate" translate="no">iResolution</code> et de les passer pour <code class="notranslate" translate="no">fragCoords</code>.</p>
<p>Pour ce faire, nous ajoutons un <em>varying</em>. Un varying est une valeur pass√©e du vertex shader au fragment shader qui est interpol√©e (ou varie) entre les sommets. Pour l'utiliser dans notre fragment shader, nous la d√©clarons. Three.js fait r√©f√©rence √† ses coordonn√©es de texture comme <code class="notranslate" translate="no">uv</code> avec le <code class="notranslate" translate="no">v</code> devant signifiant <em>varying</em> (variable).</p>
<pre class="prettyprint showlinemods notranslate lang-glsl" translate="no">...

+varying vec2 vUv;

void main() {
-  mainImage(gl_FragColor, gl_FragCoord.xy);
+  mainImage(gl_FragColor, vUv * iResolution.xy);
}
</pre>
<p>Ensuite, nous devons √©galement fournir notre propre vertex shader. Voici un vertex shader three.js minimal assez courant. Three.js d√©clare et fournira des valeurs pour <code class="notranslate" translate="no">uv</code>, <code class="notranslate" translate="no">projectionMatrix</code>, <code class="notranslate" translate="no">modelViewMatrix</code> et <code class="notranslate" translate="no">position</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  }
`;
</pre>
<p>Nous devons passer le vertex shader au <a href="/docs/#api/en/materials/ShaderMaterial"><code class="notranslate" translate="no">ShaderMaterial</code></a></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const material = new THREE.ShaderMaterial({
  vertexShader,
  fragmentShader,
  uniforms,
});
</pre>
<p>Nous pouvons d√©finir la valeur de l'uniforme <code class="notranslate" translate="no">iResolution</code> au moment de l'initialisation car elle ne changera plus.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const uniforms = {
  iTime: { value: 0 },
-  iResolution:  { value: new THREE.Vector3() },
+  iResolution:  { value: new THREE.Vector3(1, 1, 1) },
  iChannel0: { value: texture },
};
</pre>
<p>et nous n'avons plus besoin de la d√©finir au moment du rendu</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const canvas = renderer.domElement;
-uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
uniforms.iTime.value = time;
</pre>
<p>Sinon, j'ai copi√© √† nouveau la cam√©ra originale et le code qui configure 3 cubes en rotation de <a href="responsive.html">l'article sur la r√©activit√©</a>. Le r√©sultat :</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/shadertoy-as-texture.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/shadertoy-as-texture.html" target="_blank">cliquer ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>J'esp√®re que cela vous donnera au moins une base sur la fa√ßon d'utiliser un shader shadertoy avec three.js. Encore une fois, il est important de se rappeler que la plupart des shaders shadertoy sont un d√©fi int√©ressant (tout dessiner avec une seule fonction) plut√¥t que la m√©thode recommand√©e pour r√©ellement afficher des choses de mani√®re performante. N√©anmoins, ils sont incroyables, impressionnants, beaux, et vous pouvez apprendre √©norm√©ment en voyant comment ils fonctionnent.</p>

        </div>
      </div>
    </div>

  <script src="../resources/prettify.js"></script>
  <script src="../resources/lesson.js"></script>




</body></html>