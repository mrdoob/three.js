<!DOCTYPE html><html lang="fr"><head>
    <meta charset="utf-8">
    <title>Chargement d'un fichier .GLTF</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@threejs">
    <meta name="twitter:title" content="Three.js ‚Äì Chargement d'un fichier .GLTF">
    <meta property="og:image" content="https://threejs.org/files/share.png">
    <link rel="shortcut icon" href="../../files/favicon_white.ico" media="(prefers-color-scheme: dark)">
    <link rel="shortcut icon" href="../../files/favicon.ico" media="(prefers-color-scheme: light)">

    <link rel="stylesheet" href="../resources/lesson.css">
    <link rel="stylesheet" href="../resources/lang.css">
<script type="importmap">
{
  "imports": {
    "three": "../../build/three.module.js"
  }
}
</script>
  </head>
  <body>
    <div class="container">
      <div class="lesson-title">
        <h1>Chargement d'un fichier .GLTF</h1>
      </div>
      <div class="lesson">
        <div class="lesson-main">
          <p>Dans une le√ßon pr√©c√©dente, nous avons <a href="load-obj.html">charg√© un fichier .OBJ</a>. Si vous ne l'avez pas lue, vous pourriez vouloir la consulter d'abord.</p>
<p>Comme indiqu√© l√†-bas, le format de fichier .OBJ est tr√®s ancien et assez simple. Il ne fournit aucun graphe de sc√®ne, donc tout ce qui est charg√© est un seul grand maillage. Il a √©t√© con√ßu principalement comme un moyen simple de passer des donn√©es entre des √©diteurs 3D.</p>
<p><a href="https://github.com/KhronosGroup/glTF">Le format gLTF</a> est en r√©alit√© un format con√ßu d√®s le d√©part pour √™tre utilis√© pour afficher des graphiques. Les formats 3D peuvent √™tre divis√©s en 3 ou 4 types de base.</p>
<ul>
<li><p>Formats d'√©diteurs 3D</p>
<p>Ce sont des formats sp√©cifiques √† une seule application. .blend (Blender), .max (3d Studio Max), .mb et .ma (Maya), etc...</p>
</li>
<li><p>Formats d'√©change</p>
<p>Ce sont des formats comme .OBJ, .DAE (Collada), .FBX. Ils sont con√ßus pour aider √† √©changer des informations entre les √©diteurs 3D. En tant que tels, ils sont g√©n√©ralement beaucoup plus volumineux que n√©cessaire avec des informations suppl√©mentaires utilis√©es uniquement √† l'int√©rieur des √©diteurs 3D.</p>
</li>
<li><p>Formats d'application</p>
<p>Ceux-ci sont g√©n√©ralement sp√©cifiques √† certaines applications, g√©n√©ralement des jeux.</p>
</li>
<li><p>Formats de transmission</p>
<p>gLTF pourrait √™tre le premier v√©ritable format de transmission. Je suppose que VRML pourrait √™tre consid√©r√© comme tel, mais VRML √©tait en r√©alit√© un tr√®s mauvais format.</p>
<p>gLTF est con√ßu pour bien faire certaines choses que tous ces autres formats ne font pas</p>
<ol>
<li><p>√ätre petit pour la transmission</p>
<p>Par exemple, cela signifie qu'une grande partie de leurs donn√©es volumineuses, comme les sommets, est stock√©e en binaire. Lorsque vous t√©l√©chargez un fichier .gLTF, ces donn√©es peuvent √™tre t√©l√©charg√©es sur le GPU sans aucun traitement. Elles sont pr√™tes telles quelles. C'est en contraste avec, par exemple, VRML, .OBJ ou .DAE o√π les sommets sont stock√©s sous forme de texte et doivent √™tre analys√©s. Les positions de sommets en texte peuvent facilement √™tre 3 √† 5 fois plus volumineuses qu'en binaire.</p>
</li>
<li><p>√ätre pr√™t √† √™tre rendu</p>
<p>C'est encore diff√©rent des autres formats, sauf peut-√™tre les formats d'application. Les donn√©es d'un fichier glTF sont destin√©es √† √™tre rendues, pas √©dit√©es. Les donn√©es qui ne sont pas importantes pour le rendu ont g√©n√©ralement √©t√© supprim√©es. Les polygones ont √©t√© convertis en triangles. Les mat√©riaux ont des valeurs connues qui sont cens√©es fonctionner partout.</p>
</li>
</ol>
</li>
</ul>
<p>gLTF a √©t√© sp√©cifiquement con√ßu pour que vous puissiez t√©l√©charger un fichier glTF et l'afficher avec un minimum de probl√®mes. Croisons les doigts pour que ce soit vraiment le cas, car aucun autre format n'a √©t√© capable de faire cela.</p>
<p>Je n'√©tais pas vraiment s√ªr de ce que je devais montrer. √Ä un certain niveau, le chargement et l'affichage d'un fichier gLTF sont plus simples qu'un fichier .OBJ. Contrairement √† un fichier .OBJ, les mat√©riaux font directement partie du format. Cela dit, j'ai pens√© que je devais au moins en charger un et je pense qu'examiner les probl√®mes que j'ai rencontr√©s pourrait fournir de bonnes informations.</p>
<p>En cherchant sur le net, j'ai trouv√© <a href="https://sketchfab.com/models/edd1c604e1e045a0a2a552ddd9a293e6">cette ville low-poly</a> par <a href="https://sketchfab.com/antonmoek">antonmoek</a> qui semblait, si nous avons de la chance, faire un bon exemple.</p>
<div class="threejs_center"><img src="../resources/images/cartoon_lowpoly_small_city_free_pack.jpg"></div>

<p>En partant d'<a href="load-obj.html">un exemple de l'article sur les fichiers .OBJ</a>, j'ai supprim√© le code de chargement de .OBJ et je l'ai remplac√© par le code de chargement de .GLTF.</p>
<p>L'ancien code .OBJ √©tait</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const mtlLoader = new MTLLoader();
mtlLoader.loadMtl('resources/models/windmill/windmill-fixed.mtl', (mtl) =&gt; {
  mtl.preload();
  mtl.materials.Material.side = THREE.DoubleSide;
  objLoader.setMaterials(mtl);
  objLoader.load('resources/models/windmill/windmill.obj', (event) =&gt; {
    const root = event.detail.loaderRootNode;
    scene.add(root);
    ...
  });
});
</pre>
<p>Le nouveau code .GLTF est</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">{
  const gltfLoader = new GLTFLoader();
  const url = 'resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf';
  gltfLoader.load(url, (gltf) =&gt; {
    const root = gltf.scene;
    scene.add(root);
    ...
  });
</pre>
<p>J'ai gard√© le code de cadrage automatique comme auparavant.</p>
<p>Nous devons √©galement inclure le <a href="/docs/#examples/loaders/GLTFLoader"><code class="notranslate" translate="no">GLTFLoader</code></a> et nous pouvons nous d√©barrasser du <a href="/docs/#examples/loaders/OBJLoader"><code class="notranslate" translate="no">OBJLoader</code></a>.</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">-import {LoaderSupport} from 'three/addons/loaders/LoaderSupport.js';
-import {OBJLoader} from 'three/addons/loaders/OBJLoader.js';
-import {MTLLoader} from 'three/addons/loaders/MTLLoader.js';
+import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
</pre>
<p>Et en ex√©cutant cela, nous obtenons</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/load-gltf.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/load-gltf.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Magie ! √áa fonctionne tout seul, textures comprises.</p>
<p>Ensuite, je voulais voir si je pouvais animer les voitures qui circulent, j'ai donc eu besoin de v√©rifier si la sc√®ne avait les voitures comme entit√©s s√©par√©es et si elles √©taient configur√©es d'une mani√®re que je pouvais utiliser.</p>
<p>J'ai √©crit du code pour afficher le graphe de sc√®ne dans la <a href="debugging-javascript.html">console JavaScript</a>.</p>
<p>Voici le code pour imprimer le graphe de sc√®ne.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function dumpObject(obj, lines = [], isLast = true, prefix = '') {
  const localPrefix = isLast ? '‚îî‚îÄ' : '‚îú‚îÄ';
  lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
  const newPrefix = prefix + (isLast ? '  ' : '‚îÇ ');
  const lastNdx = obj.children.length - 1;
  obj.children.forEach((child, ndx) =&gt; {
    const isLast = ndx === lastNdx;
    dumpObject(child, lines, isLast, newPrefix);
  });
  return lines;
}
</pre>
<p>Et je l'ai appel√©e juste apr√®s avoir charg√© la sc√®ne.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const gltfLoader = new GLTFLoader();
gltfLoader.load('resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf', (gltf) =&gt; {
  const root = gltf.scene;
  scene.add(root);
  console.log(dumpObject(root).join('\n'));
</pre>
<p><a href="../examples/load-gltf-dump-scenegraph.html">En ex√©cutant cela</a>, j'ai obtenu cette liste</p>
<pre class="prettyprint showlinemods notranslate lang-text" translate="no">OSG_Scene [Scene]
  ‚îî‚îÄRootNode_(gltf_orientation_matrix) [Object3D]
    ‚îî‚îÄRootNode_(model_correction_matrix) [Object3D]
      ‚îî‚îÄ4d4100bcb1c640e69699a87140df79d7fbx [Object3D]
        ‚îî‚îÄRootNode [Object3D]
          ‚îÇ ...
          ‚îú‚îÄCars [Object3D]
          ‚îÇ ‚îú‚îÄCAR_03_1 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCAR_03_1_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCAR_03 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCAR_03_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCar_04 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCar_04_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCAR_03_2 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCAR_03_2_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCar_04_1 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCar_04_1_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCar_04_2 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCar_04_2_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCar_04_3 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCar_04_3_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCar_04_4 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCar_04_4_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCar_08_4 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCar_08_4_World_ap8_0 [Mesh]
          ‚îÇ ‚îú‚îÄCar_08_3 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCar_08_3_World_ap9_0 [Mesh]
          ‚îÇ ‚îú‚îÄCar_04_1_2 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCar_04_1_2_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCar_08_2 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCar_08_2_World_ap11_0 [Mesh]
          ‚îÇ ‚îú‚îÄCAR_03_1_2 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCAR_03_1_2_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCAR_03_2_2 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCAR_03_2_2_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCar_04_2_2 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCar_04_2_2_World_ap_0 [Mesh]
          ...
</pre>
<p>√Ä partir de cela, nous pouvons voir que toutes les voitures se trouvent sous un parent appel√© <code class="notranslate" translate="no">"Cars"</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-text" translate="no">*          ‚îú‚îÄCars [Object3D]
          ‚îÇ ‚îú‚îÄCAR_03_1 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCAR_03_1_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCAR_03 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCAR_03_World_ap_0 [Mesh]
          ‚îÇ ‚îú‚îÄCar_04 [Object3D]
          ‚îÇ ‚îÇ ‚îî‚îÄCar_04_World_ap_0 [Mesh]
</pre>
<p>Donc, comme test simple, j'ai pens√© que j'essaierais juste de faire tourner tous les enfants du n≈ìud "Cars" autour de leur axe Y.</p>
<p>J'ai cherch√© le n≈ìud "Cars" apr√®s avoir charg√© la sc√®ne et j'ai sauvegard√© le r√©sultat.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+let cars;
{
  const gltfLoader = new GLTFLoader();
  gltfLoader.load('resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf', (gltf) =&gt; {
    const root = gltf.scene;
    scene.add(root);
+    cars = root.getObjectByName('Cars');
</pre>
<p>Ensuite, dans la fonction <code class="notranslate" translate="no">render</code>, nous pouvons simplement d√©finir la rotation de chaque enfant de <code class="notranslate" translate="no">cars</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+function render(time) {
+  time *= 0.001;  // convertir en secondes

  if (resizeRendererToDisplaySize(renderer)) {
    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }

+  if (cars) {
+    for (const car of cars.children) {
+      car.rotation.y = time;
+    }
+  }

  renderer.render(scene, camera);

  requestAnimationFrame(render);
}
</pre>
<p>Et nous obtenons</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/load-gltf-rotate-cars.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/load-gltf-rotate-cars.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Hmmm, il semble que malheureusement cette sc√®ne n'a pas √©t√© con√ßue pour animer les voitures, car leurs origines ne sont pas configur√©es √† cette fin. Les camions tournent dans la mauvaise direction.</p>
<p>Cela soul√®ve un point important : si vous allez faire quelque chose en 3D, vous devez planifier √† l'avance et concevoir vos √©l√©ments de mani√®re √† ce que leurs origines soient aux bons endroits, qu'ils aient la bonne √©chelle, etc.</p>
<p>Comme je ne suis pas un artiste et que je ne connais pas tr√®s bien Blender, je vais bricoler cet exemple. Nous allons prendre chaque voiture et la faire appartenir √† un autre <a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a>. Nous allons ensuite d√©placer ces objets <a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a> pour d√©placer les voitures, mais s√©par√©ment, nous pouvons d√©finir l'<a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a> d'origine de la voiture pour la r√©orienter afin qu'elle soit √† peu pr√®s l√† o√π nous en avons vraiment besoin.</p>
<p>En regardant √† nouveau la liste du graphe de sc√®ne, il semble qu'il n'y ait en r√©alit√© que 3 types de voitures : "Car_08", "CAR_03" et "Car_04". Esp√©rons que chaque type de voiture fonctionnera avec les m√™mes ajustements.</p>
<p>J'ai √©crit ce code pour passer en revue chaque voiture, la faire appartenir √† un nouvel <a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a>, faire appartenir ce nouvel <a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a> √† la sc√®ne, appliquer des param√®tres par *type* de voiture pour corriger son orientation, et ajouter le nouvel <a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a> √† un tableau <code class="notranslate" translate="no">cars</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-let cars;
+const cars = [];
{
  const gltfLoader = new GLTFLoader();
  gltfLoader.load('resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf', (gltf) =&gt; {
    const root = gltf.scene;
    scene.add(root);

-    cars = root.getObjectByName('Cars');
+    const loadedCars = root.getObjectByName('Cars');
+    const fixes = [
+      { prefix: 'Car_08', rot: [Math.PI * .5, 0, Math.PI * .5], },
+      { prefix: 'CAR_03', rot: [0, Math.PI, 0], },
+      { prefix: 'Car_04', rot: [0, Math.PI, 0], },
+    ];
+
+    root.updateMatrixWorld();
+    for (const car of loadedCars.children.slice()) {
+      const fix = fixes.find(fix =&gt; car.name.startsWith(fix.prefix));
+      const obj = new THREE.Object3D();
+      car.getWorldPosition(obj.position);
+      car.position.set(0, 0, 0);
+      car.rotation.set(...fix.rot);
+      obj.add(car);
+      scene.add(obj);
+      cars.push(obj);
+    }
     ...
</pre>
<p>Cela corrige l'orientation des voitures.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/load-gltf-rotate-cars-fixed.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/load-gltf-rotate-cars-fixed.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Maintenant, faisons-les rouler.</p>
<p>Faire m√™me un simple syst√®me de conduite est trop pour ce post, mais il semble qu'au lieu de cela, nous pourrions simplement cr√©er un chemin alambiqu√© qui parcourt toutes les routes, puis placer les voitures sur ce chemin. Voici une image de Blender √† mi-chemin de la construction du chemin.</p>
<div class="threejs_center"><img src="../resources/images/making-path-for-cars.jpg" style="width: 1094px"></div>

<p>J'avais besoin d'un moyen d'obtenir les donn√©es de ce chemin depuis Blender. Heureusement, j'ai pu s√©lectionner juste mon chemin et exporter en .OBJ en cochant "write nurbs".</p>
<div class="threejs_center"><img src="../resources/images/blender-export-obj-write-nurbs.jpg" style="width: 498px"></div>

<p>En ouvrant le fichier .OBJ, j'ai pu obtenir une liste de points que j'ai format√©e ainsi</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const controlPoints = [
  [1.118281, 5.115846, -3.681386],
  [3.948875, 5.115846, -3.641834],
  [3.960072, 5.115846, -0.240352],
  [3.985447, 5.115846, 4.585005],
  [-3.793631, 5.115846, 4.585006],
  [-3.826839, 5.115846, -14.736200],
  [-14.542292, 5.115846, -14.765865],
  [-14.520929, 5.115846, -3.627002],
  [-5.452815, 5.115846, -3.634418],
  [-5.467251, 5.115846, 4.549161],
  [-13.266233, 5.115846, 4.567083],
  [-13.250067, 5.115846, -13.499271],
  [4.081842, 5.115846, -13.435463],
  [4.125436, 5.115846, -5.334928],
  [-14.521364, 5.115846, -5.239871],
  [-14.510466, 5.115846, 5.486727],
  [5.745666, 5.115846, 5.510492],
  [5.787942, 5.115846, -14.728308],
  [-5.423720, 5.115846, -14.761919],
  [-5.373599, 5.115846, -3.704133],
  [1.004861, 5.115846, -3.641834],
];
</pre>
<p>THREE.js poss√®de des classes de courbes. La <a href="/docs/#api/en/extras/curves/CatmullRomCurve3"><code class="notranslate" translate="no">CatmullRomCurve3</code></a> semblait pouvoir fonctionner. L'int√©r√™t de ce type de courbe est qu'elle essaie de cr√©er une courbe lisse passant par les points.</p>
<p>En fait, l'insertion directe de ces points g√©n√©rera une courbe comme celle-ci</p>
<div class="threejs_center"><img src="../resources/images/car-curves-before.png" style="width: 400px"></div>

<p>mais nous voulons des coins plus marqu√©s. Il semblait que si nous calculions des points suppl√©mentaires, nous pourrions obtenir ce que nous voulons. Pour chaque paire de points, nous allons calculer un point √† 10 % du chemin entre les 2 points et un autre √† 90 % du chemin entre les 2 points, et passer le r√©sultat √† <a href="/docs/#api/en/extras/curves/CatmullRomCurve3"><code class="notranslate" translate="no">CatmullRomCurve3</code></a>.</p>
<p>Cela nous donnera une courbe comme celle-ci</p>
<div class="threejs_center"><img src="../resources/images/car-curves-after.png" style="width: 400px"></div>

<p>Voici le code pour cr√©er la courbe</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">let curve;
let curveObject;
{
  const controlPoints = [
    [1.118281, 5.115846, -3.681386],
    [3.948875, 5.115846, -3.641834],
    [3.960072, 5.115846, -0.240352],
    [3.985447, 5.115846, 4.585005],
    [-3.793631, 5.115846, 4.585006],
    [-3.826839, 5.115846, -14.736200],
    [-14.542292, 5.115846, -14.765865],
    [-14.520929, 5.115846, -3.627002],
    [-5.452815, 5.115846, -3.634418],
    [-5.467251, 5.115846, 4.549161],
    [-13.266233, 5.115846, 4.567083],
    [-13.250067, 5.115846, -13.499271],
    [4.081842, 5.115846, -13.435463],
    [4.125436, 5.115846, -5.334928],
    [-14.521364, 5.115846, -5.239871],
    [-14.510466, 5.115846, 5.486727],
    [5.745666, 5.115846, 5.510492],
    [5.787942, 5.115846, -14.728308],
    [-5.423720, 5.115846, -14.761919],
    [-5.373599, 5.115846, -3.704133],
    [1.004861, 5.115846, -3.641834],
  ];
  const p0 = new THREE.Vector3();
  const p1 = new THREE.Vector3();
  curve = new THREE.CatmullRomCurve3(
    controlPoints.map((p, ndx) =&gt; {
      p0.set(...p);
      p1.set(...controlPoints[(ndx + 1) % controlPoints.length]);
      return [
        (new THREE.Vector3()).copy(p0),
        (new THREE.Vector3()).lerpVectors(p0, p1, 0.1),
        (new THREE.Vector3()).lerpVectors(p0, p1, 0.9),
      ];
    }).flat(),
    true,
  );
  {
    const points = curve.getPoints(250);
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const material = new THREE.LineBasicMaterial({color: 0xff0000});
    curveObject = new THREE.Line(geometry, material);
    scene.add(curveObject);
  }
}
</pre>
<p>La premi√®re partie de ce code cr√©e une courbe. La deuxi√®me partie de ce code g√©n√®re 250 points √† partir de la courbe, puis cr√©e un objet pour afficher les lignes form√©es en connectant ces 250 points.</p>
<p>En ex√©cutant <a href="../examples/load-gltf-car-path.html">l'exemple</a>, je n'ai pas vu la courbe. Pour la rendre visible, je l'ai fait ignorer le test de profondeur et la rendre en dernier.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">    curveObject = new THREE.Line(geometry, material);
+    material.depthTest = false;
+    curveObject.renderOrder = 1;
</pre>
<p>Et c'est l√† que j'ai d√©couvert qu'elle √©tait beaucoup trop petite.</p>
<div class="threejs_center"><img src="../resources/images/car-curves-too-small.png" style="width: 498px"></div>

<p>En v√©rifiant la hi√©rarchie dans Blender, j'ai d√©couvert que l'artiste avait mis √† l'√©chelle le n≈ìud parent de toutes les voitures.</p>
<div class="threejs_center"><img src="../resources/images/cars-scale-0.01.png" style="width: 342px;"></div>

<p>La mise √† l'√©chelle est mauvaise pour les applications 3D en temps r√©el. Elle cause toutes sortes de probl√®mes et finit par √™tre une source de frustration infinie lors de la cr√©ation d'applications 3D en temps r√©el. Les artistes ne le savent souvent pas car il est si facile de mettre √† l'√©chelle une sc√®ne enti√®re dans un programme d'√©dition 3D, mais si vous d√©cidez de cr√©er une application 3D en temps r√©el, je vous sugg√®re de demander √† vos artistes de ne jamais rien mettre √† l'√©chelle. S'ils modifient l'√©chelle, ils devraient trouver un moyen d'appliquer cette √©chelle aux sommets afin que, lorsqu'elle arrive dans votre application, vous puissiez ignorer l'√©chelle.</p>
<p>Et, pas seulement l'√©chelle, dans ce cas, les voitures sont tourn√©es et d√©cal√©es par leur parent, le n≈ìud <code class="notranslate" translate="no">Cars</code>. Cela rendra difficile au moment de l'ex√©cution de d√©placer les voitures dans l'espace mondial. Pour √™tre clair, dans ce cas, nous voulons que les voitures circulent dans l'espace mondial, c'est pourquoi ces probl√®mes se posent. Si quelque chose est destin√© √† √™tre manipul√© dans un espace local, comme la lune tournant autour de la terre, c'est moins probl√©matique.</p>
<p>Pour en revenir √† la fonction que nous avons √©crite ci-dessus pour afficher le graphe de sc√®ne, affichons la position, la rotation et l'√©chelle de chaque n≈ìud.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+function dumpVec3(v3, precision = 3) {
+  return `${v3.x.toFixed(precision)}, ${v3.y.toFixed(precision)}, ${v3.z.toFixed(precision)}`;
+}

function dumpObject(obj, lines, isLast = true, prefix = '') {
  const localPrefix = isLast ? '‚îî‚îÄ' : '‚îú‚îÄ';
  lines.push(`${prefix}${prefix ? localPrefix : ''}${obj.name || '*no-name*'} [${obj.type}]`);
+  const dataPrefix = obj.children.length
+     ? (isLast ? '  ‚îÇ ' : '‚îÇ ‚îÇ ')
+     : (isLast ? '    ' : '‚îÇ   ');
+  lines.push(`${prefix}${dataPrefix}  pos: ${dumpVec3(obj.position)}`);
+  lines.push(`${prefix}${dataPrefix}  rot: ${dumpVec3(obj.rotation)}`);
+  lines.push(`${prefix}${dataPrefix}  scl: ${dumpVec3(obj.scale)}`);
  const newPrefix = prefix + (isLast ? '  ' : '‚îÇ ');
  const lastNdx = obj.children.length - 1;
  obj.children.forEach((child, ndx) =&gt; {
    const isLast = ndx === lastNdx;
    dumpObject(child, lines, isLast, newPrefix);
  });
  return lines;
}
</pre>
<p>Et le r√©sultat de <a href="../examples/load-gltf-dump-scenegraph-extra.html">l'ex√©cution</a></p>
<pre class="prettyprint showlinemods notranslate lang-text" translate="no">OSG_Scene [Scene]
  ‚îÇ   pos: 0.000, 0.000, 0.000
  ‚îÇ   rot: 0.000, 0.000, 0.000
  ‚îÇ   scl: 1.000, 1.000, 1.000
  ‚îî‚îÄRootNode_(gltf_orientation_matrix) [Object3D]
    ‚îÇ   pos: 0.000, 0.000, 0.000
    ‚îÇ   rot: -1.571, 0.000, 0.000
    ‚îÇ   scl: 1.000, 1.000, 1.000
    ‚îî‚îÄRootNode_(model_correction_matrix) [Object3D]
      ‚îÇ   pos: 0.000, 0.000, 0.000
      ‚îÇ   rot: 0.000, 0.000, 0.000
      ‚îÇ   scl: 1.000, 1.000, 1.000
      ‚îî‚îÄ4d4100bcb1c640e69699a87140df79d7fbx [Object3D]
        ‚îÇ   pos: 0.000, 0.000, 0.000
        ‚îÇ   rot: 1.571, 0.000, 0.000
        ‚îÇ   scl: 1.000, 1.000, 1.000
        ‚îî‚îÄRootNode [Object3D]
          ‚îÇ   pos: 0.000, 0.000, 0.000
          ‚îÇ   rot: 0.000, 0.000, 0.000
          ‚îÇ   scl: 1.000, 1.000, 1.000
          ‚îú‚îÄCars [Object3D]
*          ‚îÇ ‚îÇ   pos: -369.069, -90.704, -920.159
*          ‚îÇ ‚îÇ   rot: 0.000, 0.000, 0.000
*          ‚îÇ ‚îÇ   scl: 1.000, 1.000, 1.000
          ‚îÇ ‚îú‚îÄCAR_03_1 [Object3D]
          ‚îÇ ‚îÇ ‚îÇ   pos: 22.131, 14.663, -475.071
          ‚îÇ ‚îÇ ‚îÇ   rot: -3.142, 0.732, 3.142
          ‚îÇ ‚îÇ ‚îÇ   scl: 1.500, 1.500, 1.500
          ‚îÇ ‚îÇ ‚îî‚îÄCAR_03_1_World_ap_0 [Mesh]
          ‚îÇ ‚îÇ       pos: 0.000, 0.000, 0.000
          ‚îÇ ‚îÇ       rot: 0.000, 0.000, 0.000
          ‚îÇ ‚îÇ       scl: 1.000, 1.000, 1.000
</pre>
<p>Cela nous montre que l'<code class="notranslate" translate="no">Cars</code> dans la sc√®ne originale a vu sa rotation et son √©chelle supprim√©es et appliqu√©es √† ses enfants. Cela sugg√®re que soit l'exportateur utilis√© pour cr√©er le fichier .GLTF a fait un travail sp√©cial ici, soit plus probablement l'artiste a export√© une version diff√©rente du fichier que le fichier .blend correspondant, ce qui explique pourquoi les choses ne correspondent pas.</p>
<p>La morale de l'histoire est que j'aurais probablement d√ª t√©l√©charger le fichier .blend et exporter moi-m√™me. Avant d'exporter, j'aurais d√ª inspecter tous les n≈ìuds principaux et supprimer toute transformation.</p>
<p>Tous ces n≈ìuds en haut</p>
<pre class="prettyprint showlinemods notranslate lang-text" translate="no">OSG_Scene [Scene]
  ‚îÇ   pos: 0.000, 0.000, 0.000
  ‚îÇ   rot: 0.000, 0.000, 0.000
  ‚îÇ   scl: 1.000, 1.000, 1.000
  ‚îî‚îÄRootNode_(gltf_orientation_matrix) [Object3D]
    ‚îÇ   pos: 0.000, 0.000, 0.000
    ‚îÇ   rot: -1.571, 0.000, 0.000
    ‚îÇ   scl: 1.000, 1.000, 1.000
    ‚îî‚îÄRootNode_(model_correction_matrix) [Object3D]
      ‚îÇ   pos: 0.000, 0.000, 0.000
      ‚îÇ   rot: 0.000, 0.000, 0.000
      ‚îÇ   scl: 1.000, 1.000, 1.000
      ‚îî‚îÄ4d4100bcb1c640e69699a87140df79d7fbx [Object3D]
        ‚îÇ   pos: 0.000, 0.000, 0.000
        ‚îÇ   rot: 1.571, 0.000, 0.000
        ‚îÇ   scl: 1.000, 1.000, 1.000
</pre>
<p>sont √©galement un gaspillage.</p>
<p>Id√©alement, la sc√®ne devrait se composer d'un seul n≈ìud "racine" sans position, rotation ou √©chelle. Au moment de l'ex√©cution, je pourrais alors retirer tous les enfants de cette racine et les faire appartenir √† la sc√®ne elle-m√™me. Il pourrait y avoir des enfants de la racine comme "Cars" qui m'aideraient √† trouver toutes les voitures, mais id√©alement, il n'aurait pas non plus de translation, rotation ou √©chelle afin que je puisse rattacher les voitures √† la sc√®ne avec un minimum de travail.</p>
<p>En tout cas, la solution la plus rapide, m√™me si ce n'est peut-√™tre pas la meilleure, est de simplement ajuster l'objet que nous utilisons pour visualiser la courbe.</p>
<p>Voici ce que j'ai obtenu au final.</p>
<p>D'abord, j'ai ajust√© la position de la courbe et trouv√© des valeurs qui semblaient fonctionner. Je l'ai ensuite cach√©e.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">{
  const points = curve.getPoints(250);
  const geometry = new THREE.BufferGeometry().setFromPoints(points);
  const material = new THREE.LineBasicMaterial({color: 0xff0000});
  curveObject = new THREE.Line(geometry, material);
+  curveObject.scale.set(100, 100, 100);
+  curveObject.position.y = -621;
+  curveObject.visible = false;
  material.depthTest = false;
  curveObject.renderOrder = 1;
  scene.add(curveObject);
}
</pre>
<p>Ensuite, j'ai √©crit du code pour d√©placer les voitures le long de la courbe. Pour chaque voiture, nous choisissons une position de 0 √† 1 le long de la courbe et calculons un point dans l'espace mondial en utilisant l'<code class="notranslate" translate="no">curveObject</code> pour transformer le point. Nous choisissons ensuite un autre point l√©g√®rement plus loin sur la courbe. Nous d√©finissons l'orientation de la voiture en utilisant <code class="notranslate" translate="no">lookAt</code> et pla√ßons la voiture au point m√©dian entre les 2 points.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// cr√©er 2 Vector3 que nous pouvons utiliser pour les calculs de chemin
const carPosition = new THREE.Vector3();
const carTarget = new THREE.Vector3();

function render(time) {
  ...

-  for (const car of cars) {
-    car.rotation.y = time;
-  }

+  {
+    const pathTime = time * .01;
+    const targetOffset = 0.01;
+    cars.forEach((car, ndx) =&gt; {
+      // un nombre entre 0 et 1 pour espacer uniform√©ment les voitures
+      const u = pathTime + ndx / cars.length;
+
+      // obtenir le premier point
+      curve.getPointAt(u % 1, carPosition);
+      carPosition.applyMatrix4(curveObject.matrixWorld);
+
+      // obtenir un deuxi√®me point l√©g√®rement plus loin sur la courbe
+      curve.getPointAt((u + targetOffset) % 1, carTarget);
+      carTarget.applyMatrix4(curveObject.matrixWorld);
+
+      // placer la voiture au premier point (temporairement)
+      car.position.copy(carPosition);
+      // orienter la voiture vers le deuxi√®me point
+      car.lookAt(carTarget);
+
+      // placer la voiture entre les 2 points
+      car.position.lerpVectors(carPosition, carTarget, 0.5);
+    });
+  }
</pre>
<p>et quand je l'ai ex√©cut√©, j'ai d√©couvert que pour chaque type de voiture, leur hauteur au-dessus de leurs origines n'est pas d√©finie de mani√®re coh√©rente, et j'ai donc d√ª d√©caler chacune un peu.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const loadedCars = root.getObjectByName('Cars');
const fixes = [
-  { prefix: 'Car_08', rot: [Math.PI * .5, 0, Math.PI * .5], },
-  { prefix: 'CAR_03', rot: [0, Math.PI, 0], },
-  { prefix: 'Car_04', rot: [0, Math.PI, 0], },
+  { prefix: 'Car_08', y: 0,  rot: [Math.PI * .5, 0, Math.PI * .5], },
+  { prefix: 'CAR_03', y: 33, rot: [0, Math.PI, 0], },
+  { prefix: 'Car_04', y: 40, rot: [0, Math.PI, 0], },
];

root.updateMatrixWorld();
for (const car of loadedCars.children.slice()) {
  const fix = fixes.find(fix =&gt; car.name.startsWith(fix.prefix));
  const obj = new THREE.Object3D();
  car.getWorldPosition(obj.position);
-  car.position.set(0, 0, 0);
+  car.position.set(0, fix.y, 0);
  car.rotation.set(...fix.rot);
  obj.add(car);
  scene.add(obj);
  cars.push(obj);
}
</pre>
<p>Et le r√©sultat.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/load-gltf-animated-cars.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/load-gltf-animated-cars.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Pas mal pour quelques minutes de travail.</p>
<p>La derni√®re chose que je voulais faire est d'activer les ombres.</p>
<p>Pour ce faire, j'ai pris tout le code GUI de l'exemple d'ombres <a href="/docs/#api/en/lights/DirectionalLight"><code class="notranslate" translate="no">DirectionalLight</code></a> dans <a href="shadows.html">l'article sur les ombres</a> et l'ai coll√© dans notre dernier code.</p>
<p>Ensuite, apr√®s le chargement, nous devons activer les ombres sur tous les objets.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">{
  const gltfLoader = new GLTFLoader();
  gltfLoader.load('resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf', (gltf) =&gt; {
    const root = gltf.scene;
    scene.add(root);

+    root.traverse((obj) =&gt; {
+      if (obj.castShadow !== undefined) {
+        obj.castShadow = true;
+        obj.receiveShadow = true;
+      }
+    });
</pre>
<p>J'ai ensuite pass√© pr√®s de 4 heures √† essayer de comprendre pourquoi les helpers d'ombre ne fonctionnaient pas. C'√©tait parce que j'avais oubli√© d'activer les ombres avec</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">renderer.shadowMap.enabled = true;
</pre>
<p>üò≠</p>
<p>J'ai ensuite ajust√© les valeurs jusqu'√† ce que la cam√©ra d'ombre de notre <code class="notranslate" translate="no">DirectionLight</code> ait un frustum qui couvrait toute la sc√®ne. Voici les param√®tres avec lesquels j'ai fini.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">{
  const color = 0xFFFFFF;
  const intensity = 1;
  const light = new THREE.DirectionalLight(color, intensity);
+  light.castShadow = true;
*  light.position.set(-250, 800, -850);
*  light.target.position.set(-550, 40, -450);

+  light.shadow.bias = -0.004;
+  light.shadow.mapSize.width = 2048;
+  light.shadow.mapSize.height = 2048;

  scene.add(light);
  scene.add(light.target);
+  const cam = light.shadow.camera;
+  cam.near = 1;
+  cam.far = 2000;
+  cam.left = -1500;
+  cam.right = 1500;
+  cam.top = 1500;
+  cam.bottom = -1500;
...
</pre>
<p>et j'ai d√©fini la couleur de fond en bleu clair.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const scene = new THREE.Scene();
-scene.background = new THREE.Color('black');
+scene.background = new THREE.Color('#DEFEFF');
</pre>
<p>Et ... les ombres</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/load-gltf-shadows.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/load-gltf-shadows.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>J'esp√®re que parcourir ce projet a √©t√© utile et a montr√© de bons exemples de r√©solution de certains des probl√®mes li√©s au chargement d'un fichier avec un graphe de sc√®ne.</p>
<p>Une chose int√©ressante est qu'en comparant le fichier .blend au fichier .gltf, le fichier .blend a plusieurs lumi√®res mais elles ne sont pas des lumi√®res apr√®s avoir √©t√© charg√©es dans la sc√®ne. Un fichier .GLTF est juste un fichier JSON, vous pouvez donc facilement regarder √† l'int√©rieur. Il se compose de plusieurs tableaux de choses et chaque √©l√©ment dans un tableau est r√©f√©renc√© par index ailleurs. Bien qu'il y ait des extensions en cours de d√©veloppement, elles soulignent un probl√®me commun √† presque tous les formats 3D. <strong>Ils ne peuvent jamais couvrir tous les cas</strong>.</p>
<p>Il y a toujours un besoin de plus de donn√©es. Par exemple, nous avons export√© manuellement un chemin pour les voitures √† suivre. Id√©alement, cette information aurait pu √™tre dans le fichier .GLTF, mais pour ce faire, nous aurions besoin d'√©crire notre propre exportateur et de marquer d'une mani√®re ou d'une autre les n≈ìuds pour la fa√ßon dont nous voulons qu'ils soient export√©s, ou utiliser un sch√©ma de nommage ou quelque chose de similaire pour obtenir les donn√©es de l'outil que nous utilisons pour cr√©er les donn√©es dans notre application.</p>
<p>Tout cela est laiss√© comme un exercice pour le lecteur.</p>

        </div>
      </div>
    </div>

  <script src="../resources/prettify.js"></script>
  <script src="../resources/lesson.js"></script>




</body></html>