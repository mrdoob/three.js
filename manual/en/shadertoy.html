<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <title>Three.js et Shadertoy</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@threejs">
    <meta name="twitter:title" content="Three.js ‚Äì et Shadertoy">
    <meta property="og:image" content="https://threejs.org/files/share.png">
    <link rel="shortcut icon" href="../../files/favicon_white.ico" media="(prefers-color-scheme: dark)">
    <link rel="shortcut icon" href="../../files/favicon.ico" media="(prefers-color-scheme: light)">

    <link rel="stylesheet" href="../resources/lesson.css">
    <link rel="stylesheet" href="../resources/lang.css">
<script type="importmap">
{
  "imports": {
    "three": "../../build/three.module.js"
  }
}
</script>
  </head>
  <body>
    <div class="container">
      <div class="lesson-title">
        <h1>Three.js et Shadertoy</h1>
      </div>
      <div class="lesson">
        <div class="lesson-main">
          <p><a href="https://shadertoy.com">Shadertoy</a> est un site web c√©l√®bre qui h√©berge d'√©tonnantes exp√©riences de shaders. Les gens demandent souvent comment ils peuvent utiliser ces shaders avec Three.js.</p>
<p>Il est important de reconna√Ætre qu'il s'appelle Shader<strong>TOY</strong> pour une raison. En g√©n√©ral, les shaders Shadertoy ne suivent pas les meilleures pratiques. Il s'agit plut√¥t d'un d√©fi amusant similaire √† <a href="https://dwitter.net">dwitter</a> (√©crire du code en 140 caract√®res) ou <a href="https://js13kgames.com">js13kGames</a> (cr√©er un jeu en 13k ou moins).</p>
<p>Dans le cas de Shadertoy, l'√©nigme est : <em>√©crire une fonction qui, pour une position de pixel donn√©e, produit une couleur qui dessine quelque chose d'int√©ressant</em>. C'est un d√©fi amusant et beaucoup de r√©sultats sont √©tonnants. Mais ce n'est pas une bonne pratique.</p>
<p>Comparez <a href="https://www.shadertoy.com/view/XtsSWs">cet √©tonnant shader shadertoy qui dessine une ville enti√®re</a></p>
<div class="threejs_center"><img src="../resources/images/shadertoy-skyline.png"></div>

<p>En plein √©cran sur mon GPU, il tourne √† environ 5 images par seconde. Comparez cela √† <a href="https://store.steampowered.com/app/255710/Cities_Skylines/">un jeu comme Cities: Skylines</a></p>
<div class="threejs_center"><img src="../resources/images/cities-skylines.jpg" style="width: 600px;"></div>

<p>Ce jeu tourne √† 30-60 images par seconde sur la m√™me machine car il utilise des techniques plus traditionnelles, dessinant des b√¢timents faits de triangles textur√©s, etc...</p>
<p>N√©anmoins, passons en revue l'utilisation d'un shader Shadertoy avec three.js.</p>
<p>Voici le shader Shadertoy par d√©faut si vous <a href="https://www.shadertoy.com/new">choisissez "New" sur shadertoy.com</a>, du moins depuis janvier 2019.</p>
<pre class="prettyprint showlinemods notranslate lang-glsl" translate="no">// Par iq : https://www.shadertoy.com/user/iq
// licence : Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Coordonn√©es de pixel normalis√©es (de 0 √† 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Couleur du pixel variant dans le temps
    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Sortie √† l'√©cran
    fragColor = vec4(col,1.0);
}
</pre>
<p>Une chose importante √† comprendre concernant les shaders est qu'ils sont √©crits dans un langage appel√© GLSL (Graphics Library Shading Language), con√ßu pour les math√©matiques 3D et incluant des types sp√©ciaux. Ci-dessus, nous voyons <code class="notranslate" translate="no">vec4</code>, <code class="notranslate" translate="no">vec2</code>, <code class="notranslate" translate="no">vec3</code> comme 3 de ces types sp√©ciaux. Un <code class="notranslate" translate="no">vec2</code> a 2 valeurs, un <code class="notranslate" translate="no">vec3</code> 3, un <code class="notranslate" translate="no">vec4</code> 4 valeurs. Ils peuvent √™tre adress√©s de plusieurs fa√ßons. Les plus courantes sont avec <code class="notranslate" translate="no">x</code>, <code class="notranslate" translate="no">y</code>, <code class="notranslate" translate="no">z</code> et <code class="notranslate" translate="no">w</code> comme dans</p>
<pre class="prettyprint showlinemods notranslate lang-glsl" translate="no">vec4 v1 = vec4(1.0, 2.0, 3.0, 4.0);
float v2 = v1.x + v1.y;  // adds 1.0 + 2.0
</pre>
<p>Contrairement au JavaScript, le GLSL ressemble plus au C/C++ o√π les variables doivent avoir leur type d√©clar√©, donc au lieu de <code class="notranslate" translate="no">var v = 1.2;</code>, c'est <code class="notranslate" translate="no">float v = 1.2;</code>, d√©clarant <code class="notranslate" translate="no">v</code> comme un nombre √† virgule flottante.</p>
<p>Expliquer le GLSL en d√©tail d√©passe le cadre de cet article. Pour un aper√ßu rapide, consultez <a href="https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html">cet article</a> et peut-√™tre poursuivez avec <a href="https://thebookofshaders.com/">cette s√©rie</a>.</p>
<p>Il convient de noter qu'au moins depuis janvier 2019, <a href="https://shadertoy.com">shadertoy.com</a> ne traite que des <em>shaders de fragments</em>. La responsabilit√© d'un shader de fragments est, √©tant donn√© une position de pixel, de produire une couleur pour ce pixel.</p>
<p>En regardant la fonction ci-dessus, nous pouvons voir que le shader a un param√®tre <code class="notranslate" translate="no">out</code> appel√© <code class="notranslate" translate="no">fragColor</code>. <code class="notranslate" translate="no">out</code> signifie <code class="notranslate" translate="no">output</code> (sortie). C'est un param√®tre pour lequel la fonction est cens√©e fournir une valeur. Nous devons d√©finir cela sur une couleur.</p>
<p>Il a √©galement un param√®tre <code class="notranslate" translate="no">in</code> (pour input/entr√©e) appel√© <code class="notranslate" translate="no">fragCoord</code>. C'est la coordonn√©e du pixel qui est sur le point d'√™tre dessin√©e. Nous pouvons utiliser cette coordonn√©e pour d√©cider d'une couleur. Si le canvas sur lequel nous dessinons fait 400x300 pixels, la fonction sera appel√©e 400x300 fois, soit 120 000 fois. Chaque fois, <code class="notranslate" translate="no">fragCoord</code> sera une coordonn√©e de pixel diff√©rente.</p>
<p>Il y a 2 variables suppl√©mentaires utilis√©es qui ne sont pas d√©finies dans le code. L'une est <code class="notranslate" translate="no">iResolution</code>. Celle-ci est d√©finie sur la r√©solution du canvas. Si le canvas est 400x300, alors <code class="notranslate" translate="no">iResolution</code> serait 400,300, donc √† mesure que les coordonn√©es de pixel changent, cela fait que <code class="notranslate" translate="no">uv</code> va de 0.0 √† 1.0 sur et le long de la texture. Travailler avec des valeurs <em>normalis√©es</em> rend souvent les choses plus faciles et c'est pourquoi la majorit√© des shaders shadertoy commencent par quelque chose comme ceci.</p>
<p>L'autre variable ind√©finie dans le shader est <code class="notranslate" translate="no">iTime</code>. C'est le temps √©coul√© depuis le chargement de la page en secondes.</p>
<p>Dans le jargon des shaders, ces variables globales sont appel√©es variables <em>uniformes</em>. Elles sont appel√©es <em>uniformes</em> car elles ne changent pas, elles restent uniformes d'une it√©ration du shader √† la suivante. Il est important de noter qu'elles sont toutes sp√©cifiques √† shadertoy. Ce ne sont pas des variables GLSL <em>officielles</em>. Ce sont des variables invent√©es par les cr√©ateurs de shadertoy.</p>
<p>La <a href="https://www.shadertoy.com/howto">documentation de Shadertoy en d√©finit plusieurs autres</a>. Pour l'instant, √©crivons quelque chose qui g√®re les deux utilis√©es dans le shader ci-dessus.</p>
<p>La premi√®re chose √† faire est de cr√©er un simple plan qui remplit le canvas. Si vous ne l'avez pas encore lu, nous l'avons fait dans <a href="backgrounds.html">l'article sur les arri√®re-plans</a>, alors prenons cet exemple mais retirons les cubes. C'est assez court, voici donc le tout</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function main() {
  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
  renderer.autoClearColor = false;

  const camera = new THREE.OrthographicCamera(
    -1, // left
     1, // right
     1, // top
    -1, // bottom
    -1, // near,
     1, // far
  );
  const scene = new THREE.Scene();
  const plane = new THREE.PlaneGeometry(2, 2);
  const material = new THREE.MeshBasicMaterial({
      color: 'red',
  });
  scene.add(new THREE.Mesh(plane, material));

  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render() {
    resizeRendererToDisplaySize(renderer);

    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}

main();
</pre>
<p>Comme <a href="backgrounds.html">expliqu√© dans l'article sur les arri√®re-plans</a>, une <a href="/docs/#api/en/cameras/OrthographicCamera"><code class="notranslate" translate="no">OrthographicCamera</code></a> avec ces param√®tres et un plan de 2 unit√©s remplira le canvas. Pour l'instant, tout ce que nous obtiendrons est un canvas rouge, car notre plan utilise un <a href="/docs/#api/en/materials/MeshBasicMaterial"><code class="notranslate" translate="no">MeshBasicMaterial</code></a> rouge.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/shadertoy-prep.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/shadertoy-prep.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Maintenant que nous avons quelque chose qui fonctionne, ajoutons le shader shadertoy. </p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const fragmentShader = `
#include &lt;common&gt;

uniform vec3 iResolution;
uniform float iTime;

// Par iq : https://www.shadertoy.com/user/iq
// licence : Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Coordonn√©es de pixel normalis√©es (de 0 √† 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Couleur du pixel variant dans le temps
    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Sortie √† l'√©cran
    fragColor = vec4(col,1.0);
}

void main() {
  mainImage(gl_FragColor, gl_FragCoord.xy);
}
`;
</pre>
<p>Ci-dessus, nous avons d√©clar√© les 2 variables uniformes dont nous avons parl√©. Ensuite, nous avons ins√©r√© le code GLSL du shader depuis shadertoy. Enfin, nous avons appel√© <code class="notranslate" translate="no">mainImage</code> en lui passant <code class="notranslate" translate="no">gl_FragColor</code> et <code class="notranslate" translate="no">gl_FragCoord.xy</code>. <code class="notranslate" translate="no">gl_FragColor</code> est une variable globale WebGL officielle que le shader est charg√© de d√©finir sur la couleur souhait√©e pour le pixel actuel. <code class="notranslate" translate="no">gl_FragCoord</code> est une autre variable globale WebGL officielle qui nous indique la coordonn√©e du pixel pour lequel nous choisissons actuellement une couleur.</p>
<p>Nous devons ensuite configurer les uniformes de three.js afin de pouvoir fournir des valeurs au shader.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const uniforms = {
  iTime: { value: 0 },
  iResolution:  { value: new THREE.Vector3() },
};
</pre>
<p>Chaque uniforme dans THREE.js poss√®de un param√®tre <code class="notranslate" translate="no">value</code>. Cette valeur doit correspondre au type de l'uniforme.</p>
<p>Ensuite, nous passons le shader de fragments et les uniformes √† un <a href="/docs/#api/en/materials/ShaderMaterial"><code class="notranslate" translate="no">ShaderMaterial</code></a>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const material = new THREE.MeshBasicMaterial({
-    color: 'red',
-});
+const material = new THREE.ShaderMaterial({
+  fragmentShader,
+  uniforms,
+});
</pre>
<p>et avant le rendu, nous devons d√©finir les valeurs des uniformes</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-function render() {
+function render(time) {
+  time *= 0.001;  // convertir en secondes

  resizeRendererToDisplaySize(renderer);

+  const canvas = renderer.domElement;
+  uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
+  uniforms.iTime.value = time;

  renderer.render(scene, camera);

  requestAnimationFrame(render);
}
</pre>
<blockquote>
<p>Note : Je n'ai aucune id√©e de pourquoi <code class="notranslate" translate="no">iResolution</code> est un <code class="notranslate" translate="no">vec3</code> et ce qu'il y a dans la 3√®me valeur <a href="https://www.shadertoy.com/howto">n'est pas document√© sur shadertoy.com</a>. Elle n'est pas utilis√©e ci-dessus, donc je la d√©finis simplement √† 1 pour l'instant. ¬Ø\_(„ÉÑ)_/¬Ø</p>
</blockquote>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/shadertoy-basic.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/shadertoy-basic.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Cela <a href="https://www.shadertoy.com/new">correspond √† ce que nous voyons sur Shadertoy pour un nouveau shader</a>, du moins depuis janvier 2019 üòâ. Que fait le shader ci-dessus ? </p>
<ul>
<li><code class="notranslate" translate="no">uv</code> va de 0 √† 1. </li>
<li><code class="notranslate" translate="no">cos(uv.xyx)</code> nous donne 3 valeurs de cosinus sous forme de <code class="notranslate" translate="no">vec3</code>. Une pour <code class="notranslate" translate="no">uv.x</code>, une autre pour <code class="notranslate" translate="no">uv.y</code> et encore une pour <code class="notranslate" translate="no">uv.x</code>.</li>
<li>L'ajout du temps, <code class="notranslate" translate="no">cos(iTime+uv.xyx)</code>, les fait s'animer.</li>
<li>L'ajout de <code class="notranslate" translate="no">vec3(0,2,4)</code> comme dans <code class="notranslate" translate="no">cos(iTime+uv.xyx+vec3(0,2,4))</code> d√©cale les ondes cosinuso√Ødales</li>
<li><code class="notranslate" translate="no">cos</code> va de -1 √† 1, donc <code class="notranslate" translate="no">0.5 * 0.5 + cos(...)</code> convertit de -1 &lt;-&gt; 1 √† 0.0 &lt;-&gt; 1.0</li>
<li>les r√©sultats sont ensuite utilis√©s comme couleur RGB pour le pixel actuel</li>
</ul>
<p>Un changement mineur facilitera la visualisation des ondes cosinuso√Ødales. Actuellement, <code class="notranslate" translate="no">uv</code> ne va que de 0 √† 1. Un cosinus se r√©p√®te √† 2œÄ, alors faisons-le aller de 0 √† 40 en multipliant par 40.0. Cela devrait le faire se r√©p√©ter environ 6.3 fois.</p>
<pre class="prettyprint showlinemods notranslate lang-glsl" translate="no">-vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));
+vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx*40.0+vec3(0,2,4));
</pre>
<p>En comptant ci-dessous, je vois environ 6.3 r√©p√©titions. Nous pouvons voir le bleu entre le rouge car il est d√©cal√© de 4 via le <code class="notranslate" translate="no">+vec3(0,2,4)</code>. Sans cela, le bleu et le rouge se superposeraient parfaitement, cr√©ant du violet.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/shadertoy-basic-x40.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/shadertoy-basic-x40.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Conna√Ætre la simplicit√© des entr√©es et voir ensuite des r√©sultats comme <a href="https://www.shadertoy.com/view/MdXGW2">un canal urbain</a>, <a href="https://www.shadertoy.com/view/4ttSWf">une for√™t</a>, <a href="https://www.shadertoy.com/view/ld3Gz2">un escargot</a>, <a href="https://www.shadertoy.com/view/4tBXR1">un champignon</a> rend le d√©fi d'autant plus impressionnant. Esp√©rons que cela rende √©galement clair pourquoi ce n'est g√©n√©ralement pas la bonne approche par rapport aux m√©thodes plus traditionnelles de cr√©ation de sc√®nes √† partir de triangles. Le fait qu'il faille mettre autant de math√©matiques dans le calcul de la couleur de chaque pixel signifie que ces exemples fonctionnent tr√®s lentement.</p>
<p>Certains shaders shadertoy prennent des textures en entr√©e comme <a href="https://www.shadertoy.com/view/MsXSzM">celui-ci</a>. </p>
<pre class="prettyprint showlinemods notranslate lang-glsl" translate="no">// Par Daedelus : https://www.shadertoy.com/user/Daedelus
// licence : Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
#define TIMESCALE 0.25
#define TILES 8
#define COLOR 0.7, 1.6, 2.8

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord.xy / iResolution.xy;
    uv.x *= iResolution.x / iResolution.y;

    vec4 noise = texture2D(iChannel0, floor(uv * float(TILES)) / float(TILES));
    float p = 1.0 - mod(noise.r + noise.g + noise.b + iTime * float(TIMESCALE), 1.0);
    p = min(max(p * 3.0 - 1.8, 0.1), 2.0);

    vec2 r = mod(uv * float(TILES), 1.0);
    r = vec2(pow(r.x - 0.5, 2.0), pow(r.y - 0.5, 2.0));
    p *= 1.0 - pow(min(1.0, 12.0 * dot(r, r)), 2.0);

    fragColor = vec4(COLOR, 1.0) * p;
}
</pre>
<p>Passer une texture dans un shader est similaire √† <a href="textures.html">en passer une dans un mat√©riau normal</a>, mais nous devons configurer la texture sur les uniformes.</p>
<p>Nous allons d'abord ajouter l'uniforme pour la texture au shader. Ils sont appel√©s <code class="notranslate" translate="no">sampler2D</code> en GLSL.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const fragmentShader = `
#include &lt;common&gt;

uniform vec3 iResolution;
uniform float iTime;
+uniform sampler2D iChannel0;

...
</pre>
<p>Ensuite, nous pouvons charger une texture comme nous l'avons <a href="textures.html">vu ici</a> et attribuer la valeur de l'uniforme.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const loader = new THREE.TextureLoader();
+const texture = loader.load('resources/images/bayer.png');
+texture.minFilter = THREE.NearestFilter;
+texture.magFilter = THREE.NearestFilter;
+texture.wrapS = THREE.RepeatWrapping;
+texture.wrapT = THREE.RepeatWrapping;
const uniforms = {
  iTime: { value: 0 },
  iResolution:  { value: new THREE.Vector3() },
+  iChannel0: { value: texture },
};
</pre>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/shadertoy-bleepy-blocks.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/shadertoy-bleepy-blocks.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Jusqu'√† pr√©sent, nous avons utilis√© les shaders Shadertoy tels qu'ils sont utilis√©s sur <a href="https://shadertoy.com">Shadertoy.com</a>, c'est-√†-dire en dessinant pour couvrir le canvas. Il n'y a aucune raison de nous limiter √† ce seul cas d'utilisation. L'important √† retenir est que les fonctions que les gens √©crivent sur shadertoy prennent g√©n√©ralement juste une entr√©e <code class="notranslate" translate="no">fragCoord</code> et un <code class="notranslate" translate="no">iResolution</code>. <code class="notranslate" translate="no">fragCoord</code> ne doit pas n√©cessairement provenir des coordonn√©es de pixel ; nous pourrions utiliser autre chose, comme les coordonn√©es de texture, et les utiliser ensuite un peu comme d'autres textures. Cette technique consistant √† utiliser une fonction pour g√©n√©rer des textures est souvent appel√©e <a href="https://www.google.com/search?q=procedural+texture"><em>texture proc√©durale</em></a>.</p>
<p>Modifions le shader ci-dessus pour faire cela. La chose la plus simple √† faire serait peut-√™tre de prendre les coordonn√©es de texture que three.js fournit normalement, de les multiplier par <code class="notranslate" translate="no">iResolution</code> et de les passer pour <code class="notranslate" translate="no">fragCoords</code>.</p>
<p>Pour ce faire, nous ajoutons un <em>varying</em>. Un varying est une valeur pass√©e du shader de vertex au shader de fragment qui est interpol√©e (ou varie) entre les sommets. Pour l'utiliser dans notre shader de fragment, nous le d√©clarons. Three.js d√©signe ses coordonn√©es de texture comme <code class="notranslate" translate="no">uv</code> avec le <code class="notranslate" translate="no">v</code> devant signifiant <em>varying</em> (variable/variant).</p>
<pre class="prettyprint showlinemods notranslate lang-glsl" translate="no">...

+varying vec2 vUv;

void main() {
-  mainImage(gl_FragColor, gl_FragCoord.xy);
+  mainImage(gl_FragColor, vUv * iResolution.xy);
}
</pre>
<p>Ensuite, nous devons √©galement fournir notre propre shader de vertex. Voici un shader de vertex three.js minimal assez courant. Three.js d√©clare et fournira des valeurs pour <code class="notranslate" translate="no">uv</code>, <code class="notranslate" translate="no">projectionMatrix</code>, <code class="notranslate" translate="no">modelViewMatrix</code> et <code class="notranslate" translate="no">position</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const vertexShader = `
  varying vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  }
`;
</pre>
<p>Nous devons passer le shader de vertex au <a href="/docs/#api/en/materials/ShaderMaterial"><code class="notranslate" translate="no">ShaderMaterial</code></a></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const material = new THREE.ShaderMaterial({
  vertexShader,
  fragmentShader,
  uniforms,
});
</pre>
<p>Nous pouvons d√©finir la valeur uniforme <code class="notranslate" translate="no">iResolution</code> au moment de l'initialisation puisqu'elle ne changera plus.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const uniforms = {
  iTime: { value: 0 },
-  iResolution:  { value: new THREE.Vector3() },
+  iResolution:  { value: new THREE.Vector3(1, 1, 1) },
  iChannel0: { value: texture },
};
</pre>
<p>et nous n'avons plus besoin de le d√©finir au moment du rendu</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const canvas = renderer.domElement;
-uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
uniforms.iTime.value = time;
</pre>
<p>Sinon, j'ai recopi√© la cam√©ra originale et le code qui configure 3 cubes en rotation √† partir de <a href="responsive.html">l'article sur la r√©activit√©</a>. Le r√©sultat :</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/shadertoy-as-texture.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/shadertoy-as-texture.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>J'esp√®re que cela vous donnera au moins un point de d√©part sur la fa√ßon d'utiliser un shader shadertoy avec three.js. Encore une fois, il est important de se rappeler que la plupart des shaders shadertoy sont un d√©fi int√©ressant (tout dessiner avec une seule fonction) plut√¥t que la m√©thode recommand√©e pour afficher r√©ellement les choses de mani√®re performante. N√©anmoins, ils sont √©tonnants, impressionnants, magnifiques, et vous pouvez apprendre √©norm√©ment en voyant comment ils fonctionnent.</p>

        </div>
      </div>
    </div>

  <script src="../resources/prettify.js"></script>
  <script src="../resources/lesson.js"></script>




</body></html>