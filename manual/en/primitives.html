<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <title>Primitives</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@threejs">
    <meta name="twitter:title" content="Three.js – Primitives">
    <meta property="og:image" content="https://threejs.org/files/share.png">
    <link rel="shortcut icon" href="../../files/favicon_white.ico" media="(prefers-color-scheme: dark)">
    <link rel="shortcut icon" href="../../files/favicon.ico" media="(prefers-color-scheme: light)">

    <link rel="stylesheet" href="../resources/lesson.css">
    <link rel="stylesheet" href="../resources/lang.css">
<script type="importmap">
{
  "imports": {
    "three": "../../build/three.module.js"
  }
}
</script>
  </head>
  <body>
    <div class="container">
      <div class="lesson-title">
        <h1>Primitives</h1>
      </div>
      <div class="lesson">
        <div class="lesson-main">
          <p>Cet article fait partie d'une série d'articles sur three.js.
Le premier article traitait des <a href="fundamentals.html">notions fondamentales</a>.
Si vous ne l'avez pas encore lu, vous pourriez vouloir commencer par là.</p>
<p>Three.js dispose d'un grand nombre de primitives. Les primitives
sont généralement des formes 3D générées à l'exécution
avec un ensemble de paramètres.</p>
<p>Il est courant d'utiliser des primitives pour des choses comme une sphère
pour un globe ou un groupe de boîtes pour dessiner un graphe 3D. Il est
particulièrement fréquent d'utiliser des primitives pour expérimenter
et débuter avec la 3D. Pour la majorité des applications 3D,
il est plus courant qu'un artiste crée des modèles 3D
dans un programme de modélisation 3D comme <a href="https://blender.org">Blender</a>
ou <a href="https://www.autodesk.com/products/maya/">Maya</a> ou <a href="https://www.maxon.net/en-us/products/cinema-4d/">Cinema 4D</a>. Plus tard dans cette série, nous aborderons
la création et le chargement de données provenant de plusieurs programmes de modélisation 3D.
Pour l'instant, passons en revue quelques-unes des primitives
disponibles.</p>
<p>Beaucoup des primitives ci-dessous ont des valeurs par défaut pour certains ou tous leurs
paramètres, vous pouvez donc les utiliser plus ou moins selon vos besoins.</p>
<div id="Diagram-BoxGeometry" data-primitive="BoxGeometry">Une boîte</div>
<div id="Diagram-CircleGeometry" data-primitive="CircleGeometry">Un cercle plat</div>
<div id="Diagram-ConeGeometry" data-primitive="ConeGeometry">Un cône</div>
<div id="Diagram-CylinderGeometry" data-primitive="CylinderGeometry">Un cylindre</div>
<div id="Diagram-DodecahedronGeometry" data-primitive="DodecahedronGeometry">Un dodécaèdre (12 côtés)</div>
<div id="Diagram-ExtrudeGeometry" data-primitive="ExtrudeGeometry">Une forme 2D extrudée avec chanfrein optionnel.
Ici, nous extrudons une forme de cœur. Notez que c'est la base
de <a href="/docs/#api/en/geometries/TextGeometry"><code class="notranslate" translate="no">TextGeometry</code></a>.</div>
<div id="Diagram-IcosahedronGeometry" data-primitive="IcosahedronGeometry">Un icosaèdre (20 côtés)</div>
<div id="Diagram-LatheGeometry" data-primitive="LatheGeometry">Une forme générée en faisant tourner une ligne. Exemples : lampes, quilles de bowling, bougies, chandeliers, verres à vin, verres à boire, etc. Vous fournissez la silhouette 2D sous forme de série de points et indiquez ensuite à three.js le nombre de subdivisions à créer lorsqu'il fait tourner la silhouette autour d'un axe.</div>
<div id="Diagram-OctahedronGeometry" data-primitive="OctahedronGeometry">Un octaèdre (8 côtés)</div>
<div id="Diagram-ParametricGeometry" data-primitive="ParametricGeometry">Une surface générée en fournissant une fonction qui prend un point 2D d'une grille et renvoie le point 3D correspondant.</div>
<div id="Diagram-PlaneGeometry" data-primitive="PlaneGeometry">Un plan 2D</div>
<div id="Diagram-PolyhedronGeometry" data-primitive="PolyhedronGeometry">Prend un ensemble de triangles centrés autour d'un point et les projette sur une sphère</div>
<div id="Diagram-RingGeometry" data-primitive="RingGeometry">Un disque 2D avec un trou au centre</div>
<div id="Diagram-ShapeGeometry" data-primitive="ShapeGeometry">Un contour 2D qui est triangulé</div>
<div id="Diagram-SphereGeometry" data-primitive="SphereGeometry">Une sphère</div>
<div id="Diagram-TetrahedronGeometry" data-primitive="TetrahedronGeometry">Un tétraèdre (4 côtés)</div>
<div id="Diagram-TextGeometry" data-primitive="TextGeometry">Texte 3D généré à partir d'une police 3D et d'une chaîne de caractères</div>
<div id="Diagram-TorusGeometry" data-primitive="TorusGeometry">Un tore (donut)</div>
<div id="Diagram-TorusKnotGeometry" data-primitive="TorusKnotGeometry">Un nœud torique</div>
<div id="Diagram-TubeGeometry" data-primitive="TubeGeometry">Un cercle tracé le long d'un chemin</div>
<div id="Diagram-EdgesGeometry" data-primitive="EdgesGeometry">Un objet d'assistance qui prend une autre géométrie en entrée et génère des arêtes uniquement si l'angle entre les faces est supérieur à un certain seuil. Par exemple, si vous regardez la boîte en haut, elle montre une ligne traversant chaque face, montrant chaque triangle qui compose la boîte. En utilisant un <a href="/docs/#api/en/geometries/EdgesGeometry"><code class="notranslate" translate="no">EdgesGeometry</code></a> à la place, les lignes du milieu sont supprimées. Ajustez le thresholdAngle ci-dessous et vous verrez les arêtes inférieures à ce seuil disparaître.</div>
<div id="Diagram-WireframeGeometry" data-primitive="WireframeGeometry">Génère une géométrie qui contient un segment de ligne (2 points) par arête dans la géométrie donnée. Sans cela, il vous manquerait souvent des arêtes ou vous obtiendriez des arêtes supplémentaires, car WebGL nécessite généralement 2 points par segment de ligne. Par exemple, si vous n'aviez qu'un seul triangle, il n'y aurait que 3 points. Si vous essayiez de le dessiner en utilisant un matériau avec <code class="notranslate" translate="no">wireframe: true</code>, vous n'obtiendriez qu'une seule ligne. Passer cette géométrie de triangle à un <a href="/docs/#api/en/geometries/WireframeGeometry"><code class="notranslate" translate="no">WireframeGeometry</code></a> générera une nouvelle géométrie qui a 3 segments de ligne utilisant 6 points.</div>

<p>Nous aborderons la création de géométries personnalisées dans <a href="custom-buffergeometry.html">un autre article</a>. Pour l'instant,
faisons un exemple créant chaque type de primitive. Nous commencerons
avec les <a href="responsive.html">exemples de l'article précédent</a>.</p>
<p>Près du haut, définissons une couleur de fond</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const scene = new THREE.Scene();
+scene.background = new THREE.Color(0xAAAAAA);
</pre>
<p>Cela indique à three.js d'effacer sur un gris clair.</p>
<p>La caméra doit changer de position afin que nous puissions voir tous les
objets.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const fov = 75;
+const fov = 40;
const aspect = 2;  // the canvas default
const near = 0.1;
-const far = 5;
+const far = 1000;
const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
-camera.position.z = 2;
+camera.position.z = 120;
</pre>
<p>Ajoutons une fonction, <code class="notranslate" translate="no">addObject</code>, qui prend une position x, y et un <a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a> et ajoute
l'objet à la scène.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const objects = [];
const spread = 15;

function addObject(x, y, obj) {
  obj.position.x = x * spread;
  obj.position.y = y * spread;

  scene.add(obj);
  objects.push(obj);
}
</pre>
<p>Créons également une fonction pour créer un matériau de couleur aléatoire.
Nous utiliserons une fonctionnalité de <a href="/docs/#api/en/math/Color"><code class="notranslate" translate="no">Color</code></a> qui permet de définir une couleur
basée sur la teinte (hue), la saturation et la luminance.</p>
<p><code class="notranslate" translate="no">hue</code> (teinte) va de 0 à 1 autour de la roue chromatique, le
rouge étant à 0, le vert à .33 et le bleu à .66. <code class="notranslate" translate="no">saturation</code>
va de 0 à 1, 0 n'ayant pas de couleur et 1 étant
le plus saturé. <code class="notranslate" translate="no">luminance</code> va de 0 à 1
avec 0 étant le noir, 1 étant le blanc et 0.5 étant
la quantité maximale de couleur. Autrement dit,
lorsque <code class="notranslate" translate="no">luminance</code> passe de 0.0 à 0.5, la couleur
passera du noir à la <code class="notranslate" translate="no">hue</code>. De 0.5 à 1.0,
la couleur passera de la <code class="notranslate" translate="no">hue</code> au blanc.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function createMaterial() {
  const material = new THREE.MeshPhongMaterial({
    side: THREE.DoubleSide,
  });

  const hue = Math.random();
  const saturation = 1;
  const luminance = .5;
  material.color.setHSL(hue, saturation, luminance);

  return material;
}
</pre>
<p>Nous avons également passé <code class="notranslate" translate="no">side: THREE.DoubleSide</code> au matériau.
Cela indique à three de dessiner les deux côtés des triangles
qui composent une forme. Pour une forme solide comme une sphère
ou un cube, il n'y a généralement aucune raison de dessiner l'arrière
des triangles, car ils font tous face à l'intérieur de la
forme. Dans notre cas cependant, nous dessinons quelques éléments
comme la <a href="/docs/#api/en/geometries/PlaneGeometry"><code class="notranslate" translate="no">PlaneGeometry</code></a> et la <a href="/docs/#api/en/geometries/ShapeGeometry"><code class="notranslate" translate="no">ShapeGeometry</code></a>
qui sont bidimensionnels et n'ont donc pas d'intérieur. Sans
définir <code class="notranslate" translate="no">side: THREE.DoubleSide</code>, elles disparaîtraient
en regardant leur face arrière.</p>
<p>Je dois noter qu'il est plus rapide de dessiner sans définir
<code class="notranslate" translate="no">side: THREE.DoubleSide</code>, donc idéalement, nous ne le réglerions
que sur les matériaux qui en ont vraiment besoin, mais dans ce cas, nous
ne dessinons pas trop d'éléments, il n'y a donc pas beaucoup de raisons de
s'en préoccuper.</p>
<p>Créons une fonction, <code class="notranslate" translate="no">addSolidGeometry</code>,
à laquelle nous passons une géométrie et qui crée un matériau de couleur aléatoire
via <code class="notranslate" translate="no">createMaterial</code> et l'ajoute à la scène
via <code class="notranslate" translate="no">addObject</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function addSolidGeometry(x, y, geometry) {
  const mesh = new THREE.Mesh(geometry, createMaterial());
  addObject(x, y, mesh);
}
</pre>
<p>Maintenant, nous pouvons utiliser cela pour la majorité des primitives que nous créons.
Par exemple, créer une boîte</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">{
  const width = 8;
  const height = 8;
  const depth = 8;
  addSolidGeometry(-2, -2, new THREE.BoxGeometry(width, height, depth));
}
</pre>
<p>Si vous regardez le code ci-dessous, vous verrez une section similaire pour chaque type de géométrie.</p>
<p>Voici le résultat :</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/primitives.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/primitives.html" target="_blank">cliquez ici pour ouvrir dans une fenêtre séparée</a>
</div>

<p></p>
<p>Il existe quelques exceptions notables au modèle ci-dessus.
La plus importante est probablement la <a href="/docs/#api/en/geometries/TextGeometry"><code class="notranslate" translate="no">TextGeometry</code></a>. Elle doit charger
les données de police 3D avant de pouvoir générer un maillage pour le texte.
Ces données se chargent de manière asynchrone, nous devons donc attendre leur
chargement avant d'essayer de créer la géométrie. En "promisifiant"
le chargement des polices, nous pouvons simplifier grandement les choses.
Nous créons un <a href="/docs/#api/en/loaders/FontLoader"><code class="notranslate" translate="no">FontLoader</code></a>, puis une fonction <code class="notranslate" translate="no">loadFont</code> qui renvoie
une promesse qui, une fois résolue, nous donnera la police. Nous créons ensuite
une fonction <code class="notranslate" translate="no">async</code> appelée <code class="notranslate" translate="no">doit</code> et chargeons la police en utilisant <code class="notranslate" translate="no">await</code>.
Et enfin, nous créons la géométrie et appelons <code class="notranslate" translate="no">addObject</code> pour l'ajouter à la scène.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">{
  const loader = new FontLoader();
  // promisify font loading
  function loadFont(url) {
    return new Promise((resolve, reject) =&gt; {
      loader.load(url, resolve, undefined, reject);
    });
  }

  async function doit() {
    const font = await loadFont('resources/threejs/fonts/helvetiker_regular.typeface.json');  /* threejs.org : url */
    const geometry = new TextGeometry('three.js', {
      font: font,
      size: 3.0,
      depth: .2,
      curveSegments: 12,
      bevelEnabled: true,
      bevelThickness: 0.15,
      bevelSize: .3,
      bevelSegments: 5,
    });
    const mesh = new THREE.Mesh(geometry, createMaterial());
    geometry.computeBoundingBox();
    geometry.boundingBox.getCenter(mesh.position).multiplyScalar(-1);

    const parent = new THREE.Object3D();
    parent.add(mesh);

    addObject(-1, -1, parent);
  }
  doit();
}
</pre>
<p>Il y a une autre différence. Nous voulons faire tourner le texte autour de son
centre, mais par défaut, three.js crée le texte de manière que son centre de rotation
soit sur le bord gauche. Pour contourner ce problème, nous pouvons demander à three.js
de calculer la boîte englobante (bounding box) de la géométrie. Nous pouvons ensuite
appeler la méthode <code class="notranslate" translate="no">getCenter</code> de la boîte englobante
et lui passer l'objet de position de notre maillage.
<code class="notranslate" translate="no">getCenter</code> copie le centre de la boîte dans la position.
Elle renvoie également l'objet position afin que nous puissions appeler <code class="notranslate" translate="no">multiplyScalar(-1)</code>
pour positionner l'objet entier de manière que son centre de rotation
soit au centre de l'objet.</p>
<p>Si nous appelions ensuite simplement <code class="notranslate" translate="no">addSolidGeometry</code> comme dans les exemples
précédents, cela définirait à nouveau la position, ce qui
n'est pas bon. Ainsi, dans ce cas, nous créons un <a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a> qui
est le nœud standard pour le graphe de scène de three.js. <a href="/docs/#api/en/objects/Mesh"><code class="notranslate" translate="no">Mesh</code></a>
hérite également de <a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a>. Nous couvrirons <a href="scenegraph.html">le fonctionnement du graphe de scène
dans un autre article</a>.
Pour l'instant, il suffit de savoir que,
comme les nœuds DOM, les enfants sont dessinés par rapport à leur parent.
En créant un <a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a> et en faisant de notre maillage un enfant de celui-ci,
nous pouvons positionner l'<a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a> où nous voulons tout en
conservant le décalage central que nous avons défini précédemment.</p>
<p>Si nous ne faisions pas cela, le texte tournerait décentré.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/primitives-text.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/primitives-text.html" target="_blank">cliquez ici pour ouvrir dans une fenêtre séparée</a>
</div>

<p></p>
<p>Remarquez que celui de gauche ne tourne pas autour de son centre,
tandis que celui de droite le fait.</p>
<p>Les autres exceptions sont les 2 exemples basés sur des lignes pour <a href="/docs/#api/en/geometries/EdgesGeometry"><code class="notranslate" translate="no">EdgesGeometry</code></a>
et <a href="/docs/#api/en/geometries/WireframeGeometry"><code class="notranslate" translate="no">WireframeGeometry</code></a>. Au lieu d'appeler <code class="notranslate" translate="no">addSolidGeometry</code>, elles appellent
<code class="notranslate" translate="no">addLineGeometry</code> qui ressemble à ceci</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function addLineGeometry(x, y, geometry) {
  const material = new THREE.LineBasicMaterial({color: 0x000000});
  const mesh = new THREE.LineSegments(geometry, material);
  addObject(x, y, mesh);
}
</pre>
<p>Cela crée un <a href="/docs/#api/en/materials/LineBasicMaterial"><code class="notranslate" translate="no">LineBasicMaterial</code></a> noir et crée ensuite un objet <a href="/docs/#api/en/objects/LineSegments"><code class="notranslate" translate="no">LineSegments</code></a>
qui est un wrapper pour <a href="/docs/#api/en/objects/Mesh"><code class="notranslate" translate="no">Mesh</code></a> et aide three à savoir que vous affichez
des segments de ligne (2 points par segment).</p>
<p>Chacune des primitives possède plusieurs paramètres que vous pouvez passer lors de la création
et il est préférable de <a href="https://threejs.org/docs/">consulter la documentation</a> pour tous les connaître plutôt que
de les répéter ici. Vous pouvez également cliquer sur les liens ci-dessus à côté de chaque forme
pour accéder directement à la documentation de cette forme.</p>
<p>Il existe une autre paire de classes qui ne correspond pas vraiment aux modèles ci-dessus. Ce sont
les classes <a href="/docs/#api/en/materials/PointsMaterial"><code class="notranslate" translate="no">PointsMaterial</code></a> et <a href="/docs/#api/en/objects/Points"><code class="notranslate" translate="no">Points</code></a>. <a href="/docs/#api/en/objects/Points"><code class="notranslate" translate="no">Points</code></a> est similaire à <a href="/docs/#api/en/objects/LineSegments"><code class="notranslate" translate="no">LineSegments</code></a> ci-dessus en ce sens qu'il prend
une <a href="/docs/#api/en/core/BufferGeometry"><code class="notranslate" translate="no">BufferGeometry</code></a> mais dessine des points à chaque sommet au lieu de lignes.
Pour l'utiliser, vous devez également lui passer un <a href="/docs/#api/en/materials/PointsMaterial"><code class="notranslate" translate="no">PointsMaterial</code></a> qui
prend un paramètre <a href="/docs/#api/en/materials/PointsMaterial#size"><code class="notranslate" translate="no">size</code></a> pour déterminer la taille des points.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const radius = 7;
const widthSegments = 12;
const heightSegments = 8;
const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);
const material = new THREE.PointsMaterial({
    color: 'red',
    size: 0.2,     // en unités du monde
});
const points = new THREE.Points(geometry, material);
scene.add(points);
</pre>
<div class="spread">
<div data-diagram="Points"></div>
</div>

<p>Vous pouvez désactiver <a href="/docs/#api/en/materials/PointsMaterial#sizeAttenuation"><code class="notranslate" translate="no">sizeAttenuation</code></a> en le réglant sur false si vous souhaitez que les points
aient la même taille quelle que soit leur distance de la caméra.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const material = new THREE.PointsMaterial({
    color: 'red',
+    sizeAttenuation: false,
+    size: 3,       // en pixels
-    size: 0.2,     // en unités du monde
});
...
</pre>
<div class="spread">
<div data-diagram="PointsUniformSize"></div>
</div>

<p>Une autre chose importante à couvrir est que presque toutes les formes
ont divers paramètres pour déterminer leur niveau de subdivision. Un bon exemple
pourrait être les géométries de sphère. Les sphères prennent des paramètres pour
le nombre de divisions à faire autour et le nombre de divisions de haut en bas. Par exemple</p>
<div class="spread">
<div data-diagram="SphereGeometryLow"></div>
<div data-diagram="SphereGeometryMedium"></div>
<div data-diagram="SphereGeometryHigh"></div>
</div>

<p>La première sphère a 5 segments autour et 3 de haut, ce qui fait 15 segments
ou 30 triangles. La deuxième sphère a 24 segments par 10, soit 240 segments
ou 480 triangles. La dernière a 50 par 50, ce qui fait 2500 segments ou 5000 triangles.</p>
<p>C'est à vous de décider combien de subdivisions vous avez besoin. Il pourrait
sembler que vous ayez besoin d'un grand nombre de segments, mais si vous retirez les lignes
et l'ombrage plat, nous obtenons ceci</p>
<div class="spread">
<div data-diagram="SphereGeometryLowSmooth"></div>
<div data-diagram="SphereGeometryMediumSmooth"></div>
<div data-diagram="SphereGeometryHighSmooth"></div>
</div>

<p>Il n'est maintenant plus si clair que celui de droite avec 5000 triangles
soit entièrement meilleur que celui du milieu avec seulement 480.
Si vous ne dessinez que quelques sphères, comme un seul globe pour
une carte de la terre, alors une seule sphère de 10000 triangles n'est pas un mauvais
choix. Si, par contre, vous essayez de dessiner 1000 sphères,
alors 1000 sphères fois 10000 triangles chacune font 10 millions de triangles.
Pour animer fluidement, le navigateur doit dessiner à 60 images par
seconde, donc vous demanderiez au navigateur de dessiner 600 millions de triangles
par seconde. C'est beaucoup de calcul.</p>
<p>Parfois, c'est facile de choisir. Par exemple, vous pouvez également
choisir de subdiviser un plan.</p>
<div class="spread">
<div data-diagram="PlaneGeometryLow"></div>
<div data-diagram="PlaneGeometryHigh"></div>
</div>

<p>Le plan de gauche est composé de 2 triangles. Le plan de droite
est composé de 200 triangles. Contrairement à la sphère, il n'y a vraiment pas de compromis de qualité pour la plupart
des cas d'utilisation d'un plan. Vous ne subdiviseriez très probablement un plan
que si vous vous attendiez à vouloir le modifier ou le déformer d'une manière ou d'une autre. Une boîte
est similaire.</p>
<p>Alors, choisissez ce qui est approprié pour votre situation. Moins
vous choisissez de subdivisions, plus il est probable que les choses fonctionneront fluidement et moins
elles prendront de mémoire. Vous devrez décider par vous-même quel est le bon
compromis pour votre situation particulière.</p>
<p>Si aucune des formes ci-dessus ne correspond à votre cas d'utilisation, vous pouvez charger
de la géométrie, par exemple à partir d'un <a href="load-obj.html">fichier .obj</a>
ou d'un <a href="load-gltf.html">fichier .gltf</a>.
Vous pouvez également créer votre propre <a href="custom-buffergeometry.html">BufferGeometry personnalisée</a>.</p>
<p>Ensuite, passons en revue <a href="scenegraph.html">comment fonctionne le graphe de scène de three.js et comment
l'utiliser</a>.</p>
<p><link rel="stylesheet" href="../resources/threejs-primitives.css"></p>
<script type="module" src="../resources/threejs-primitives.js"></script>


        </div>
      </div>
    </div>

  <script defer src="../resources/prettify.js"></script>
  <script defer src="../resources/lesson.js"></script>




</body></html>