<!DOCTYPE html><html lang="fr"><head>
    <meta charset="utf-8">
    <title>Cam√©ras</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@threejs">
    <meta name="twitter:title" content="Three.js ‚Äì Cam√©ras">
    <meta property="og:image" content="https://threejs.org/files/share.png">
    <link rel="shortcut icon" href="../../files/favicon_white.ico" media="(prefers-color-scheme: dark)">
    <link rel="shortcut icon" href="../../files/favicon.ico" media="(prefers-color-scheme: light)">

    <link rel="stylesheet" href="../resources/lesson.css">
    <link rel="stylesheet" href="../resources/lang.css">
<script type="importmap">
{
  "imports": {
    "three": "../../build/three.module.js"
  }
}
</script>
  </head>
  <body>
    <div class="container">
      <div class="lesson-title">
        <h1>Cam√©ras</h1>
      </div>
      <div class="lesson">
        <div class="lesson-main">
          <p>Cet article fait partie d'une s√©rie d'articles sur three.js.
Le premier article √©tait <a href="fundamentals.html">sur les bases</a>.
Si vous ne l'avez pas encore lu, vous pourriez vouloir commencer par l√†.</p>
<p>Parlons des cam√©ras dans three.js. Nous avons abord√© une partie de ce sujet dans le <a href="fundamentals.html">premier article</a> mais nous allons le couvrir plus en d√©tail ici.</p>
<p>La cam√©ra la plus courante dans three.js et celle que nous avons utilis√©e jusqu'√† pr√©sent est
la <a href="/docs/#api/en/cameras/PerspectiveCamera"><code class="notranslate" translate="no">PerspectiveCamera</code></a>. Elle offre une vue 3D o√π les √©l√©ments √©loign√©s apparaissent
plus petits que les √©l√©ments proches.</p>
<p>La <a href="/docs/#api/en/cameras/PerspectiveCamera"><code class="notranslate" translate="no">PerspectiveCamera</code></a> d√©finit un <em>frustum</em>. <a href="https://en.wikipedia.org/wiki/Frustum">Un <em>tronc de pyramide</em> est une forme pyramidale solide
dont l'extr√©mit√© est coup√©e</a>.
Par nom de solide, j'entends par exemple un cube, un c√¥ne, une sph√®re, un cylindre,
et un frustum sont tous des noms de diff√©rents types de solides.</p>
<div class="spread">
  <div><div data-diagram="shapeCube"></div><div>cube</div></div>
  <div><div data-diagram="shapeCone"></div><div>c√¥ne</div></div>
  <div><div data-diagram="shapeSphere"></div><div>sph√®re</div></div>
  <div><div data-diagram="shapeCylinder"></div><div>cylindre</div></div>
  <div><div data-diagram="shapeFrustum"></div><div>frustum</div></div>
</div>

<p>Je le souligne simplement parce que je ne l'ai pas su pendant des ann√©es. Un livre ou une page mentionnait
<em>frustum</em> et mes yeux se vidaient. Comprendre que c'est le nom d'un type de forme solide
a soudainement rendu ces descriptions plus claires üòÖ</p>
<p>Une <a href="/docs/#api/en/cameras/PerspectiveCamera"><code class="notranslate" translate="no">PerspectiveCamera</code></a> d√©finit son frustum en fonction de 4 propri√©t√©s. <code class="notranslate" translate="no">near</code> d√©finit o√π commence
l'avant du frustum. <code class="notranslate" translate="no">far</code> d√©finit o√π il se termine. <code class="notranslate" translate="no">fov</code>, le champ de vision, d√©finit
la hauteur de l'avant et de l'arri√®re du frustum en calculant la hauteur correcte pour obtenir
le champ de vision sp√©cifi√© √† <code class="notranslate" translate="no">near</code> unit√©s de la cam√©ra. L'<code class="notranslate" translate="no">aspect</code> d√©finit
la largeur de l'avant et de l'arri√®re du frustum. La largeur du frustum est simplement la hauteur
multipli√©e par l'aspect.</p>
<p><img src="../resources/frustum-3d.svg" width="500" class="threejs_center"></p>
<p>Utilisons la sc√®ne de <a href="lights.html">l'article pr√©c√©dent</a> qui contient un
plan au sol, une sph√®re et un cube, et faisons en sorte de pouvoir ajuster les param√®tres de la cam√©ra.</p>
<p>Pour cela, nous allons cr√©er un <code class="notranslate" translate="no">MinMaxGUIHelper</code> pour les param√®tres <code class="notranslate" translate="no">near</code> et <code class="notranslate" translate="no">far</code> afin que <code class="notranslate" translate="no">far</code>
soit toujours sup√©rieur √† <code class="notranslate" translate="no">near</code>. Il aura des propri√©t√©s <code class="notranslate" translate="no">min</code> et <code class="notranslate" translate="no">max</code> que lil-gui
ajustera. Une fois ajust√©es, elles d√©finiront les 2 propri√©t√©s que nous sp√©cifions.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class MinMaxGUIHelper {
  constructor(obj, minProp, maxProp, minDif) {
    this.obj = obj;
    this.minProp = minProp;
    this.maxProp = maxProp;
    this.minDif = minDif;
  }
  get min() {
    return this.obj[this.minProp];
  }
  set min(v) {
    this.obj[this.minProp] = v;
    this.obj[this.maxProp] = Math.max(this.obj[this.maxProp], v + this.minDif);
  }
  get max() {
    return this.obj[this.maxProp];
  }
  set max(v) {
    this.obj[this.maxProp] = v;
    this.min = this.min;  // this will call the min setter
  }
}
</pre>
<p>Nous pouvons maintenant configurer notre GUI comme ceci</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function updateCamera() {
  camera.updateProjectionMatrix();
}

const gui = new GUI();
gui.add(camera, 'fov', 1, 180).onChange(updateCamera);
const minMaxGUIHelper = new MinMaxGUIHelper(camera, 'near', 'far', 0.1);
gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far').onChange(updateCamera);
</pre>
<p>Chaque fois que les param√®tres de la cam√©ra changent, nous devons appeler la fonction
<a href="/docs/#api/en/cameras/PerspectiveCamera#updateProjectionMatrix"><code class="notranslate" translate="no">updateProjectionMatrix</code></a> de la cam√©ra,
nous avons donc cr√©√© une fonction appel√©e <code class="notranslate" translate="no">updateCamera</code> et l'avons pass√©e √† lil-gui pour l'appeler lorsque les choses changent.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/cameras-perspective.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/cameras-perspective.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Vous pouvez ajuster les valeurs et voir comment elles fonctionnent. Notez que nous n'avons pas rendu l'<code class="notranslate" translate="no">aspect</code> r√©glable car
il est tir√© de la taille de la fen√™tre. Donc si vous voulez ajuster l'aspect, ouvrez l'exemple
dans une nouvelle fen√™tre et redimensionnez la fen√™tre.</p>
<p>Cependant, je pense que c'est un peu difficile √† voir, alors changeons l'exemple pour qu'il ait 2 cam√©ras.
L'une montrera notre sc√®ne telle que nous la voyons ci-dessus, l'autre montrera une autre cam√©ra regardant la
sc√®ne que la premi√®re cam√©ra dessine et montrant le frustum de cette cam√©ra.</p>
<p>Pour ce faire, nous pouvons utiliser la fonction scissor de three.js.
Changeons-la pour dessiner 2 sc√®nes avec 2 cam√©ras c√¥te √† c√¥te en utilisant la fonction scissor</p>
<p>Tout d'abord, utilisons du HTML et du CSS pour d√©finir 2 √©l√©ments c√¥te √† c√¥te. Cela nous aidera √©galement
avec les √©v√©nements afin que les deux cam√©ras puissent facilement avoir leurs propres <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate" translate="no">OrbitControls</code></a>.</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;body&gt;
  &lt;canvas id="c"&gt;&lt;/canvas&gt;
+  &lt;div class="split"&gt;
+     &lt;div id="view1" tabindex="1"&gt;&lt;/div&gt;
+     &lt;div id="view2" tabindex="2"&gt;&lt;/div&gt;
+  &lt;/div&gt;
&lt;/body&gt;
</pre>
<p>Et le CSS qui fera appara√Ætre ces 2 vues c√¥te √† c√¥te superpos√©es sur le dessus du
canvas</p>
<pre class="prettyprint showlinemods notranslate lang-css" translate="no">.split {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: flex;
}
.split&gt;div {
  width: 100%;
  height: 100%;
}
</pre>
<p>Ensuite, dans notre code, nous allons ajouter un <a href="/docs/#api/en/helpers/CameraHelper"><code class="notranslate" translate="no">CameraHelper</code></a>. Un <a href="/docs/#api/en/helpers/CameraHelper"><code class="notranslate" translate="no">CameraHelper</code></a> dessine le frustum pour une <a href="/docs/#api/en/cameras/Camera"><code class="notranslate" translate="no">Camera</code></a></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const cameraHelper = new THREE.CameraHelper(camera);

...

scene.add(cameraHelper);
</pre>
<p>Regardons maintenant les 2 √©l√©ments de vue.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const view1Elem = document.querySelector('#view1');
const view2Elem = document.querySelector('#view2');
</pre>
<p>Et nous allons configurer nos <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate" translate="no">OrbitControls</code></a> existants pour r√©pondre uniquement au premier
√©l√©ment de vue.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const controls = new OrbitControls(camera, canvas);
+const controls = new OrbitControls(camera, view1Elem);
</pre>
<p>Cr√©ons une seconde <a href="/docs/#api/en/cameras/PerspectiveCamera"><code class="notranslate" translate="no">PerspectiveCamera</code></a> et une seconde <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate" translate="no">OrbitControls</code></a>.
Le second <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate" translate="no">OrbitControls</code></a> est li√© √† la seconde cam√©ra et re√ßoit l'entr√©e
du second √©l√©ment de vue.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const camera2 = new THREE.PerspectiveCamera(
  60,  // champ de vision
  2,   // aspect
  0.1, // pr√®s
  500, // loin
);
camera2.position.set(40, 10, 30);
camera2.lookAt(0, 5, 0);

const controls2 = new OrbitControls(camera2, view2Elem);
controls2.target.set(0, 5, 0);
controls2.update();
</pre>
<p>Enfin, nous devons rendre la sc√®ne du point de vue de chaque
cam√©ra en utilisant la fonction scissor pour ne rendre qu'une partie du canvas.</p>
<p>Voici une fonction qui, √©tant donn√© un √©l√©ment, calcule le rectangle
de cet √©l√©ment qui chevauche le canvas. Elle configure ensuite le scissor
et le viewport sur ce rectangle et renvoie l'aspect pour cette taille.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function setScissorForElement(elem) {
  const canvasRect = canvas.getBoundingClientRect();
  const elemRect = elem.getBoundingClientRect();

  // calculer un rectangle relatif au canvas
  const right = Math.min(elemRect.right, canvasRect.right) - canvasRect.left;
  const left = Math.max(0, elemRect.left - canvasRect.left);
  const bottom = Math.min(elemRect.bottom, canvasRect.bottom) - canvasRect.top;
  const top = Math.max(0, elemRect.top - canvasRect.top);

  const width = Math.min(canvasRect.width, right - left);
  const height = Math.min(canvasRect.height, bottom - top);

  // configurer le scissor pour ne rendre que sur cette partie du canvas
  const positiveYUpBottom = canvasRect.height - bottom;
  renderer.setScissor(left, positiveYUpBottom, width, height);
  renderer.setViewport(left, positiveYUpBottom, width, height);

  // renvoyer l'aspect
  return width / height;
}
</pre>
<p>Et maintenant, nous pouvons utiliser cette fonction pour dessiner la sc√®ne deux fois dans notre fonction <code class="notranslate" translate="no">render</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  function render() {

-    if (resizeRendererToDisplaySize(renderer)) {
-      const canvas = renderer.domElement;
-      camera.aspect = canvas.clientWidth / canvas.clientHeight;
-      camera.updateProjectionMatrix();
-    }

+    resizeRendererToDisplaySize(renderer);
+
+    // activer le scissor
+    renderer.setScissorTest(true);
+
+    // rendre la vue originale
+    {
+      const aspect = setScissorForElement(view1Elem);
+
+      // ajuster la cam√©ra pour cet aspect
+      camera.aspect = aspect;
+      camera.updateProjectionMatrix();
+      cameraHelper.update();
+
+      // ne pas dessiner le camera helper dans la vue originale
+      cameraHelper.visible = false;
+
+      scene.background.set(0x000000);
+
+      // rendre
+      renderer.render(scene, camera);
+    }
+
+    // rendre √† partir de la 2√®me cam√©ra
+    {
+      const aspect = setScissorForElement(view2Elem);
+
+      // ajuster la cam√©ra pour cet aspect
+      camera2.aspect = aspect;
+      camera2.updateProjectionMatrix();
+
+      // dessiner le camera helper dans la 2√®me vue
+      cameraHelper.visible = true;
+
+      scene.background.set(0x000040);
+
+      renderer.render(scene, camera2);
+    }

-    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}
</pre>
<p>Le code ci-dessus d√©finit la couleur de fond de la sc√®ne lors du rendu de la
deuxi√®me vue en bleu fonc√© juste pour faciliter la distinction entre les deux vues.</p>
<p>Nous pouvons √©galement supprimer notre code <code class="notranslate" translate="no">updateCamera</code> puisque nous mettons tout √† jour
dans la fonction <code class="notranslate" translate="no">render</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-function updateCamera() {
-  camera.updateProjectionMatrix();
-}

const gui = new GUI();
-gui.add(camera, 'fov', 1, 180).onChange(updateCamera);
+gui.add(camera, 'fov', 1, 180);
const minMaxGUIHelper = new MinMaxGUIHelper(camera, 'near', 'far', 0.1);
-gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
-gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far').onChange(updateCamera);
+gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near');
+gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far');
</pre>
<p>Et maintenant, vous pouvez utiliser une vue pour voir le frustum de l'autre.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/cameras-perspective-2-scenes.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/cameras-perspective-2-scenes.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Sur la gauche, vous pouvez voir la vue originale et sur la droite, vous pouvez
voir une vue montrant le frustum de la cam√©ra de gauche. Lorsque vous ajustez
<code class="notranslate" translate="no">near</code>, <code class="notranslate" translate="no">far</code>, <code class="notranslate" translate="no">fov</code> et d√©placez la cam√©ra avec la souris, vous pouvez voir que
seul ce qui se trouve √† l'int√©rieur du frustum montr√© √† droite appara√Æt dans la sc√®ne
√† gauche.</p>
<p>Ajustez <code class="notranslate" translate="no">near</code> jusqu'√† environ 20 et vous verrez facilement l'avant des objets
dispara√Ætre car ils ne sont plus dans le frustum. Ajustez <code class="notranslate" translate="no">far</code> en dessous d'environ 35
et vous commencerez √† voir le plan au sol dispara√Ætre car il n'est plus dans
le frustum.</p>
<p>Cela soul√®ve la question : pourquoi ne pas simplement r√©gler <code class="notranslate" translate="no">near</code> √† 0.0000000001 et <code class="notranslate" translate="no">far</code>
√† 10000000000000 ou quelque chose de similaire pour pouvoir tout voir ?
La raison est que votre GPU n'a qu'une certaine pr√©cision pour d√©cider si quelque chose
est devant ou derri√®re quelque chose d'autre. Cette pr√©cision est r√©partie entre
<code class="notranslate" translate="no">near</code> et <code class="notranslate" translate="no">far</code>. Pire, par d√©faut, la pr√©cision proche de la cam√©ra est d√©taill√©e
et la pr√©cision loin de la cam√©ra est grossi√®re. Les unit√©s commencent avec <code class="notranslate" translate="no">near</code>
et s'√©tendent lentement √† mesure qu'elles approchent <code class="notranslate" translate="no">far</code>.</p>
<p>En partant de l'exemple du haut, modifions le code pour ins√©rer 20 sph√®res √† la suite.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">{
  const sphereRadius = 3;
  const sphereWidthDivisions = 32;
  const sphereHeightDivisions = 16;
  const sphereGeo = new THREE.SphereGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
  const numSpheres = 20;
  for (let i = 0; i &lt; numSpheres; ++i) {
    const sphereMat = new THREE.MeshPhongMaterial();
    sphereMat.color.setHSL(i * .73, 1, 0.5);
    const mesh = new THREE.Mesh(sphereGeo, sphereMat);
    mesh.position.set(-sphereRadius - 1, sphereRadius + 2, i * sphereRadius * -2.2);
    scene.add(mesh);
  }
}
</pre>
<p>et r√©glons <code class="notranslate" translate="no">near</code> √† 0.00001</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const fov = 45;
const aspect = 2;  // the canvas default
-const near = 0.1;
+const near = 0.00001;
const far = 100;
const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
</pre>
<p>Nous devons √©galement l√©g√®rement ajuster le code de l'interface graphique pour permettre 0.00001 si la valeur est modifi√©e</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
+gui.add(minMaxGUIHelper, 'min', 0.00001, 50, 0.00001).name('near').onChange(updateCamera);
</pre>
<p>Que pensez-vous qu'il va se passer ?</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/cameras-z-fighting.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/cameras-z-fighting.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>C'est un exemple de <em>z fighting</em> (ou scintillement Z) o√π le GPU de votre ordinateur ne dispose pas
d'une pr√©cision suffisante pour d√©cider quels pixels sont devant et quels pixels sont derri√®re.</p>
<p>Juste au cas o√π le probl√®me n'appara√Ætrait pas sur votre machine, voici ce que je vois sur la mienne</p>
<div class="threejs_center"><img src="../resources/images/z-fighting.png" style="width: 570px;"></div>

<p>Une solution consiste √† dire √† three.js d'utiliser une m√©thode diff√©rente pour calculer quels
pixels sont devant et quels sont derri√®re. Nous pouvons le faire en activant
<code class="notranslate" translate="no">logarithmicDepthBuffer</code> lors de la cr√©ation du <a href="/docs/#api/en/renderers/WebGLRenderer"><code class="notranslate" translate="no">WebGLRenderer</code></a></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const renderer = new THREE.WebGLRenderer({antialias: true, canvas});
+const renderer = new THREE.WebGLRenderer({
+  antialias: true,
+  canvas,
+  logarithmicDepthBuffer: true,
+});
</pre>
<p>et avec cela, cela pourrait fonctionner</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/cameras-logarithmic-depth-buffer.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/cameras-logarithmic-depth-buffer.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Si cela n'a pas r√©solu le probl√®me pour vous, c'est que vous avez rencontr√© l'une des raisons pour lesquelles
vous ne pouvez pas toujours utiliser cette solution. Cette raison est que seuls certains GPU la
supportent. En septembre 2018, presque aucun appareil mobile ne supportait cette
solution, alors que la plupart des ordinateurs de bureau le faisaient.</p>
<p>Une autre raison de ne pas choisir cette solution est qu'elle peut √™tre significativement plus lente
que la solution standard.</p>
<p>M√™me avec cette solution, la r√©solution reste limit√©e. Diminuez encore <code class="notranslate" translate="no">near</code>
ou augmentez encore <code class="notranslate" translate="no">far</code> et vous finirez par rencontrer les m√™mes probl√®mes.</p>
<p>Cela signifie que vous devriez toujours vous efforcer de choisir un r√©glage <code class="notranslate" translate="no">near</code>
et <code class="notranslate" translate="no">far</code> qui correspond √† votre cas d'utilisation. R√©glez <code class="notranslate" translate="no">near</code> aussi loin de la cam√©ra
que possible sans que les √©l√©ments ne disparaissent. R√©glez <code class="notranslate" translate="no">far</code> aussi pr√®s de la cam√©ra
que possible sans que les √©l√©ments ne disparaissent. Si vous essayez de dessiner une sc√®ne immense
et de montrer un gros plan du visage de quelqu'un afin de voir ses cils
tandis qu'en arri√®re-plan, vous pouvez voir jusqu'aux montagnes √† 50 kilom√®tres
de distance, alors vous devrez trouver d'autres solutions cr√©atives
que nous aborderons peut-√™tre plus tard. Pour l'instant, sachez simplement que vous devez
faire attention √† choisir des valeurs <code class="notranslate" translate="no">near</code> et <code class="notranslate" translate="no">far</code> appropri√©es pour vos besoins.</p>
<p>La deuxi√®me cam√©ra la plus courante est l'<a href="/docs/#api/en/cameras/OrthographicCamera"><code class="notranslate" translate="no">OrthographicCamera</code></a>. Plut√¥t que
de sp√©cifier un frustum, elle sp√©cifie une bo√Æte avec les r√©glages <code class="notranslate" translate="no">left</code>, <code class="notranslate" translate="no">right</code>,
<code class="notranslate" translate="no">top</code>, <code class="notranslate" translate="no">bottom</code>, <code class="notranslate" translate="no">near</code> et <code class="notranslate" translate="no">far</code>. Parce qu'elle projette une bo√Æte,
il n'y a pas de perspective.</p>
<p>Modifions l'exemple √† 2 vues ci-dessus pour utiliser une <a href="/docs/#api/en/cameras/OrthographicCamera"><code class="notranslate" translate="no">OrthographicCamera</code></a>
dans la premi√®re vue.</p>
<p>Commen√ßons par configurer une <a href="/docs/#api/en/cameras/OrthographicCamera"><code class="notranslate" translate="no">OrthographicCamera</code></a>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const left = -1;
const right = 1;
const top = 1;
const bottom = -1;
const near = 5;
const far = 50;
const camera = new THREE.OrthographicCamera(left, right, top, bottom, near, far);
camera.zoom = 0.2;
</pre>
<p>Nous avons d√©fini <code class="notranslate" translate="no">left</code> et <code class="notranslate" translate="no">bottom</code> √† -1 et <code class="notranslate" translate="no">right</code> et <code class="notranslate" translate="no">top</code> √† 1. Cela cr√©erait
une bo√Æte de 2 unit√©s de large et 2 unit√©s de haut, mais nous allons ajuster <code class="notranslate" translate="no">left</code> et <code class="notranslate" translate="no">top</code>
en fonction de l'aspect du rectangle sur lequel nous dessinons. Nous allons utiliser la propri√©t√© <code class="notranslate" translate="no">zoom</code>
pour faciliter l'ajustement du nombre r√©el d'unit√©s affich√©es par la cam√©ra.</p>
<p>Ajoutons un r√©glage GUI pour <code class="notranslate" translate="no">zoom</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const gui = new GUI();
+gui.add(camera, 'zoom', 0.01, 1, 0.01).listen();
</pre>
<p>L'appel √† <code class="notranslate" translate="no">listen</code> indique √† lil-gui de surveiller les changements. Ceci est pr√©sent car
les <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate" translate="no">OrbitControls</code></a> peuvent √©galement contr√¥ler le zoom. Par exemple, la molette de d√©filement sur
une souris fera zoomer via les <a href="/docs/#examples/controls/OrbitControls"><code class="notranslate" translate="no">OrbitControls</code></a>.</p>
<p>Enfin, nous devons simplement modifier la partie qui rend le c√¥t√© gauche
pour mettre √† jour la <a href="/docs/#api/en/cameras/OrthographicCamera"><code class="notranslate" translate="no">OrthographicCamera</code></a>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">{
  const aspect = setScissorForElement(view1Elem);

  // mettre √† jour la cam√©ra pour cet aspect
-  camera.aspect = aspect;
+  camera.left   = -aspect;
+  camera.right  =  aspect;
  camera.updateProjectionMatrix();
  cameraHelper.update();

  // ne pas dessiner le camera helper dans la vue originale
  cameraHelper.visible = false;

  scene.background.set(0x000000);
  renderer.render(scene, camera);
}
</pre>
<p>et maintenant vous pouvez voir une <a href="/docs/#api/en/cameras/OrthographicCamera"><code class="notranslate" translate="no">OrthographicCamera</code></a> √† l'≈ìuvre.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/cameras-orthographic-2-scenes.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/cameras-orthographic-2-scenes.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Une autre utilisation courante d'une <a href="/docs/#api/en/cameras/OrthographicCamera"><code class="notranslate" translate="no">OrthographicCamera</code></a> est de dessiner les
vues du haut, du bas, de gauche, de droite, de face et de dos d'un programme de mod√©lisation 3D
ou de l'√©diteur d'un moteur de jeu.</p>
<div class="threejs_center"><img src="../resources/images/quad-viewport.png" style="width: 574px;"></div>

<p>Dans la capture d'√©cran ci-dessus, vous pouvez voir qu'une vue est une vue en perspective et 3 vues sont
des vues orthographiques.</p>
<p>Voil√† les bases des cam√©ras. Nous aborderons quelques fa√ßons courantes de d√©placer les cam√©ras
dans d'autres articles. Pour l'instant, passons aux <a href="shadows.html">ombres</a>.</p>
<p><canvas id="c"></canvas></p>
<script type="module" src="../resources/threejs-cameras.js"></script>

        </div>
      </div>
    </div>

  <script src="../resources/prettify.js"></script>
  <script src="../resources/lesson.js"></script>




</body></html>