<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <title>Créer un Jeu</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@threejs">
    <meta name="twitter:title" content="Three.js – Créer un Jeu">
    <meta property="og:image" content="https://threejs.org/files/share.png">
    <link rel="shortcut icon" href="../../files/favicon_white.ico" media="(prefers-color-scheme: dark)">
    <link rel="shortcut icon" href="../../files/favicon.ico" media="(prefers-color-scheme: light)">

    <link rel="stylesheet" href="../resources/lesson.css">
    <link rel="stylesheet" href="../resources/lang.css">
<script type="importmap">
{
  "imports": {
    "three": "../../build/three.module.js"
  }
}
</script>
  </head>
  <body>
    <div class="container">
      <div class="lesson-title">
        <h1>Créer un Jeu</h1>
      </div>
      <div class="lesson">
        <div class="lesson-main">
          <p>Beaucoup de gens veulent écrire des jeux en utilisant three.js. Cet article,
espérons-le, vous donnera quelques idées sur la façon de commencer.</p>
<p>Du moins au moment où j'écris cet article, il s'agira probablement de
l'article le plus long de ce site. Il est possible que le code ici soit massivement sur-
conçu, mais au fur et à mesure que j'écrivais chaque nouvelle fonctionnalité, je rencontrais un problème qui nécessitait une
solution à laquelle je suis habitué d'autres jeux que j'ai écrits. En d'autres termes, chaque nouvelle
solution semblait importante, j'essaierai donc de montrer pourquoi. Bien sûr, plus votre
jeu est petit, moins vous pourriez avoir besoin de certaines des solutions présentées ici, mais il s'agit d'un
assez petit jeu et pourtant, avec les complexités des personnages 3D, beaucoup de choses
nécessitent plus d'organisation qu'avec des personnages 2D.</p>
<p>À titre d'exemple, si vous créez PacMan en 2D, lorsque PacMan tourne un coin,
cela se produit instantanément à 90 degrés. Il n'y a pas d'étape intermédiaire. Mais
dans un jeu 3D, nous devons souvent que le personnage tourne sur plusieurs images.
Ce simple changement peut ajouter beaucoup de complexité et nécessiter différentes
solutions.</p>
<p>La majorité du code ici ne sera pas vraiment du three.js et
il est important de noter que <strong>three.js n'est pas un moteur de jeu</strong>.
Three.js est une bibliothèque 3D. Elle fournit un <a href="scenegraph.html">graphe de scène</a>
et des fonctionnalités pour afficher des objets 3D ajoutés à ce graphe de scène,
mais elle ne fournit pas toutes les autres choses nécessaires pour faire un jeu.
Pas de collisions, pas de physique, pas de systèmes d'entrée, pas de recherche de chemin, etc, etc...
Donc, nous devrons fournir ces choses nous-mêmes.</p>
<p>J'ai fini par écrire pas mal de code pour faire cette chose de jeu simple, <em>inachevée</em>,
et encore une fois, il est certainement possible que j'aie sur-conçu et qu'il existe
des solutions plus simples, mais j'ai l'impression de ne pas avoir écrit
assez de code et, espérons-le, je peux expliquer ce qui, selon moi, manque.</p>
<p>Beaucoup des idées ici sont fortement influencées par <a href="https://unity.com">Unity</a>.
Si vous n'êtes pas familier avec Unity, cela n'a probablement pas d'importance.
Je le mentionne uniquement car des dizaines de milliers de jeux ont été livrés en utilisant
ces idées.</p>
<p>Commençons par les parties three.js. Nous devons charger des modèles pour notre jeu.</p>
<p>Sur <a href="https://opengameart.org">opengameart.org</a> j'ai trouvé ce <a href="https://opengameart.org/content/lowpoly-animated-knight">modèle de chevalier animé</a>
par <a href="https://opengameart.org/users/quaternius">quaternius</a></p>
<div class="threejs_center"><img src="../resources/images/knight.jpg" style="width: 375px;"></div>

<p><a href="https://opengameart.org/users/quaternius">quaternius</a> a également créé <a href="https://opengameart.org/content/lowpoly-animated-farm-animal-pack">ces animaux animés</a>.</p>
<div class="threejs_center"><img src="../resources/images/animals.jpg" style="width: 606px;"></div>

<p>Ceux-ci semblent être de bons modèles pour commencer, donc la première chose que nous devons
faire est de les charger.</p>
<p>Nous avons abordé le <a href="load-gltf.html">chargement de fichiers glTF auparavant</a>.
La différence cette fois est que nous devons charger plusieurs modèles et
que nous ne pouvons pas démarrer le jeu tant que tous les modèles ne sont pas chargés.</p>
<p>Heureusement, three.js fournit le <a href="/docs/#api/en/loaders/managers/LoadingManager"><code class="notranslate" translate="no">LoadingManager</code></a> juste à cette fin.
Nous créons un <a href="/docs/#api/en/loaders/managers/LoadingManager"><code class="notranslate" translate="no">LoadingManager</code></a> et le passons aux autres chargeurs. Le
<a href="/docs/#api/en/loaders/managers/LoadingManager"><code class="notranslate" translate="no">LoadingManager</code></a> fournit à la fois les propriétés <a href="/docs/#api/en/loaders/managers/LoadingManager#onProgress"><code class="notranslate" translate="no">onProgress</code></a> et
<a href="/docs/#api/en/loaders/managers/LoadingManager#onLoad"><code class="notranslate" translate="no">onLoad</code> auxquelles nous pouvons attacher des rappels.
Le rappel <a href="/docs/#api/en/loaders/managers/LoadingManager#onLoad"><code class="notranslate" translate="no">onLoad</code></a> sera appelé lorsque
tous les fichiers auront été chargés. Le rappel <a href="/docs/#api/en/loaders/managers/LoadingManager#onProgress"><code class="notranslate" translate="no">onProgress</code></a>
est appelé après l'arrivée de chaque fichier individuel pour nous donner une chance de montrer
la progression du chargement.</p>
<p>En partant du code de <a href="load-gltf.html">chargement d'un fichier glTF</a>, j'ai supprimé tout
le code lié au cadrage de la scène et ajouté ce code pour charger tous les modèles.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const manager = new THREE.LoadingManager();
manager.onLoad = init;
const models = {
  pig:    { url: 'resources/models/animals/Pig.gltf' },
  cow:    { url: 'resources/models/animals/Cow.gltf' },
  llama:  { url: 'resources/models/animals/Llama.gltf' },
  pug:    { url: 'resources/models/animals/Pug.gltf' },
  sheep:  { url: 'resources/models/animals/Sheep.gltf' },
  zebra:  { url: 'resources/models/animals/Zebra.gltf' },
  horse:  { url: 'resources/models/animals/Horse.gltf' },
  knight: { url: 'resources/models/knight/KnightCharacter.gltf' },
};
{
  const gltfLoader = new GLTFLoader(manager);
  for (const model of Object.values(models)) {
    gltfLoader.load(model.url, (gltf) =&gt; {
      model.gltf = gltf;
    });
  }
}

function init() {
  // TBD
}
</pre>
<p>Ce code chargera tous les modèles ci-dessus et le <a href="/docs/#api/en/loaders/managers/LoadingManager"><code class="notranslate" translate="no">LoadingManager</code></a> appellera
<code class="notranslate" translate="no">init</code> une fois terminé. Nous utiliserons l'objet <code class="notranslate" translate="no">models</code> plus tard pour nous permettre d'accéder aux
modèles chargés, de sorte que le rappel <a href="/docs/#examples/loaders/GLTFLoader"><code class="notranslate" translate="no">GLTFLoader</code></a> pour chaque modèle individuel attache
les données chargées aux informations de ce modèle.</p>
<p>Tous les modèles avec toutes leurs animations font actuellement environ 6,6 Mo. C'est un
téléchargement assez important. En supposant que votre serveur prenne en charge la compression (le serveur sur lequel
ce site tourne la prend en charge), il est capable de les compresser à environ 1,4 Mo. C'est
certainement mieux que 6,6 Mo mais ce n'est toujours pas une petite quantité de données. Il serait
probablement bon d'ajouter une barre de progression pour que l'utilisateur ait une idée du temps
qu'il lui reste à attendre.</p>
<p>Alors, ajoutons un rappel <a href="/docs/#api/en/loaders/managers/LoadingManager#onProgress"><code class="notranslate" translate="no">onProgress</code></a>. Il sera
appelé avec 3 arguments : l'<code class="notranslate" translate="no">url</code> du dernier objet chargé, puis le nombre
d'éléments chargés jusqu'à présent ainsi que le nombre total d'éléments.</p>
<p>Mettons en place du HTML pour une barre de chargement</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;body&gt;
  &lt;canvas id="c"&gt;&lt;/canvas&gt;
+  &lt;div id="loading"&gt;
+    &lt;div&gt;
+      &lt;div&gt;...chargement...&lt;/div&gt;
+      &lt;div class="progress"&gt;&lt;div id="progressbar"&gt;&lt;/div&gt;&lt;/div&gt;
+    &lt;/div&gt;
+  &lt;/div&gt;
&lt;/body&gt;
</pre>
<p>Nous allons rechercher le div <code class="notranslate" translate="no">#progressbar</code> et nous pourrons définir la largeur de 0% à 100%
pour montrer notre progression. Tout ce que nous devons faire est de le définir dans notre rappel.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const manager = new THREE.LoadingManager();
manager.onLoad = init;

+const progressbarElem = document.querySelector('#progressbar');
+manager.onProgress = (url, itemsLoaded, itemsTotal) =&gt; {
+  progressbarElem.style.width = `${itemsLoaded / itemsTotal * 100 | 0}%`;
+};
</pre>
<p>Nous avons déjà configuré <code class="notranslate" translate="no">init</code> pour être appelé lorsque tous les modèles sont chargés, donc
nous pouvons désactiver la barre de progression en masquant l'élément <code class="notranslate" translate="no">#loading</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function init() {
+  // cacher la barre de chargement
+  const loadingElem = document.querySelector('#loading');
+  loadingElem.style.display = 'none';
}
</pre>
<p>Voici un tas de CSS pour styliser la barre. Le CSS fait que le <code class="notranslate" translate="no">&lt;div&gt;</code> <code class="notranslate" translate="no">#loading</code>
occupe toute la page et centre ses enfants. Le CSS crée une zone <code class="notranslate" translate="no">.progress</code>
pour contenir la barre de progression. Le CSS donne également à la barre de progression
une animation CSS de rayures diagonales.</p>
<pre class="prettyprint showlinemods notranslate lang-css" translate="no">#loading {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  font-size: xx-large;
  font-family: sans-serif;
}
#loading&gt;div&gt;div {
  padding: 2px;
}
.progress {
  width: 50vw;
  border: 1px solid black;
}
#progressbar {
  width: 0;
  transition: width ease-out .5s;
  height: 1em;
  background-color: #888;
  background-image: linear-gradient(
    -45deg,
    rgba(255, 255, 255, .5) 25%,
    transparent 25%,
    transparent 50%,
    rgba(255, 255, 255, .5) 50%,
    rgba(255, 255, 255, .5) 75%,
    transparent 75%,
    transparent
  );
  background-size: 50px 50px;
  animation: progressanim 2s linear infinite;
}

@keyframes progressanim {
  0% {
    background-position: 50px 50px;
  }
  100% {
    background-position: 0 0;
  }
}
</pre>
<p>Maintenant que nous avons une barre de progression, occupons-nous des modèles. Ces modèles
ont des animations et nous voulons pouvoir accéder à ces animations.
Les animations sont stockées dans un tableau par défaut, mais nous aimerions pouvoir
y accéder facilement par leur nom. Configurons donc une propriété <code class="notranslate" translate="no">animations</code> pour
chaque modèle afin de faire cela. Notez bien sûr que cela signifie que les animations doivent avoir des noms uniques.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+function prepModelsAndAnimations() {
+  Object.values(models).forEach(model =&gt; {
+    const animsByName = {};
+    model.gltf.animations.forEach((clip) =&gt; {
+      animsByName[clip.name] = clip;
+    });
+    model.animations = animsByName;
+  });
+}

function init() {
  // cacher la barre de chargement
  const loadingElem = document.querySelector('#loading');
  loadingElem.style.display = 'none';

+  prepModelsAndAnimations();
}
</pre>
<p>Affichons les modèles animés.</p>
<p>Contrairement à l'<a href="load-gltf.html">exemple précédent de chargement d'un fichier glTF</a>,
cette fois-ci, nous voulons probablement pouvoir afficher plus d'une instance
de chaque modèle. Pour ce faire, au lieu d'ajouter
la scène gltf chargée directement comme nous l'avons fait dans <a href="load-gltf.html">l'article sur le chargement d'un glTF</a>,
nous voulons plutôt cloner la scène, et en particulier, nous voulons la cloner
pour les personnages animés skinnés. Heureusement, il existe une fonction utilitaire,
<code class="notranslate" translate="no">SkeletonUtils.clone</code>, que nous pouvons utiliser pour cela. Nous devons donc d'abord inclure
les utilitaires.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">import * as THREE from 'three';
import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
+import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
</pre>
<p>Ensuite, nous pouvons cloner les modèles que nous venons de charger</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function init() {
  // cacher la barre de chargement
  const loadingElem = document.querySelector('#loading');
  loadingElem.style.display = 'none';

  prepModelsAndAnimations();

+  Object.values(models).forEach((model, ndx) =&gt; {
+    const clonedScene = SkeletonUtils.clone(model.gltf.scene);
+    const root = new THREE.Object3D();
+    root.add(clonedScene);
+    scene.add(root);
+    root.position.x = (ndx - 3) * 3;
+  });
}
</pre>
<p>Ci-dessus, pour chaque modèle, nous clonons la <code class="notranslate" translate="no">gltf.scene</code> que nous avons chargée et nous la parentons
à un nouveau <a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a>. Nous devons la parentar à un autre objet car lorsque
nous jouons des animations, l'animation appliquera des positions animées aux nœuds
de la scène chargée, ce qui signifie que nous n'aurons pas le contrôle sur ces positions.</p>
<p>Pour lire les animations, chaque modèle que nous clonons a besoin d'un <a href="/docs/#api/en/animation/AnimationMixer"><code class="notranslate" translate="no">AnimationMixer</code></a>.
Un <a href="/docs/#api/en/animation/AnimationMixer"><code class="notranslate" translate="no">AnimationMixer</code></a> contient 1 ou plusieurs <a href="/docs/#api/en/animation/AnimationAction"><code class="notranslate" translate="no">AnimationAction</code></a>s. Une
<a href="/docs/#api/en/animation/AnimationAction"><code class="notranslate" translate="no">AnimationAction</code></a> référence un <a href="/docs/#api/en/animation/AnimationClip"><code class="notranslate" translate="no">AnimationClip</code></a>. Les <a href="/docs/#api/en/animation/AnimationAction"><code class="notranslate" translate="no">AnimationAction</code></a>s
ont toutes sortes de paramètres pour les lire, puis les enchaîner à une autre
action ou faire des fondus enchaînés entre les actions. Obtenons simplement la première
<a href="/docs/#api/en/animation/AnimationClip"><code class="notranslate" translate="no">AnimationClip</code></a> et créons une action pour elle. Par défaut, une
action joue son clip en boucle pour toujours.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const mixers = [];

function init() {
  // cacher la barre de chargement
  const loadingElem = document.querySelector('#loading');
  loadingElem.style.display = 'none';

  prepModelsAndAnimations();

  Object.values(models).forEach((model, ndx) =&gt; {
    const clonedScene = SkeletonUtils.clone(model.gltf.scene);
    const root = new THREE.Object3D();
    root.add(clonedScene);
    scene.add(root);
    root.position.x = (ndx - 3) * 3;

+    const mixer = new THREE.AnimationMixer(clonedScene);
+    const firstClip = Object.values(model.animations)[0];
+    const action = mixer.clipAction(firstClip);
+    action.play();
+    mixers.push(mixer);
  });
}
</pre>
<p>Nous avons appelé <a href="/docs/#api/en/animation/AnimationAction#play"><code class="notranslate" translate="no">play</code></a> pour démarrer l'action et avons stocké
tous les <code class="notranslate" translate="no">AnimationMixers</code> dans un tableau appelé <code class="notranslate" translate="no">mixers</code>. Enfin,
nous devons mettre à jour chaque <a href="/docs/#api/en/animation/AnimationMixer"><code class="notranslate" translate="no">AnimationMixer</code></a> dans notre boucle de rendu en calculant
le temps écoulé depuis la dernière image et en le passant à <a href="/docs/#api/en/animation/AnimationMixer.update"><code class="notranslate" translate="no">AnimationMixer.update</code></a>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+let then = 0;
function render(now) {
+  now *= 0.001;  // convertir en secondes
+  const deltaTime = now - then;
+  then = now;

  if (resizeRendererToDisplaySize(renderer)) {
    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }

+  for (const mixer of mixers) {
+    mixer.update(deltaTime);
+  }

  renderer.render(scene, camera);

  requestAnimationFrame(render);
}
</pre>
<p>Et avec cela, nous devrions obtenir chaque modèle chargé et jouant sa première animation.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/game-load-models.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/game-load-models.html" target="_blank">cliquez ici pour ouvrir dans une fenêtre séparée</a>
</div>

<p></p>
<p>Faisons en sorte que nous puissions vérifier toutes les animations.
Nous allons ajouter tous les clips en tant qu'actions, puis n'en activer qu'un seul
à la fois.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const mixers = [];
+const mixerInfos = [];

function init() {
  // cacher la barre de chargement
  const loadingElem = document.querySelector('#loading');
  loadingElem.style.display = 'none';

  prepModelsAndAnimations();

  Object.values(models).forEach((model, ndx) =&gt; {
    const clonedScene = SkeletonUtils.clone(model.gltf.scene);
    const root = new THREE.Object3D();
    root.add(clonedScene);
    scene.add(root);
    root.position.x = (ndx - 3) * 3;

    const mixer = new THREE.AnimationMixer(clonedScene);
-    const firstClip = Object.values(model.animations)[0];
-    const action = mixer.clipAction(firstClip);
-    action.play();
-    mixers.push(mixer);
+    const actions = Object.values(model.animations).map((clip) =&gt; {
+      return mixer.clipAction(clip);
+    });
+    const mixerInfo = {
+      mixer,
+      actions,
+      actionNdx: -1,
+    };
+    mixerInfos.push(mixerInfo);
+    playNextAction(mixerInfo);
  });
}

+function playNextAction(mixerInfo) {
+  const {actions, actionNdx} = mixerInfo;
+  const nextActionNdx = (actionNdx + 1) % actions.length;
+  mixerInfo.actionNdx = nextActionNdx;
+  actions.forEach((action, ndx) =&gt; {
+    const enabled = ndx === nextActionNdx;
+    action.enabled = enabled;
+    if (enabled) {
+      action.play();
+    }
+  });
+}
</pre>
<p>Le code ci-dessus crée un tableau d'<a href="/docs/#api/en/animation/AnimationAction"><code class="notranslate" translate="no">AnimationAction</code></a>s,
une pour chaque <a href="/docs/#api/en/animation/AnimationClip"><code class="notranslate" translate="no">AnimationClip</code></a>. Il crée un tableau d'objets, <code class="notranslate" translate="no">mixerInfos</code>,
avec des références à l'<a href="/docs/#api/en/animation/AnimationMixer"><code class="notranslate" translate="no">AnimationMixer</code></a> et à toutes les <a href="/docs/#api/en/animation/AnimationAction"><code class="notranslate" translate="no">AnimationAction</code></a>s
pour chaque modèle. Il appelle ensuite <code class="notranslate" translate="no">playNextAction</code> qui définit <code class="notranslate" translate="no">enabled</code> sur
toutes les actions sauf une pour ce mélangeur.</p>
<p>Nous devons mettre à jour la boucle de rendu pour le nouveau tableau</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-for (const mixer of mixers) {
+for (const {mixer} of mixerInfos) {
  mixer.update(deltaTime);
}
</pre>
<p>Faisons en sorte que l'appui sur une touche de 1 à 8 joue l'animation suivante
pour chaque modèle.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">window.addEventListener('keydown', (e) =&gt; {
  const mixerInfo = mixerInfos[e.keyCode - 49];
  if (!mixerInfo) {
    return;
  }
  playNextAction(mixerInfo);
});
</pre>
<p>Maintenant, vous devriez pouvoir cliquer sur l'exemple, puis appuyer sur les touches 1 à 8
pour faire passer chacun des modèles à travers leurs animations disponibles.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/game-check-animations.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/game-check-animations.html" target="_blank">cliquez ici pour ouvrir dans une fenêtre séparée</a>
</div>

<p></p>
<p>C'est, sans doute, l'essentiel de la partie three.js de cet
article. Nous avons couvert le chargement de plusieurs fichiers, le clonage de modèles skinnés,
et la lecture d'animations sur ceux-ci. Dans un vrai jeu, vous auriez
beaucoup plus de manipulations d'objets <a href="/docs/#api/en/animation/AnimationAction"><code class="notranslate" translate="no">AnimationAction</code></a> à faire.</p>
<p>Commençons à construire une infrastructure de jeu.</p>
<p>Un modèle courant pour créer un jeu moderne est d'utiliser un
<a href="https://www.google.com/search?q=entity+component+system">Système Entité-Composant</a>.
Dans un Système Entité-Composant, un objet dans un jeu est appelé une <em>entité</em> qui se compose
d'un ensemble de <em>composants</em>. Vous construisez des entités en décidant quels composants leur
attacher. Alors, créons un Système Entité-Composant.</p>
<p>Nous appellerons nos entités <code class="notranslate" translate="no">GameObject</code>. Il s'agit effectivement juste d'une collection
de composants et d'un <a href="/docs/#api/en/core/Object3D"><code class="notranslate" translate="no">Object3D</code></a> three.js.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function removeArrayElement(array, element) {
  const ndx = array.indexOf(element);
  if (ndx &gt;= 0) {
    array.splice(ndx, 1);
  }
}

class GameObject {
  constructor(parent, name) {
    this.name = name;
    this.components = [];
    this.transform = new THREE.Object3D();
    parent.add(this.transform);
  }
  addComponent(ComponentType, ...args) {
    const component = new ComponentType(this, ...args);
    this.components.push(component);
    return component;
  }
  removeComponent(component) {
    removeArrayElement(this.components, component);
  }
  getComponent(ComponentType) {
    return this.components.find(c =&gt; c instanceof ComponentType);
  }
  update() {
    for (const component of this.components) {
      component.update();
    }
  }
}
</pre>
<p>Appeler <code class="notranslate" translate="no">GameObject.update</code> appelle <code class="notranslate" translate="no">update</code> sur tous les composants.</p>
<p>J'ai inclus un nom uniquement pour aider au débogage afin que si je regarde un <code class="notranslate" translate="no">GameObject</code>
dans le débogueur, je puisse voir un nom pour m'aider à l'identifier.</p>
<p>Certaines choses qui peuvent sembler un peu étranges :</p>
<p><code class="notranslate" translate="no">GameObject.addComponent</code> est utilisé pour créer des composants. Je ne suis pas sûr si
c'est une bonne ou une mauvaise idée. Mon idée était qu'il n'est pas logique qu'un composant existe en dehors d'un gameobject, alors j'ai pensé
qu'il pourrait être bon que la création d'un composant ajoute automatiquement ce composant
au gameobject et passe le gameobject au constructeur du composant.
En d'autres termes, pour ajouter un composant, vous faites ceci</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const gameObject = new GameObject(scene, 'foo');
gameObject.addComponent(TypeOfComponent);
</pre>
<p>Si je ne l'avais pas fait de cette façon, vous feriez plutôt quelque chose comme ça</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const gameObject = new GameObject(scene, 'foo');
const component = new TypeOfComponent(gameObject);
gameObject.addComponent(component);
</pre>
<p>Est-ce mieux que la première méthode soit plus courte et plus automatisée ou est-ce pire
parce qu'elle semble inhabituelle ? Je ne sais pas.</p>
<p><code class="notranslate" translate="no">GameObject.getComponent</code> recherche les composants par type. Cela a
l'implication que vous ne pouvez pas avoir 2 composants du même
type sur un seul game object, ou du moins si vous le faites, vous ne pouvez rechercher
que le premier sans ajouter une autre API.</p>
<p>Il est courant qu'un composant en recherche un autre, et lors de la recherche, ils
doivent correspondre par type, sinon vous pourriez obtenir le mauvais. Nous pourrions
donner à chaque composant un nom et vous pourriez les rechercher par leur nom. Cela
serait plus flexible car vous pourriez avoir plusieurs composants du même type, mais ce
serait également plus fastidieux. Encore une fois, je ne suis pas sûr de ce qui est le mieux.</p>
<p>Passons aux composants eux-mêmes. Voici leur classe de base.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// Base pour tous les composants
class Component {
  constructor(gameObject) {
    this.gameObject = gameObject;
  }
  update() {
  }
}
</pre>
<p>Les composants ont-ils besoin d'une classe de base ? JavaScript n'est pas comme la plupart des langages
strictement typés, donc en fait, nous pourrions ne pas avoir de classe de base et
laisser simplement chaque composant faire ce qu'il veut dans son constructeur
sachant que le premier argument est toujours le gameobject du composant.
S'il ne se soucie pas du gameobject, il ne le stockerait pas. Je pense quand même que cette
base commune est bonne. Cela signifie que si vous avez une référence à un
composant, vous savez que vous pouvez toujours trouver son gameobject parent et à partir de son
parent, vous pouvez facilement rechercher d'autres composants ainsi que regarder sa
transformation.</p>
<p>Pour gérer les gameobjects, nous avons probablement besoin d'une sorte de gestionnaire de gameobjects. Vous
pourriez penser que nous pourrions simplement garder un tableau de gameobjects, mais dans un vrai jeu, les
composants d'un gameobject pourraient ajouter et supprimer d'autres gameobjects au moment de l'exécution.
Par exemple, un gameobject de pistolet pourrait ajouter un gameobject de balle chaque fois que le pistolet
tire. Un gameobject de monstre pourrait se retirer s'il a été tué. Nous aurions alors
un problème où nous pourrions avoir du code comme ceci</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">for (const gameObject of globalArrayOfGameObjects) {
  gameObject.update();
}
</pre>
<p>La boucle ci-dessus échouerait ou ferait des choses imprévues si
des gameobjects sont ajoutés ou supprimés de <code class="notranslate" translate="no">globalArrayOfGameObjects</code>
au milieu de la boucle dans la fonction <code class="notranslate" translate="no">update</code> d'un composant.</p>
<p>Pour tenter de prévenir ce problème, nous avons besoin de quelque chose d'un peu plus sûr.
Voici une tentative.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class SafeArray {
  constructor() {
    this.array = [];
    this.addQueue = [];
    this.removeQueue = new Set();
  }
  get isEmpty() {
    return this.addQueue.length + this.array.length &gt; 0;
  }
  add(element) {
    this.addQueue.push(element);
  }
  remove(element) {
    this.removeQueue.add(element);
  }
  forEach(fn) {
    this._addQueued();
    this._removeQueued();
    for (const element of this.array) {
      if (this.removeQueue.has(element)) {
        continue;
      }
      fn(element);
    }
    this._removeQueued();
  }
  _addQueued() {
    if (this.addQueue.length) {
      this.array.splice(this.array.length, 0, ...this.addQueue);
      this.addQueue = [];
    }
  }
  _removeQueued() {
    if (this.removeQueue.size) {
      this.array = this.array.filter(element =&gt; !this.removeQueue.has(element));
      this.removeQueue.clear();
    }
  }
}
</pre>
<p>La classe ci-dessus vous permet d'ajouter ou de supprimer des éléments du <code class="notranslate" translate="no">SafeArray</code>
mais ne modifiera pas le tableau lui-même pendant qu'il est parcouru. Au lieu de cela,
les nouveaux éléments sont ajoutés à <code class="notranslate" translate="no">addQueue</code> et les éléments supprimés à la <code class="notranslate" translate="no">removeQueue</code>,
puis ajoutés ou supprimés en dehors de la boucle.</p>
<p>En utilisant cela, voici notre classe pour gérer les gameobjects.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class GameObjectManager {
  constructor() {
    this.gameObjects = new SafeArray();
  }
  createGameObject(parent, name) {
    const gameObject = new GameObject(parent, name);
    this.gameObjects.add(gameObject);
    return gameObject;
  }
  removeGameObject(gameObject) {
    this.gameObjects.remove(gameObject);
  }
  update() {
    this.gameObjects.forEach(gameObject =&gt; gameObject.update());
  }
}
</pre>
<p>Avec tout cela, créons maintenant notre premier composant. Ce composant
gérera simplement un objet three.js skinné comme ceux que nous venons de créer.
Pour simplifier, il n'aura qu'une seule méthode, <code class="notranslate" translate="no">setAnimation</code>, qui
prend le nom de l'animation à lire et la lance.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class SkinInstance extends Component {
  constructor(gameObject, model) {
    super(gameObject);
    this.model = model;
    this.animRoot = SkeletonUtils.clone(this.model.gltf.scene);
    this.mixer = new THREE.AnimationMixer(this.animRoot);
    gameObject.transform.add(this.animRoot);
    this.actions = {};
  }
  setAnimation(animName) {
    const clip = this.model.animations[animName];
    // désactiver toutes les actions actuelles
    for (const action of Object.values(this.actions)) {
      action.enabled = false;
    }
    // obtenir ou créer une action existante pour le clip
    const action = this.mixer.clipAction(clip);
    action.enabled = true;
    action.reset();
    action.play();
    this.actions[animName] = action;
  }
  update() {
    this.mixer.update(globals.deltaTime);
  }
}
</pre>
<p>Vous pouvez voir que c'est essentiellement le code que nous avions auparavant qui clone la scène que nous avons chargée,
puis configure un <a href="/docs/#api/en/animation/AnimationMixer"><code class="notranslate" translate="no">AnimationMixer</code></a>. <code class="notranslate" translate="no">setAnimation</code> ajoute une <a href="/docs/#api/en/animation/AnimationAction"><code class="notranslate" translate="no">AnimationAction</code></a> pour un
<a href="/docs/#api/en/animation/AnimationClip"><code class="notranslate" translate="no">AnimationClip</code></a> particulier s'il n'existe pas déjà, et désactive toutes
les actions existantes.</p>
<p>Le code référence <code class="notranslate" translate="no">globals.deltaTime</code>. Créons un objet globals</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const globals = {
  time: 0,
  deltaTime: 0,
};
</pre>
<p>Et mettez-le à jour dans la boucle de rendu</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">let then = 0;
function render(now) {
  // convertir en secondes
  globals.time = now * 0.001;
  // s'assurer que le temps delta n'est pas trop grand.
  globals.deltaTime = Math.min(globals.time - then, 1 / 20);
  then = globals.time;
</pre>
<p>La vérification ci-dessus pour s'assurer que <code class="notranslate" translate="no">deltaTime</code> n'est pas supérieure à 1/20e
de seconde est due au fait que sinon, nous obtiendrions une valeur énorme pour <code class="notranslate" translate="no">deltaTime</code>
si nous masquons l'onglet. Nous pourrions le masquer pendant des secondes ou des minutes, puis
lorsque notre onglet serait ramené au premier plan, <code class="notranslate" translate="no">deltaTime</code> serait énorme
et pourrait téléporter des personnages à travers notre monde de jeu si nous avions du code comme</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">position += velocity * deltaTime;
</pre>
<p>En limitant le <code class="notranslate" translate="no">deltaTime</code> maximum, ce problème est évité.</p>
<p>Maintenant, créons un composant pour le joueur.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class Player extends Component {
  constructor(gameObject) {
    super(gameObject);
    const model = models.knight;
    this.skinInstance = gameObject.addComponent(SkinInstance, model);
    this.skinInstance.setAnimation('Run');
  }
}
</pre>
<p>Le joueur appelle <code class="notranslate" translate="no">setAnimation</code> avec <code class="notranslate" translate="no">'Run'</code>. Pour savoir quelles animations
sont disponibles, j'ai modifié notre exemple précédent pour imprimer les noms des
animations.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function prepModelsAndAnimations() {
  Object.values(models).forEach(model =&gt; {
+    console.log('-------&gt;:', model.url);
    const animsByName = {};
    model.gltf.animations.forEach((clip) =&gt; {
      animsByName[clip.name] = clip;
+      console.log('  ', clip.name);
    });
    model.animations = animsByName;
  });
}
</pre>
<p>Et l'exécuter a donné cette liste dans <a href="https://developers.google.com/web/tools/chrome-devtools/console/javascript">la console JavaScript</a>.</p>
<pre class="prettyprint showlinemods notranslate notranslate" translate="no"> -------&gt;:  resources/models/animals/Pig.gltf
    Idle
    Death
    WalkSlow
    Jump
    Walk
 -------&gt;:  resources/models/animals/Cow.gltf
    Walk
    Jump
    WalkSlow
    Death
    Idle
 -------&gt;:  resources/models/animals/Llama.gltf
    Jump
    Idle
    Walk
    Death
    WalkSlow
 -------&gt;:  resources/models/animals/Pug.gltf
    Jump
    Walk
    Idle
    WalkSlow
    Death
 -------&gt;:  resources/models/animals/Sheep.gltf
    WalkSlow
    Death
    Jump
    Walk
    Idle
 -------&gt;:  resources/models/animals/Zebra.gltf
    Jump
    Walk
    Death
    WalkSlow
    Idle
 -------&gt;:  resources/models/animals/Horse.gltf
    Jump
    WalkSlow
    Death
    Walk
    Idle
 -------&gt;:  resources/models/knight/KnightCharacter.gltf
    Run_swordRight
    Run
    Idle_swordLeft
    Roll_sword
    Idle
    Run_swordAttack
</pre><p>Heureusement, les noms des animations pour tous les animaux correspondent,
ce qui sera utile plus tard. Pour l'instant, nous nous soucions seulement que le
joueur ait une animation appelée <code class="notranslate" translate="no">Run</code>.</p>
<p>Utilisons ces composants. Voici la fonction init mise à jour.
Tout ce qu'elle fait est de créer un <code class="notranslate" translate="no">GameObject</code> et d'y ajouter un composant <code class="notranslate" translate="no">Player</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const globals = {
  time: 0,
  deltaTime: 0,
};
+const gameObjectManager = new GameObjectManager();

function init() {
  // cacher la barre de chargement
  const loadingElem = document.querySelector('#loading');
  loadingElem.style.display = 'none';

  prepModelsAndAnimations();

+  {
+    const gameObject = gameObjectManager.createGameObject(scene, 'player');
+    gameObject.addComponent(Player);
+  }
}
</pre>
<p>Et nous devons appeler <code class="notranslate" translate="no">gameObjectManager.update</code> dans notre boucle de rendu.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">let then = 0;
function render(now) {
  // convertir en secondes
  globals.time = now * 0.001;
  // s'assurer que le temps delta n'est pas trop grand.
  globals.deltaTime = Math.min(globals.time - then, 1 / 20);
  then = globals.time;

  if (resizeRendererToDisplaySize(renderer)) {
    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }

-  for (const {mixer} of mixerInfos) {
-    mixer.update(deltaTime);
-  }
+  gameObjectManager.update();

  renderer.render(scene, camera);

  requestAnimationFrame(render);
}
</pre>
<p>et si nous exécutons cela, nous obtenons un seul joueur.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/game-just-player.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/game-just-player.html" target="_blank">cliquez ici pour ouvrir dans une fenêtre séparée</a>
</div>

<p></p>
<p>Cela représentait beaucoup de code juste pour un système entité-composant, mais
c'est une infrastructure dont la plupart des jeux ont besoin.</p>
<p>Ajoutons un système d'entrée. Plutôt que de lire les touches directement, nous allons
créer une classe que d'autres parties du code pourront interroger <code class="notranslate" translate="no">left</code> ou <code class="notranslate" translate="no">right</code>.
De cette façon, nous pouvons assigner plusieurs façons de saisir <code class="notranslate" translate="no">left</code> ou <code class="notranslate" translate="no">right</code>, etc.
Nous allons commencer avec juste des touches.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// Garde l'état des touches/boutons
//
// Vous pouvez vérifier
//
//   inputManager.keys.left.down
//
// pour voir si la touche gauche est actuellement enfoncée
// et vous pouvez vérifier
//
//   inputManager.keys.left.justPressed
//
// Pour voir si la touche gauche a été enfoncée cette image
//
// Les touches sont 'left', 'right', 'a', 'b', 'up', 'down'
class InputManager {
  constructor() {
    this.keys = {};
    const keyMap = new Map();

    const setKey = (keyName, pressed) =&gt; {
      const keyState = this.keys[keyName];
      keyState.justPressed = pressed &amp;&amp; !keyState.down;
      keyState.down = pressed;
    };

    const addKey = (keyCode, name) =&gt; {
      this.keys[name] = { down: false, justPressed: false };
      keyMap.set(keyCode, name);
    };

    const setKeyFromKeyCode = (keyCode, pressed) =&gt; {
      const keyName = keyMap.get(keyCode);
      if (!keyName) {
        return;
      }
      setKey(keyName, pressed);
    };

    addKey(37, 'left');
    addKey(39, 'right');
    addKey(38, 'up');
    addKey(40, 'down');
    addKey(90, 'a');
    addKey(88, 'b');

    window.addEventListener('keydown', (e) =&gt; {
      setKeyFromKeyCode(e.keyCode, true);
    });
    window.addEventListener('keyup', (e) =&gt; {
      setKeyFromKeyCode(e.keyCode, false);
    });
  }
  update() {
    for (const keyState of Object.values(this.keys)) {
      if (keyState.justPressed) {
        keyState.justPressed = false;
      }
    }
  }
}
</pre>
<p>Le code ci-dessus suit si les touches sont relevées ou enfoncées et vous pouvez vérifier
si une touche est actuellement enfoncée en vérifiant par exemple
<code class="notranslate" translate="no">inputManager.keys.left.down</code>. Il a également une propriété <code class="notranslate" translate="no">justPressed</code>
pour chaque touche afin que vous puissiez vérifier si l'utilisateur vient d'appuyer sur la touche.
Par exemple, pour une touche de saut, vous ne voulez pas savoir si le bouton est maintenu
enfoncé, vous voulez savoir si l'utilisateur vient d'appuyer dessus maintenant.</p>
<p>Créons une instance d'<code class="notranslate" translate="no">InputManager</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const globals = {
  time: 0,
  deltaTime: 0,
};
const gameObjectManager = new GameObjectManager();
+const inputManager = new InputManager();
</pre>
<p>et mettez-le à jour dans notre boucle de rendu.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function render(now) {

  ...

  gameObjectManager.update();
+  inputManager.update();

  ...
}
</pre>
<p>Il doit être appelé après <code class="notranslate" translate="no">gameObjectManager.update</code> sinon
<code class="notranslate" translate="no">justPressed</code> ne serait jamais vrai à l'intérieur de la fonction <code class="notranslate" translate="no">update</code> d'un composant.</p>
<p>Utilisons-le dans le composant <code class="notranslate" translate="no">Player</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const kForward = new THREE.Vector3(0, 0, 1);
const globals = {
  time: 0,
  deltaTime: 0,
+  moveSpeed: 16,
};

class Player extends Component {
  constructor(gameObject) {
    super(gameObject);
    const model = models.knight;
    this.skinInstance = gameObject.addComponent(SkinInstance, model);
    this.skinInstance.setAnimation('Run');
+    this.turnSpeed = globals.moveSpeed / 4;
  }
+  update() {
+    const {deltaTime, moveSpeed} = globals;
+    const {transform} = this.gameObject;
+    const delta = (inputManager.keys.left.down  ?  1 : 0) +
+                  (inputManager.keys.right.down ? -1 : 0);
+    transform.rotation.y += this.turnSpeed * delta * deltaTime;
+    transform.translateOnAxis(kForward, moveSpeed * deltaTime);
+  }
}
</pre>
<p>Le code ci-dessus utilise <a href="/docs/#api/en/core/Object3D.transformOnAxis"><code class="notranslate" translate="no">Object3D.transformOnAxis</code></a> pour déplacer le joueur
vers l'avant. <a href="/docs/#api/en/core/Object3D.transformOnAxis"><code class="notranslate" translate="no">Object3D.transformOnAxis</code></a> fonctionne dans l'espace local, donc il
fonctionne uniquement si l'objet en question est à la racine de la scène, pas s'il est
parenté à autre chose <a class="footnote" href="#parented" id="parented-backref">1</a></p>
<p>Nous avons également ajouté une variable globale <code class="notranslate" translate="no">moveSpeed</code> et basé une variable <code class="notranslate" translate="no">turnSpeed</code> sur la vitesse de déplacement.
La vitesse de rotation est basée sur la vitesse de déplacement pour s'assurer qu'un personnage
peut tourner assez brusquement pour atteindre sa cible. Si <code class="notranslate" translate="no">turnSpeed</code> est trop petite,
un personnage tournera en rond autour de sa cible sans jamais
l'atteindre. Je n'ai pas pris la peine de faire le calcul pour déterminer la vitesse de rotation requise
pour une vitesse de déplacement donnée. J'ai juste deviné.</p>
<p>Le code jusqu'à présent fonctionnerait, mais si le joueur sort de l'écran, il n'y a aucun
moyen de savoir où il se trouve. Faisons en sorte que s'il est hors écran
pendant plus d'un certain temps, il soit téléporté à l'origine.
Nous pouvons faire cela en utilisant la classe <a href="/docs/#api/en/math/Frustum"><code class="notranslate" translate="no">Frustum</code></a> de three.js pour vérifier si un point
est à l'intérieur du frustum de vue de la caméra.</p>
<p>Nous devons construire un frustum à partir de la caméra. Nous pourrions le faire dans le composant Player,
mais d'autres objets pourraient vouloir l'utiliser aussi, alors ajoutons un autre
gameobject avec un composant pour gérer un frustum.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class CameraInfo extends Component {
  constructor(gameObject) {
    super(gameObject);
    this.projScreenMatrix = new THREE.Matrix4();
    this.frustum = new THREE.Frustum();
  }
  update() {
    const {camera} = globals;
    this.projScreenMatrix.multiplyMatrices(
        camera.projectionMatrix,
        camera.matrixWorldInverse);
    this.frustum.setFromProjectionMatrix(this.projScreenMatrix);
  }
}
</pre>
<p>Ensuite, configurons un autre gameobject au moment de l'initialisation.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function init() {
  // cacher la barre de chargement
  const loadingElem = document.querySelector('#loading');
  loadingElem.style.display = 'none';

  prepModelsAndAnimations();

+  {
+    const gameObject = gameObjectManager.createGameObject(camera, 'camera');
+    globals.cameraInfo = gameObject.addComponent(CameraInfo);
+  }

  {
    const gameObject = gameObjectManager.createGameObject(scene, 'player');
    gameObject.addComponent(Player);
  }
}
</pre>
<p>et maintenant, nous pouvons l'utiliser dans le composant <code class="notranslate" translate="no">Player</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class Player extends Component {
  constructor(gameObject) {
    super(gameObject);
    const model = models.knight;
    this.skinInstance = gameObject.addComponent(SkinInstance, model);
    this.skinInstance.setAnimation('Run');
    this.turnSpeed = globals.moveSpeed / 4;
+    this.offscreenTimer = 0;
+    this.maxTimeOffScreen = 3;
  }
  update() {
-    const {deltaTime, moveSpeed} = globals;
+    const {deltaTime, moveSpeed, cameraInfo} = globals;
    const {transform} = this.gameObject;
    const delta = (inputManager.keys.left.down  ?  1 : 0) +
                  (inputManager.keys.right.down ? -1 : 0);
    transform.rotation.y += this.turnSpeed * delta * deltaTime;
    transform.translateOnAxis(kForward, moveSpeed * deltaTime);

+    const {frustum} = cameraInfo;
+    if (frustum.containsPoint(transform.position)) {
+      this.offscreenTimer = 0;
+    } else {
+      this.offscreenTimer += deltaTime;
+      if (this.offscreenTimer &gt;= this.maxTimeOffScreen) {
+        transform.position.set(0, 0, 0);
+      }
+    }
  }
}
</pre>
<p>Une chose de plus avant d'essayer, ajoutons le support des écrans tactiles
pour mobile. D'abord, ajoutons du HTML pour le toucher.</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;body&gt;
  &lt;canvas id="c"&gt;&lt;/canvas&gt;
+  &lt;div id="ui"&gt;
+    &lt;div id="left"&gt;&lt;img src="../resources/images/left.svg"&gt;&lt;/div&gt;
+    &lt;div style="flex: 0 0 40px;"&gt;&lt;/div&gt;
+    &lt;div id="right"&gt;&lt;img src="../resources/images/right.svg"&gt;&lt;/div&gt;
+  &lt;/div&gt;
  &lt;div id="loading"&gt;
    &lt;div&gt;
      &lt;div&gt;...chargement...&lt;/div&gt;
      &lt;div class="progress"&gt;&lt;div id="progressbar"&gt;&lt;/div&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
+  &lt;div id="labels"&gt;&lt;/div&gt;
&lt;/body&gt;
</pre>
<p>Et ajoutons du CSS pour le styliser.</p>
<pre class="prettyprint showlinemods notranslate lang-css" translate="no">#ui {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-items: center;
  align-content: stretch;
}
#ui&gt;div {
  display: flex;
  align-items: flex-end;
  flex: 1 1 auto;
}
.bright {
  filter: brightness(2);
}
#left {
  justify-content: flex-end;
}
#right {
  justify-content: flex-start;
}
#ui img {
  padding: 10px;
  width: 80px;
  height: 80px;
  display: block;
}
</pre>
<p>L'idée ici est qu'il y a un div, <code class="notranslate" translate="no">#ui</code>, qui
couvre toute la page. À l'intérieur se trouveront 2 divs, <code class="notranslate" translate="no">#left</code> et <code class="notranslate" translate="no">#right</code>,
qui occupent presque la moitié de la largeur de la page et toute la hauteur de l'écran.
Entre les deux, il y a un séparateur de 40px. Si l'utilisateur fait glisser son doigt
sur le côté gauche ou droit, nous devons mettre à jour <code class="notranslate" translate="no">keys.left</code> et <code class="notranslate" translate="no">keys.right</code>
dans l'<code class="notranslate" translate="no">InputManager</code>. Cela rend toute la surface de l'écran sensible au toucher,
ce qui semblait mieux que de simples petites flèches.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class InputManager {
  constructor() {
    this.keys = {};
    const keyMap = new Map();

    const setKey = (keyName, pressed) =&gt; {
      const keyState = this.keys[keyName];
      keyState.justPressed = pressed &amp;&amp; !keyState.down;
      keyState.down = pressed;
    };

    const addKey = (keyCode, name) =&gt; {
      this.keys[name] = { down: false, justPressed: false };
      keyMap.set(keyCode, name);
    };

    const setKeyFromKeyCode = (keyCode, pressed) =&gt; {
      const keyName = keyMap.get(keyCode);
      if (!keyName) {
        return;
      }
      setKey(keyName, pressed);
    };

    addKey(37, 'left');
    addKey(39, 'right');
    addKey(38, 'up');
    addKey(40, 'down');
    addKey(90, 'a');
    addKey(88, 'b');

    window.addEventListener('keydown', (e) =&gt; {
      setKeyFromKeyCode(e.keyCode, true);
    });
    window.addEventListener('keyup', (e) =&gt; {
      setKeyFromKeyCode(e.keyCode, false);
    });

+    const sides = [
+      { elem: document.querySelector('#left'),  key: 'left'  },
+      { elem: document.querySelector('#right'), key: 'right' },
+    ];
+
+    const clearKeys = () =&gt; {
+      for (const {key} of sides) {
+          setKey(key, false);
+      }
+    };
+
+    const handleMouseMove = (e) =&gt; {
+      e.preventDefault();
+      // ceci est nécessaire car nous appelons preventDefault();
+      // nous avons également donné au canvas un tabindex afin qu'il puisse
+      // devenir le focus
+      canvas.focus();
+      window.addEventListener('pointermove', handleMouseMove);
+      window.addEventListener('pointerup', handleMouseUp);
+
+      for (const {elem, key} of sides) {
+        let pressed = false;
+        const rect = elem.getBoundingClientRect();
+        const x = e.clientX;
+        const y = e.clientY;
+        const inRect = x &gt;= rect.left &amp;&amp; x &lt; rect.right &amp;&amp;
+                       y &gt;= rect.top &amp;&amp; y &lt; rect.bottom;
+        if (inRect) {
+          pressed = true;
+        }
+        setKey(key, pressed);
+      }
+    };
+
+    function handleMouseUp() {
+      clearKeys();
+      window.removeEventListener('pointermove', handleMouseMove, {passive: false});
+      window.removeEventListener('pointerup', handleMouseUp);
+    }
+
+    const uiElem = document.querySelector('#ui');
+    uiElem.addEventListener('pointerdown', handleMouseMove, {passive: false});
+
+    uiElem.addEventListener('touchstart', (e) =&gt; {
+      // empêcher le défilement
+      e.preventDefault();
+    }, {passive: false});
  }
  update() {
    for (const keyState of Object.values(this.keys)) {
      if (keyState.justPressed) {
        keyState.justPressed = false;
      }
    }
  }
}
</pre>
<p>Et maintenant, nous devrions pouvoir contrôler le personnage avec les touches fléchées gauche et droite
ou avec nos doigts sur un écran tactile.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/game-player-input.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/game-player-input.html" target="_blank">cliquez ici pour ouvrir dans une fenêtre séparée</a>
</div>

<p></p>
<p>Idéalement, nous ferions autre chose si le joueur sortait de l'écran, comme déplacer
la caméra ou peut-être que sortir de l'écran équivaut à la mort, mais cet article va déjà être
trop long, donc pour l'instant, se téléporter au centre était la chose la plus simple.</p>
<p>Ajoutons quelques animaux. Nous pouvons commencer de manière similaire au <code class="notranslate" translate="no">Player</code> en créant
un composant <code class="notranslate" translate="no">Animal</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class Animal extends Component {
  constructor(gameObject, model) {
    super(gameObject);
    const skinInstance = gameObject.addComponent(SkinInstance, model);
    skinInstance.mixer.timeScale = globals.moveSpeed / 4;
    skinInstance.setAnimation('Idle');
  }
}
</pre>
<p>Le code ci-dessus définit le <a href="/docs/#api/en/animation/AnimationMixer.timeScale"><code class="notranslate" translate="no">AnimationMixer.timeScale</code></a> pour définir la vitesse
de lecture des animations par rapport à la vitesse de déplacement. Ainsi, si nous
ajustons la vitesse de déplacement, l'animation accélérera ou ralentira également.</p>
<p>Pour commencer, nous pourrions configurer un animal de chaque type.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function init() {
  // cacher la barre de chargement
  const loadingElem = document.querySelector('#loading');
  loadingElem.style.display = 'none';

  prepModelsAndAnimations();
  {
    const gameObject = gameObjectManager.createGameObject(camera, 'camera');
    globals.cameraInfo = gameObject.addComponent(CameraInfo);
  }

  {
    const gameObject = gameObjectManager.createGameObject(scene, 'player');
    globals.player = gameObject.addComponent(Player);
    globals.congaLine = [gameObject];
  }

+  const animalModelNames = [
+    'pig',
+    'cow',
+    'llama',
+    'pug',
+    'sheep',
+    'zebra',
+    'horse',
+  ];
+  animalModelNames.forEach((name, ndx) =&gt; {
+    const gameObject = gameObjectManager.createGameObject(scene, name);
+    gameObject.addComponent(Animal, models[name]);
+    gameObject.transform.position.x = (ndx + 1) * 5;
+  });
}
</pre>
<p>Et cela nous donnerait des animaux debout à l'écran, mais nous voulons qu'ils fassent
quelque chose.</p>
<p>Faisons en sorte qu'ils suivent le joueur en file indienne, mais seulement si le joueur s'approche suffisamment.
Pour ce faire, nous avons besoin de plusieurs états.</p>
<ul>
<li><p>Inactif :</p>
<p>L'animal attend que le joueur s'approche.</p>
</li>
<li><p>Attente de la fin de la ligne :</p>
<p>L'animal a été touché par le joueur, mais doit maintenant attendre que l'animal
au bout de la ligne arrive pour pouvoir rejoindre le bout de la ligne.</p>
</li>
<li><p>Aller au dernier :</p>
<p>L'animal doit marcher jusqu'à l'endroit où se trouvait l'animal qu'il suit, tout en enregistrant
un historique de l'endroit où l'animal qu'il suit se trouve actuellement.</p>
</li>
<li><p>Suivre</p>
<p>L'animal doit continuer à enregistrer un historique de l'endroit où l'animal qu'il suit se trouve, tout en
se déplaçant vers l'endroit où l'animal qu'il suit se trouvait auparavant.</p>
</li>
</ul>
<p>Il existe de nombreuses façons de gérer différents états comme celui-ci. Une méthode courante consiste à utiliser
une <a href="https://www.google.com/search?q=finite+state+machine">Machine à états finis</a> et
à construire une classe pour nous aider à gérer l'état.</p>
<p>Alors, faisons cela.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class FiniteStateMachine {
  constructor(states, initialState) {
    this.states = states;
    this.transition(initialState);
  }
  get state() {
    return this.currentState;
  }
  transition(state) {
    const oldState = this.states[this.currentState];
    if (oldState &amp;&amp; oldState.exit) {
      oldState.exit.call(this);
    }
    this.currentState = state;
    const newState = this.states[state];
    if (newState.enter) {
      newState.enter.call(this);
    }
  }
  update() {
    const state = this.states[this.currentState];
    if (state.update) {
      state.update.call(this);
    }
  }
}
</pre>
<p>Voici une classe simple. Nous lui passons un objet avec un tas d'états.
Chaque état a 3 fonctions optionnelles : <code class="notranslate" translate="no">enter</code>, <code class="notranslate" translate="no">update</code>, et <code class="notranslate" translate="no">exit</code>.
Pour changer d'état, nous appelons <code class="notranslate" translate="no">FiniteStateMachine.transition</code> et lui passons
le nom du nouvel état. Si l'état actuel a une fonction <code class="notranslate" translate="no">exit</code>, elle
est appelée. Ensuite, si le nouvel état a une fonction <code class="notranslate" translate="no">enter</code>, elle est appelée.
Enfin, à chaque image, <code class="notranslate" translate="no">FiniteStateMachine.update</code> appelle la fonction <code class="notranslate" translate="no">update</code>
de l'état actuel.</p>
<p>Utilisons-la pour gérer les états des animaux.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// Renvoie vrai si obj1 et obj2 sont proches
function isClose(obj1, obj1Radius, obj2, obj2Radius) {
  const minDist = obj1Radius + obj2Radius;
  const dist = obj1.position.distanceTo(obj2.position);
  return dist &lt; minDist;
}

// garde v entre -min et +min
function minMagnitude(v, min) {
  return Math.abs(v) &gt; min
      ? min * Math.sign(v)
      : v;
}

const aimTowardAndGetDistance = function() {
  const delta = new THREE.Vector3();

  return function aimTowardAndGetDistance(source, targetPos, maxTurn) {
    delta.subVectors(targetPos, source.position);
    // calculer la direction dans laquelle nous voulons faire face
    const targetRot = Math.atan2(delta.x, delta.z) + Math.PI * 1.5;
    // tourner dans la direction la plus courte
    const deltaRot = (targetRot - source.rotation.y + Math.PI * 1.5) % (Math.PI * 2) - Math.PI;
    // s'assurer que nous ne tournons pas plus vite que maxTurn
    const deltaRotation = minMagnitude(deltaRot, maxTurn);
    // garder la rotation entre 0 et Math.PI * 2
    source.rotation.y = THREE.MathUtils.euclideanModulo(
        source.rotation.y + deltaRotation, Math.PI * 2);
    // retourner la distance à la cible
    return delta.length();
  };
}();

class Animal extends Component {
  constructor(gameObject, model) {
    super(gameObject);
+    const hitRadius = model.size / 2;
    const skinInstance = gameObject.addComponent(SkinInstance, model);
    skinInstance.mixer.timeScale = globals.moveSpeed / 4;
+    const transform = gameObject.transform;
+    const playerTransform = globals.player.gameObject.transform;
+    const maxTurnSpeed = Math.PI * (globals.moveSpeed / 4);
+    const targetHistory = [];
+    let targetNdx = 0;
+
+    function addHistory() {
+      const targetGO = globals.congaLine[targetNdx];
+      const newTargetPos = new THREE.Vector3();
+      newTargetPos.copy(targetGO.transform.position);
+      targetHistory.push(newTargetPos);
+    }
+
+    this.fsm = new FiniteStateMachine({
+      idle: {
+        enter: () =&gt; {
+          skinInstance.setAnimation('Idle');
+        },
+        update: () =&gt; {
+          // vérifier si le joueur est proche
+          if (isClose(transform, hitRadius, playerTransform, globals.playerRadius)) {
+            this.fsm.transition('waitForEnd');
+          }
+        },
+      },
+      waitForEnd: {
+        enter: () =&gt; {
+          skinInstance.setAnimation('Jump');
+        },
+        update: () =&gt; {
+          // obtenir le gameObject au bout de la ligne de conga
+          const lastGO = globals.congaLine[globals.congaLine.length - 1];
+          const deltaTurnSpeed = maxTurnSpeed * globals.deltaTime;
+          const targetPos = lastGO.transform.position;
+          aimTowardAndGetDistance(transform, targetPos, deltaTurnSpeed);
+          // vérifier si la dernière chose dans la ligne de conga est proche
+          if (isClose(transform, hitRadius, lastGO.transform, globals.playerRadius)) {
+            this.fsm.transition('goToLast');
+          }
+        },
+      },
+      goToLast: {
+        enter: () =&gt; {
+          // se souvenir de qui nous suivons
+          targetNdx = globals.congaLine.length - 1;
+          // nous ajouter à la ligne de conga
+          globals.congaLine.push(gameObject);
+          skinInstance.setAnimation('Walk');
+        },
+        update: () =&gt; {
+          addHistory();
+          // marcher jusqu'au point le plus ancien de l'historique
+          const targetPos = targetHistory[0];
+          const maxVelocity = globals.moveSpeed * globals.deltaTime;
+          const deltaTurnSpeed = maxTurnSpeed * globals.deltaTime;
+          const distance = aimTowardAndGetDistance(transform, targetPos, deltaTurnSpeed);
+          const velocity = distance;
+          transform.translateOnAxis(kForward, Math.min(velocity, maxVelocity));
+          if (distance &lt;= maxVelocity) {
+            this.fsm.transition('follow');
+          }
+        },
+      },
+      follow: {
+        update: () =&gt; {
+          addHistory();
+          // supprimer l'historique le plus ancien et nous y placer.
+          const targetPos = targetHistory.shift();
+          transform.position.copy(targetPos);
+          const deltaTurnSpeed = maxTurnSpeed * globals.deltaTime;
+          aimTowardAndGetDistance(transform, targetHistory[0], deltaTurnSpeed);
+        },
+      },
+    }, 'idle');
+  }
+  update() {
+    this.fsm.update();
+  }
}
</pre>
<p>C'était un gros morceau de code mais il fait ce qui a été décrit ci-dessus.
J'espère que si vous parcourez chaque état, ce sera clair.</p>
<p>Quelques choses que nous devons ajouter. Le joueur doit s'ajouter
aux variables globales afin que les animaux puissent le trouver, et nous devons démarrer la
file indienne avec le <code class="notranslate" translate="no">GameObject</code> du joueur.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function init() {

  ...

  {
    const gameObject = gameObjectManager.createGameObject(scene, 'player');
+    globals.player = gameObject.addComponent(Player);
+    globals.congaLine = [gameObject];
  }

}
</pre>
<p>Nous devons également calculer une taille pour chaque modèle.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function prepModelsAndAnimations() {
+  const box = new THREE.Box3();
+  const size = new THREE.Vector3();
  Object.values(models).forEach(model =&gt; {
+    box.setFromObject(model.gltf.scene);
+    box.getSize(size);
+    model.size = size.length();
    const animsByName = {};
    model.gltf.animations.forEach((clip) =&gt; {
      animsByName[clip.name] = clip;
      // Devrait vraiment corriger cela dans le fichier .blend
      if (clip.name === 'Walk') {
        clip.duration /= 2;
      }
    });
    model.animations = animsByName;
  });
}
</pre>
<p>Et le joueur doit enregistrer sa taille.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class Player extends Component {
  constructor(gameObject) {
    super(gameObject);
    const model = models.knight;
+    globals.playerRadius = model.size / 2;
</pre>
<p>En y réfléchissant maintenant, il aurait probablement été plus intelligent
que les animaux ciblent simplement la tête de la file indienne
au lieu du joueur spécifiquement. Peut-être que je reviendrai
et changerai cela plus tard.</p>
<p>Lorsque j'ai commencé, j'ai utilisé un seul rayon pour tous les animaux,
mais bien sûr, ce n'était pas bon car le carlin est beaucoup plus petit que le cheval.
J'ai donc ajouté les différentes tailles, mais je voulais pouvoir visualiser
les choses. Pour ce faire, j'ai créé un composant <code class="notranslate" translate="no">StatusDisplayHelper</code>.</p>
<p>Il utilise un <a href="/docs/#api/en/helpers/PolarGridHelper"><code class="notranslate" translate="no">PolarGridHelper</code></a> pour dessiner un cercle autour de chaque personnage
et utilise des éléments HTML pour permettre à chaque personnage d'afficher un état en utilisant
les techniques abordées dans <a href="align-html-elements-to-3d.html">l'article sur l'alignement des éléments HTML en 3D</a>.</p>
<p>Nous devons d'abord ajouter du HTML pour héberger ces éléments.</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;body&gt;
  &lt;canvas id="c"&gt;&lt;/canvas&gt;
  &lt;div id="ui"&gt;
    &lt;div id="left"&gt;&lt;img src="../resources/images/left.svg"&gt;&lt;/div&gt;
    &lt;div style="flex: 0 0 40px;"&gt;&lt;/div&gt;
    &lt;div id="right"&gt;&lt;img src="../resources/images/right.svg"&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div id="loading"&gt;
    &lt;div&gt;
      &lt;div&gt;...chargement...&lt;/div&gt;
      &lt;div class="progress"&gt;&lt;div id="progressbar"&gt;&lt;/div&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
+  &lt;div id="labels"&gt;&lt;/div&gt;
&lt;/body&gt;
</pre>
<p>Et ajoutons du CSS pour les styliser.</p>
<pre class="prettyprint showlinemods notranslate lang-css" translate="no">#labels {
  position: absolute;  /* nous permet de nous positionner à l'intérieur du conteneur */
  left: 0;             /* faire de notre position le coin supérieur gauche du conteneur */
  top: 0;
  color: white;
  width: 100%;
  height: 100%;
  overflow: hidden;
  pointer-events: none;
}
#labels&gt;div {
  position: absolute;  /* nous permet de les positionner à l'intérieur du conteneur */
  left: 0;             /* faire de leur position par défaut le coin supérieur gauche du conteneur */
  top: 0;
  font-size: large;
  font-family: monospace;
  user-select: none;   /* ne pas laisser le texte être sélectionné */
  text-shadow:         /* créer un contour noir */
    -1px -1px 0 #000,
     0   -1px 0 #000,
     1px -1px 0 #000,
     1px  0   0 #000,
     1px  1px 0 #000,
     0    1px 0 #000,
    -1px  1px 0 #000,
    -1px  0   0 #000;
}
</pre>
<p>Voici ensuite le composant.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const labelContainerElem = document.querySelector('#labels');

class StateDisplayHelper extends Component {
  constructor(gameObject, size) {
    super(gameObject);
    this.elem = document.createElement('div');
    labelContainerElem.appendChild(this.elem);
    this.pos = new THREE.Vector3();

    this.helper = new THREE.PolarGridHelper(size / 2, 1, 1, 16);
    gameObject.transform.add(this.helper);
  }
  setState(s) {
    this.elem.textContent = s;
  }
  setColor(cssColor) {
    this.elem.style.color = cssColor;
    this.helper.material.color.set(cssColor);
  }
  update() {
    const {pos} = this;
    const {transform} = this.gameObject;
    const {canvas} = globals;
    pos.copy(transform.position);

    // obtenir les coordonnées écran normalisées de cette position
    // x et y seront dans la plage de -1 à +1 avec x = -1 étant
    // à gauche et y = -1 étant en bas
    pos.project(globals.camera);

    // convertir la position normalisée en coordonnées CSS
    const x = (pos.x *  .5 + .5) * canvas.clientWidth;
    const y = (pos.y * -.5 + .5) * canvas.clientHeight;

    // déplacer l'élément à cette position
    this.elem.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;
  }
}
</pre>
<p>Et nous pouvons alors les ajouter aux animaux comme ceci :</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class Animal extends Component {
  constructor(gameObject, model) {
    super(gameObject);
+    this.helper = gameObject.addComponent(StateDisplayHelper, model.size);

     ...

  }
  update() {
    this.fsm.update();
+    const dir = THREE.MathUtils.radToDeg(this.gameObject.transform.rotation.y);
+    this.helper.setState(`${this.fsm.state}:${dir.toFixed(0)}`);
  }
}
</pre>
<p>Pendant que nous y sommes, faisons en sorte que nous puissions les activer/désactiver en utilisant lil-gui comme
nous l'avons utilisé ailleurs.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">import * as THREE from 'three';
import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
+import {GUI} from 'three/addons/libs/lil-gui.module.min.js';
</pre>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const gui = new GUI();
+gui.add(globals, 'debug').onChange(showHideDebugInfo);
+showHideDebugInfo();

const labelContainerElem = document.querySelector('#labels');
+function showHideDebugInfo() {
+  labelContainerElem.style.display = globals.debug ? '' : 'none';
+}
+showHideDebugInfo();

class StateDisplayHelper extends Component {

  ...

  update() {
+    this.helper.visible = globals.debug;
+    if (!globals.debug) {
+      return;
+    }

    ...
  }
}
</pre>
<p>Et avec cela, nous obtenons le début d'un jeu.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/game-conga-line.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/game-conga-line.html" target="_blank">cliquez ici pour ouvrir dans une fenêtre séparée</a>
</div>

<p></p>
<p>Vous vous demandez peut-être pourquoi ne pas utiliser <code class="notranslate" translate="no">setTimeout</code> ? Le problème avec <code class="notranslate" translate="no">setTimeout</code>
est qu'il n'est pas lié à l'horloge du jeu. Par exemple, ci-dessus, nous avons défini le maximum
temps autorisé entre les images à 1/20e de seconde.
Notre système de coroutines respectera cette limite, mais <code class="notranslate" translate="no">setTimeout</code> ne le ferait pas.</p>
<p>Bien sûr, nous aurions pu faire un simple minuteur nous-mêmes.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class Player ... {
  update() {
    this.noteTimer -= globals.deltaTime;
    if (this.noteTimer &lt;= 0) {
      // réinitialiser le minuteur
      this.noteTimer = rand(0.5, 1);
      // créer un gameobject avec un composant note
    }
  }
</pre>
<p>Et pour ce cas particulier, cela aurait pu être mieux, mais à mesure que vous ajoutez
plus de choses, vous aurez de plus en plus de variables ajoutées à vos classes,
tandis qu'avec les coroutines, vous pouvez souvent simplement les <em>lancer et oublier</em>.</p>
<p>Compte tenu des états simples de nos animaux, nous aurions également pu les implémenter
avec une coroutine sous la forme de</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">// pseudo-code !
function* animalCoroutine() {
   setAnimation('Idle');
   while(playerIsTooFar()) {
     yield;
   }
   const target = endOfLine;
   setAnimation('Jump');
   while(targetIsTooFar()) {
     aimAt(target);
     yield;
   }
   setAnimation('Walk')
   while(notAtOldestPositionOfTarget()) {
     addHistory();
     aimAt(target);
     yield;
   }
   for(;;) {
     addHistory();
     const pos = history.unshift();
     transform.position.copy(pos);
     aimAt(history[0]);
     yield;
   }
}
</pre>
<p>Cela aurait fonctionné, mais bien sûr, dès que nos états n'étaient pas si linéaires,
nous aurions dû passer à une <code class="notranslate" translate="no">FiniteStateMachine</code>.</p>
<p>Il n'était pas non plus clair pour moi si les coroutines devaient s'exécuter indépendamment de leurs
composants. Nous aurions pu créer un <code class="notranslate" translate="no">CoroutineRunner</code> global et y placer toutes
les coroutines. Cela rendrait leur nettoyage plus difficile. En l'état actuel,
si le gameobject est supprimé, tous ses composants sont supprimés et
par conséquent, les CoroutineRunners créés ne sont plus appelés et tout
sera récupéré par le garbage collector. Si nous avions un runner global,
il incomberait à chaque composant de supprimer toute coroutine qu'il a ajoutée,
ou un autre mécanisme d'enregistrement des coroutines avec un composant ou un gameobject particulier
serait nécessaire afin que la suppression de l'un entraîne la suppression des
autres.</p>
<p>Il y a beaucoup d'autres problèmes qu'un
moteur de jeu normal gérerait. En l'état actuel, il n'y a pas d'ordre d'exécution
des gameobjects ou de leurs composants. Ils sont simplement exécutés dans l'ordre d'ajout.
De nombreux systèmes de jeu ajoutent une priorité afin que l'ordre puisse être défini ou modifié.</p>
<p>Un autre problème que nous avons rencontré est que la <code class="notranslate" translate="no">Note</code> supprime la transformation de son gameobject de la scène.
Cela semble être quelque chose qui devrait se produire dans <code class="notranslate" translate="no">GameObject</code> puisqu'il a été <code class="notranslate" translate="no">GameObject</code>
qui a ajouté la transformation en premier lieu. Peut-être que <code class="notranslate" translate="no">GameObject</code> devrait avoir
une méthode <code class="notranslate" translate="no">dispose</code> appelée par <code class="notranslate" translate="no">GameObjectManager.removeGameObject</code> ?</p>
<p>Encore un autre problème est la façon dont nous appelons manuellement <code class="notranslate" translate="no">gameObjectManager.update</code> et <code class="notranslate" translate="no">inputManager.update</code>.
Peut-être qu'il devrait y avoir un <code class="notranslate" translate="no">SystemManager</code> auquel ces services globaux peuvent s'ajouter
et chaque service aura sa fonction <code class="notranslate" translate="no">update</code> appelée. De cette façon, si nous ajoutions un nouveau
service comme <code class="notranslate" translate="no">CollisionManager</code>, nous pourrions simplement l'ajouter au SystemManager et ne
pas avoir à modifier la boucle de rendu.</p>
<p>Je vous laisse ces types de problèmes.
J'espère que cet article vous a donné quelques idées pour votre propre moteur de jeu.</p>
<p>Peut-être devrais-je promouvoir une game jam. Si vous cliquez sur les boutons <em>jsfiddle</em> ou <em>codepen</em>
au-dessus du dernier exemple, ils s'ouvriront dans ces sites prêts à être modifiés. Ajoutez des fonctionnalités,
Changez le jeu pour qu'un carlin mène un groupe de chevaliers. Utilisez l'animation de roulade du chevalier
comme boule de bowling et créez un jeu de bowling avec des animaux. Organisez une course de relais avec des animaux.
Si vous créez un jeu sympa, postez un lien dans les commentaires ci-dessous.</p>
<div class="footnotes">
[<a id="parented">1</a>]: techniquement, cela fonctionnerait toujours si aucun des parents n'avait de translation, de rotation ou d'échelle <a href="#parented-backref">§</a>.
</div>
        </div>
      </div>
    </div>

  <script src="../resources/prettify.js"></script>
  <script src="../resources/lesson.js"></script>




</body></html>