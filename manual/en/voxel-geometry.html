<!DOCTYPE html><html lang="fr"><head>
    <meta charset="utf-8">
    <title>G√©om√©trie Voxel (type Minecraft)</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@threejs">
    <meta name="twitter:title" content="Three.js ‚Äì G√©om√©trie Voxel (type Minecraft)">
    <meta property="og:image" content="https://threejs.org/files/share.png">
    <link rel="shortcut icon" href="../../files/favicon_white.ico" media="(prefers-color-scheme: dark)">
    <link rel="shortcut icon" href="../../files/favicon.ico" media="(prefers-color-scheme: light)">

    <link rel="stylesheet" href="../resources/lesson.css">
    <link rel="stylesheet" href="../resources/lang.css">
<script type="importmap">
{
  "imports": {
    "three": "../../build/three.module.js"
  }
}
</script>
  </head>
  <body>
    <div class="container">
      <div class="lesson-title">
        <h1>G√©om√©trie Voxel (type Minecraft)</h1>
      </div>
      <div class="lesson">
        <div class="lesson-main">
          <p>J'ai vu ce sujet appara√Ætre plusieurs fois √† divers endroits.
La question est essentiellement : "Comment puis-je cr√©er un affichage voxel comme Minecraft ?".</p>
<p>La plupart des gens essaient d'abord de cr√©er une g√©om√©trie de cube, puis de cr√©er un maillage √† chaque position de voxel. Juste pour m'amuser, j'ai essay√© cela. J'ai cr√©√© un <code class="notranslate" translate="no">Uint8Array</code> de 16777216 √©l√©ments pour repr√©senter
un cube de voxels de 256x256x256.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const cellSize = 256;
const cell = new Uint8Array(cellSize * cellSize * cellSize);
</pre>
<p>J'ai ensuite cr√©√© une seule couche avec une sorte de collines faites d'ondes sinuso√Ødales comme ceci</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const height = (Math.sin(x / cellSize * Math.PI * 4) + Math.sin(z / cellSize * Math.PI * 6)) * 20 + cellSize / 2;
      if (height &gt; y &amp;&amp; height &lt; y + 1) {
        const offset = y * cellSize * cellSize +
                       z * cellSize +
                       x;
        cell[offset] = 1;
      }
    }
  }
}
</pre>
<p>J'ai ensuite parcouru toutes les cellules et si elles n'√©taient pas
0, j'ai cr√©√© un maillage avec un cube.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshPhongMaterial({color: 'green'});

for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const offset = y * cellSize * cellSize +
                     z * cellSize +
                     x;
      const block = cell[offset];
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, y, z);
      scene.add(mesh);
    }
  }
}
</pre>
<p>Le reste du code est bas√© sur l'exemple de
<a href="rendering-on-demand.html">l'article sur le rendu √† la demande</a>.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/voxel-geometry-separate-cubes.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/voxel-geometry-separate-cubes.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Cela prend un certain temps √† d√©marrer et si vous essayez de d√©placer la cam√©ra,
c'est probablement trop lent. Comme dans <a href="optimize-lots-of-objects.html">l'article sur la fa√ßon d'optimiser beaucoup d'objets</a>,
le probl√®me est qu'il y a beaucoup trop d'objets. 256x256
font 65536 bo√Ætes !</p>
<p>L'utilisation de <a href="rendering-on-demand.html">la technique de fusion de g√©om√©trie</a>
r√©soudra le probl√®me pour cet exemple, mais que se passerait-il si au lieu de simplement faire
une seule couche, nous remplissions tout ce qui est sous le sol avec des voxels.
En d'autres termes, changeons la boucle qui remplit les voxels comme ceci</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const height = (Math.sin(x / cellSize * Math.PI * 4) + Math.sin(z / cellSize * Math.PI * 6)) * 20 + cellSize / 2;
-      if (height &gt; y &amp;&amp; height &lt; y + 1) {
+      if (height &lt; y + 1) {
        const offset = y * cellSize * cellSize +
                       z * cellSize +
                       x;
        cell[offset] = 1;
      }
    }
  }
}
</pre>
<p>J'ai essay√© une fois juste pour voir les r√©sultats. Cela a moulin√© pendant
environ une minute, puis a plant√© avec <em>manque de m√©moire</em> üòÖ</p>
<p>Il y a plusieurs probl√®mes, mais le plus important est
que nous cr√©ons toutes ces faces √† l'int√©rieur des cubes que
nous ne pouvons en r√©alit√© jamais voir.</p>
<p>En d'autres termes, supposons que nous ayons une bo√Æte de voxels
de 3x2x2. En fusionnant les cubes, nous obtenons ceci</p>
<div class="spread">
  <div data-diagram="mergedCubes" style="height: 300px;"></div>
</div>

<p>mais nous voulons vraiment ceci</p>
<div class="spread">
  <div data-diagram="culledCubes" style="height: 300px;"></div>
</div>

<p>Dans la bo√Æte sup√©rieure, il y a des faces entre les voxels. Des faces
qui sont un gaspillage puisqu'elles ne peuvent pas √™tre vues. Ce n'est pas seulement
une face entre chaque voxel, il y a 2 faces, une pour
chaque voxel faisant face √† son voisin, qui sont un gaspillage. Toutes ces faces suppl√©mentaires,
surtout pour un grand volume de voxels, nuiront aux performances.</p>
<p>Il devrait √™tre clair que nous ne pouvons pas simplement fusionner la g√©om√©trie.
Nous devons la construire nous-m√™mes, en tenant compte du fait
que si un voxel a un voisin adjacent, il n'a pas besoin de la
face faisant face √† ce voisin.</p>
<p>Le probl√®me suivant est que 256x256x256 est tout simplement trop grand. 16 Mo, c'est beaucoup de m√©moire et,
de toute fa√ßon, dans une grande partie de cet espace, il n'y a rien, donc c'est beaucoup de m√©moire gaspill√©e. C'est aussi un nombre √©norme de voxels, 16 millions ! C'est trop pour
√™tre pris en compte en une seule fois.</p>
<p>Une solution consiste √† diviser la zone en zones plus petites.
Toute zone vide ne n√©cessite pas de stockage. Utilisons
des zones de 32x32x32 (soit 32k) et ne cr√©ons une zone que si elle contient quelque chose.
Nous appellerons l'une de ces zones plus grandes de 32x32x32 une "cellule".</p>
<p>D√©coupons cela en morceaux. Tout d'abord, cr√©ons une classe pour g√©rer les donn√©es de voxel.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
  }
}
</pre>
<p>Cr√©ons la fonction qui cr√©e la g√©om√©trie pour une cellule.
Supposons que vous passiez une position de cellule.
En d'autres termes, si vous voulez la g√©om√©trie pour la cellule qui couvre les voxels (0-31x, 0-31y, 0-31z),
vous passeriez alors 0,0,0. Pour la cellule qui couvre les voxels (32-63x, 0-31y, 0-31z), vous passeriez alors
1,0,0.</p>
<p>Nous devons pouvoir v√©rifier les voxels voisins, alors supposons que notre classe
dispose d'une fonction <code class="notranslate" translate="no">getVoxel</code> qui, √©tant donn√© une position de voxel, retourne la valeur
du voxel √† cet endroit. En d'autres termes, si vous lui passez 35,0,0 et que cellSize est 32,
elle regardera la cellule 1,0,0 et dans cette cellule, elle regardera le voxel 3,0,0.
Gr√¢ce √† cette fonction, nous pouvons regarder les voxels voisins d'un voxel, m√™me s'ils
se trouvent dans des cellules voisines.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
  }
+  generateGeometryDataForCell(cellX, cellY, cellZ) {
+    const {cellSize} = this;
+    const startX = cellX * cellSize;
+    const startY = cellY * cellSize;
+    const startZ = cellZ * cellSize;
+
+    for (let y = 0; y &lt; cellSize; ++y) {
+      const voxelY = startY + y;
+      for (let z = 0; z &lt; cellSize; ++z) {
+        const voxelZ = startZ + z;
+        for (let x = 0; x &lt; cellSize; ++x) {
+          const voxelX = startX + x;
+          const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
+          if (voxel) {
+            for (const {dir} of VoxelWorld.faces) {
+              const neighbor = this.getVoxel(
+                  voxelX + dir[0],
+                  voxelY + dir[1],
+                  voxelZ + dir[2]);
+              if (!neighbor) {
+                // ce voxel n'a pas de voisin dans cette direction, nous avons donc besoin d'une face ici.
+              }
+            }
+          }
+        }
+      }
+    }
+  }
}

+VoxelWorld.faces = [
+  { // gauche
+    dir: [ -1,  0,  0, ],
+  },
+  { // droite
+    dir: [  1,  0,  0, ],
+  },
+  { // bas
+    dir: [  0, -1,  0, ],
+  },
+  { // haut
+    dir: [  0,  1,  0, ],
+  },
+  { // arri√®re
+    dir: [  0,  0, -1, ],
+  },
+  { // avant
+    dir: [  0,  0,  1, ],
+  },
+];
</pre>
<p>Donc, en utilisant le code ci-dessus, nous savons quand nous avons besoin d'une face. G√©n√©rons les faces.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
  }
  generateGeometryDataForCell(cellX, cellY, cellZ) {
    const {cellSize} = this;
+    const positions = [];
+    const normals = [];
+    const indices = [];
    const startX = cellX * cellSize;
    const startY = cellY * cellSize;
    const startZ = cellZ * cellSize;

    for (let y = 0; y &lt; cellSize; ++y) {
      const voxelY = startY + y;
      for (let z = 0; z &lt; cellSize; ++z) {
        const voxelZ = startZ + z;
        for (let x = 0; x &lt; cellSize; ++x) {
          const voxelX = startX + x;
          const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
          if (voxel) {
-            for (const {dir} of VoxelWorld.faces) {
+            for (const {dir, corners} of VoxelWorld.faces) {
               const neighbor = this.getVoxel(
                   voxelX + dir[0],
                   voxelY + dir[1],
                   voxelZ + dir[2]);
               if (!neighbor) {
-                // this voxel has no neighbor in this direction so we need a face.
+                // ce voxel n'a pas de voisin dans cette direction, nous avons donc besoin d'une face.
+                const ndx = positions.length / 3;
+                for (const pos of corners) {
+                  positions.push(pos[0] + x, pos[1] + y, pos[2] + z);
+                  normals.push(...dir);
+                }
+                indices.push(
+                  ndx, ndx + 1, ndx + 2,
+                  ndx + 2, ndx + 1, ndx + 3,
+                );
+              }
+            }
+          }
+        }
+      }
+    }
+    return {
+      positions,
+      normals,
+      indices,
+    };
+  }
+}

VoxelWorld.faces = [
  { // gauche
+    dir: [ -1,  0,  0, ],
+    corners: [
+-      [ 0, 1, 0 ],
+-      [ 0, 0, 0 ],
+-      [ 0, 1, 1 ],
+-      [ 0, 0, 1 ],
++      [ 0, 1, 0 ],
++      [ 0, 0, 0 ],
++      [ 0, 1, 1 ],
++      [ 0, 0, 1 ],
+    ],
+  },
+  { // droite
+    dir: [  1,  0,  0, ],
+    corners: [
+-      [ 1, 1, 1 ],
+-      [ 1, 0, 1 ],
+-      [ 1, 1, 0 ],
+-      [ 1, 0, 0 ],
++      [ 1, 1, 1 ],
++      [ 1, 0, 1 ],
++      [ 1, 1, 0 ],
++      [ 1, 0, 0 ],
+    ],
+  },
+  { // bas
+    dir: [  0, -1,  0, ],
+    corners: [
+-      [ 1, 0, 1 ],
+-      [ 0, 0, 1 ],
+-      [ 1, 0, 0 ],
+-      [ 0, 0, 0 ],
++      [ 1, 0, 1 ],
++      [ 0, 0, 1 ],
++      [ 1, 0, 0 ],
++      [ 0, 0, 0 ],
+    ],
+  },
+  { // haut
+    dir: [  0,  1,  0, ],
+    corners: [
+-      [ 0, 1, 1 ],
+-      [ 1, 1, 1 ],
+-      [ 0, 1, 0 ],
+-      [ 1, 1, 0 ],
++      [ 0, 1, 1 ],
++      [ 1, 1, 1 ],
++      [ 0, 1, 0 ],
++      [ 1, 1, 0 ],
+    ],
+  },
+  { // arri√®re
+    dir: [  0,  0, -1, ],
+    corners: [
+-      [ 1, 0, 0 ],
+-      [ 0, 0, 0 ],
+-      [ 1, 1, 0 ],
+-      [ 0, 1, 0 ],
++      [ 1, 0, 0 ],
++      [ 0, 0, 0 ],
++      [ 1, 1, 0 ],
++      [ 0, 1, 0 ],
+    ],
+  },
+  { // avant
+    dir: [  0,  0,  1, ],
+    corners: [
+-      [ 0, 0, 1 ],
+-      [ 1, 0, 1 ],
+-      [ 0, 1, 1 ],
+-      [ 1, 1, 1 ],
++      [ 0, 0, 1 ],
++      [ 1, 0, 1 ],
++      [ 0, 1, 1 ],
++      [ 1, 1, 1 ],
+    ],
               }
             }
           }
         }
       }
     }
-    return {
-      positions,
-      normals,
-      indices,
-    };
   }
 }
-
-VoxelWorld.faces = [
-  { // left
-    dir: [ -1,  0,  0, ],
-    corners: [
-      [ 0, 1, 0 ],
-      [ 0, 0, 0 ],
-      [ 0, 1, 1 ],
-      [ 0, 0, 1 ],
-    ],
-  },
-  { // right
-    dir: [  1,  0,  0, ],
-    corners: [
-      [ 1, 1, 1 ],
-      [ 1, 0, 1 ],
-      [ 1, 1, 0 ],
-      [ 1, 0, 0 ],
-    ],
-  },
-  { // bottom
-    dir: [  0, -1,  0, ],
-    corners: [
-      [ 1, 0, 1 ],
-      [ 0, 0, 1 ],
-      [ 1, 0, 0 ],
-      [ 0, 0, 0 ],
-    ],
-  },
-  { // top
-    dir: [  0,  1,  0, ],
-    corners: [
-      [ 0, 1, 1 ],
-      [ 1, 1, 1 ],
-      [ 0, 1, 0 ],
-      [ 1, 1, 0 ],
-    ],
-  },
-  { // back
-    dir: [  0,  0, -1, ],
-    corners: [
-      [ 1, 0, 0 ],
-      [ 0, 0, 0 ],
-      [ 1, 1, 0 ],
-      [ 0, 1, 0 ],
-    ],
-  },
-  { // front
-    dir: [  0,  0,  1, ],
-    corners: [
-      [ 0, 0, 1 ],
-      [ 1, 0, 1 ],
-      [ 0, 1, 1 ],
-      [ 1, 1, 1 ],
-    ],
-  },
-];
</pre>
<p>Le code ci-dessus nous permettrait d'obtenir des donn√©es de g√©om√©trie de base. Il suffit de fournir
la fonction <code class="notranslate" translate="no">getVoxel</code>. Commen√ßons avec une seule cellule cod√©e en dur.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
+    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
  }
+  getCellForVoxel(x, y, z) {
+    const {cellSize} = this;
+    const cellX = Math.floor(x / cellSize);
+    const cellY = Math.floor(y / cellSize);
+    const cellZ = Math.floor(z / cellSize);
+    if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
+      return null
+    }
+    return this.cell;
+  }
+  getVoxel(x, y, z) {
+    const cell = this.getCellForVoxel(x, y, z);
+    if (!cell) {
+      return 0;
+    }
+    const {cellSize} = this;
+    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
+    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
+    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
+    const voxelOffset = voxelY * cellSize * cellSize +
+                        voxelZ * cellSize +
+                        voxelX;
+    return cell[voxelOffset];
+  }
  generateGeometryDataForCell(cellX, cellY, cellZ) {

  ...
}
</pre>
<p>Cela semble fonctionner. Cr√©ons une fonction <code class="notranslate" translate="no">setVoxel</code>
pour pouvoir d√©finir des donn√©es.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
  }
  getCellForVoxel(x, y, z) {
    const {cellSize} = this;
    const cellX = Math.floor(x / cellSize);
    const cellY = Math.floor(y / cellSize);
    const cellZ = Math.floor(z / cellSize);
    if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
      return null
    }
    return this.cell;
  }
+  setVoxel(x, y, z, v) {
+    let cell = this.getCellForVoxel(x, y, z);
+    if (!cell) {
+      return;  // TODO : ajouter une nouvelle cellule ?
+    }
+    const {cellSize} = this;
+    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
+    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
+    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
+    const voxelOffset = voxelY * cellSize * cellSize +
+                        voxelZ * cellSize +
+                        voxelX;
+    cell[voxelOffset] = v;
+  }
  getVoxel(x, y, z) {
    const cell = this.getCellForVoxel(x, y, z);
    if (!cell) {
      return 0;
    }
    const {cellSize} = this;
    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
    const voxelOffset = voxelY * cellSize * cellSize +
                        voxelZ * cellSize +
                        voxelX;
    return cell[voxelOffset];
  }
  generateGeometryDataForCell(cellX, cellY, cellZ) {

  ...
}
</pre>
<p>Hmmm, je vois beaucoup de code r√©p√©t√©. Arrangeons cela</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
+    this.cellSliceSize = cellSize * cellSize;
    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
  }
  getCellForVoxel(x, y, z) {
    const {cellSize} = this;
    const cellX = Math.floor(x / cellSize);
    const cellY = Math.floor(y / cellSize);
    const cellZ = Math.floor(z / cellSize);
    if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
      return null;
    }
    return this.cell;
  }
+  computeVoxelOffset(x, y, z) {
+    const {cellSize, cellSliceSize} = this;
+    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
+    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
+    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
+    return voxelY * cellSliceSize +
+           voxelZ * cellSize +
+           voxelX;
+  }
  setVoxel(x, y, z, v) {
    const cell = this.getCellForVoxel(x, y, z);
    if (!cell) {
-      return 0;
+      return;  // TODO : ajouter une nouvelle cellule ?
    }
-    const {cellSize} = this;
-    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
-    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
-    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
-    const voxelOffset = voxelY * cellSize * cellSize +
-                        voxelZ * cellSize +
-                        voxelX;
+    const voxelOffset = this.computeVoxelOffset(x, y, z);
     cell[voxelOffset] = v;
   }
   getVoxel(x, y, z) {
     const cell = this.getCellForVoxel(x, y, z);
     if (!cell) {
       return 0;
     }
-    const {cellSize} = this;
-    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
-    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
-    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
-    const voxelOffset = voxelY * cellSize * cellSize +
-                        voxelZ * cellSize +
-                        voxelX;
+    const voxelOffset = this.computeVoxelOffset(x, y, z);
     return cell[voxelOffset];
   }
   generateGeometryDataForCell(cellX, cellY, cellZ) {

   ...
}
</pre>
<p>Maintenant, cr√©ons du code pour remplir la premi√®re cellule avec des voxels.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const cellSize = 32;

const world = new VoxelWorld(cellSize);

for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const height = (Math.sin(x / cellSize * Math.PI * 2) + Math.sin(z / cellSize * Math.PI * 3)) * (cellSize / 6) + (cellSize / 2);
      if (y &lt; height) {
        world.setVoxel(x, y, z, 1);
      }
    }
  }
}
</pre>
<p>et du code pour g√©n√©rer r√©ellement la g√©om√©trie, comme nous l'avons vu dans
<a href="custom-buffergeometry.html">l'article sur la BufferGeometry personnalis√©e</a>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const {positions, normals, indices} = world.generateGeometryDataForCell(0, 0, 0);
const geometry = new THREE.BufferGeometry();
const material = new THREE.MeshLambertMaterial({color: 'green'});

const positionNumComponents = 3;
const normalNumComponents = 3;
geometry.setAttribute(
    'position',
    new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
geometry.setAttribute(
    'normal',
    new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
geometry.setIndex(indices);
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);
</pre>
<p>essayons</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/voxel-geometry-culled-faces.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/voxel-geometry-culled-faces.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Cela semble fonctionner ! D'accord, ajoutons des textures.</p>
<p>En cherchant sur le net, j'ai trouv√© <a href="https://www.minecraftforum.net/forums/mapping-and-modding-java-edition/resource-packs/1245961-16x-1-7-4-wip-flourish">cet ensemble</a>
de textures Minecraft sous licence <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA</a>
par <a href="https://www.minecraftforum.net/members/Joshtimus">Joshtimus</a>.
J'en ai choisi quelques-unes au hasard et j'ai construit cette <a href="https://www.google.com/search?q=texture+atlas">carte de textures</a>.</p>
<div class="threejs_center"><img class="checkerboard" src="../examples/resources/images/minecraft/flourish-cc-by-nc-sa.png" style="width: 512px; image-rendering: pixelated;"></div>

<p>Pour simplifier les choses, elles sont arrang√©es avec un type de voxel par colonne,
o√π la premi√®re ligne est le c√¥t√© d'un voxel. La 2√®me ligne est
le haut du voxel, et la 3√®me ligne est le bas du voxel.</p>
<p>Sachant cela, nous pouvons ajouter des informations √† nos donn√©es <code class="notranslate" translate="no">VoxelWorld.faces</code>
pour sp√©cifier pour chaque face quelle ligne utiliser et les UV √† utiliser
pour cette face.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">VoxelWorld.faces = [
  { // gauche
+    uvRow: 0,
    dir: [ -1,  0,  0, ],
    corners: [
-      [ 0, 1, 0 ],
-      [ 0, 0, 0 ],
-      [ 0, 1, 1 ],
-      [ 0, 0, 1 ],
+      { pos: [ 0, 1, 0 ], uv: [ 0, 1 ], },
+      { pos: [ 0, 0, 0 ], uv: [ 0, 0 ], },
+      { pos: [ 0, 1, 1 ], uv: [ 1, 1 ], },
+      { pos: [ 0, 0, 1 ], uv: [ 1, 0 ], },
    ],
   },
   { // droite
+    uvRow: 0,
     dir: [  1,  0,  0, ],
     corners: [
-      [ 1, 1, 1 ],
-      [ 1, 0, 1 ],
-      [ 1, 1, 0 ],
-      [ 1, 0, 0 ],
+      { pos: [ 1, 1, 1 ], uv: [ 0, 1 ], },
+      { pos: [ 1, 0, 1 ], uv: [ 0, 0 ], },
+      { pos: [ 1, 1, 0 ], uv: [ 1, 1 ], },
+      { pos: [ 1, 0, 0 ], uv: [ 1, 0 ], },
     ],
   },
   { // bas
+    uvRow: 1,
     dir: [  0, -1,  0, ],
     corners: [
-      [ 1, 0, 1 ],
-      [ 0, 0, 1 ],
-      [ 1, 0, 0 ],
-      [ 0, 0, 0 ],
+      { pos: [ 1, 0, 1 ], uv: [ 1, 0 ], },
+      { pos: [ 0, 0, 1 ], uv: [ 0, 0 ], },
+      { pos: [ 1, 0, 0 ], uv: [ 1, 1 ], },
+      { pos: [ 0, 0, 0 ], uv: [ 0, 1 ], },
     ],
   },
   { // haut
+    uvRow: 2,
     dir: [  0,  1,  0, ],
     corners: [
-      [ 0, 1, 1 ],
-      [ 1, 1, 1 ],
-      [ 0, 1, 0 ],
-      [ 1, 1, 0 ],
+      { pos: [ 0, 1, 1 ], uv: [ 1, 1 ], },
+      { pos: [ 1, 1, 1 ], uv: [ 0, 1 ], },
+      { pos: [ 0, 1, 0 ], uv: [ 1, 0 ], },
+      { pos: [ 1, 1, 0 ], uv: [ 0, 0 ], },
     ],
   },
   { // arri√®re
+    uvRow: 0,
     dir: [  0,  0, -1, ],
     corners: [
-      [ 1, 0, 0 ],
-      [ 0, 0, 0 ],
-      [ 1, 1, 0 ],
-      [ 0, 1, 0 ],
+      { pos: [ 1, 0, 0 ], uv: [ 0, 0 ], },
+      { pos: [ 0, 0, 0 ], uv: [ 1, 0 ], },
+      { pos: [ 1, 1, 0 ], uv: [ 0, 1 ], },
+      { pos: [ 0, 1, 0 ], uv: [ 1, 1 ], },
     ],
   },
   { // avant
+    uvRow: 0,
     dir: [  0,  0,  1, ],
     corners: [
-      [ 0, 0, 1 ],
-      [ 1, 0, 1 ],
-      [ 0, 1, 1 ],
-      [ 1, 1, 1 ],
+      { pos: [ 0, 0, 1 ], uv: [ 0, 0 ], },
+      { pos: [ 1, 0, 1 ], uv: [ 1, 0 ], },
+      { pos: [ 0, 1, 1 ], uv: [ 0, 1 ], },
+      { pos: [ 1, 1, 1 ], uv: [ 1, 1 ], },
     ],
   },
 ];
</pre>
<p>Et nous pouvons mettre √† jour le code pour utiliser ces donn√©es. Nous devons
conna√Ætre la taille d'une tuile dans la carte de textures et les dimensions
de la texture.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
-  constructor(cellSize) {
-    this.cellSize = cellSize;
+  constructor(options) {
+    this.cellSize = options.cellSize;
+    this.tileSize = options.tileSize;
+    this.tileTextureWidth = options.tileTextureWidth;
+    this.tileTextureHeight = options.tileTextureHeight;
+    const {cellSize} = this;
+    this.cellSliceSize = cellSize * cellSize;
+    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
   }

   ...

   generateGeometryDataForCell(cellX, cellY, cellZ) {
-    const {cellSize} = this;
+    const {cellSize, tileSize, tileTextureWidth, tileTextureHeight} = this;
     const positions = [];
     const normals = [];
+    const uvs = [];
     const indices = [];
     const startX = cellX * cellSize;
     const startY = cellY * cellSize;
     const startZ = cellZ * cellSize;

     for (let y = 0; y &lt; cellSize; ++y) {
       const voxelY = startY + y;
       for (let z = 0; z &lt; cellSize; ++z) {
         const voxelZ = startZ + z;
         for (let x = 0; x &lt; cellSize; ++x) {
           const voxelX = startX + x;
           const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
           if (voxel) {
-            const uvVoxel = voxel - 1;  // voxel 0 is sky so for UVs we start at 0
-            // There is a voxel here but do we need faces for it?
+            const uvVoxel = voxel - 1;  // le voxel 0 est le ciel, donc pour les UV, nous commen√ßons √† 0
+            // Il y a un voxel ici, mais avons-nous besoin de faces pour lui ?
-            for (const {dir, corners} of VoxelWorld.faces) {
+            for (const {dir, corners, uvRow} of VoxelWorld.faces) {
               const neighbor = this.getVoxel(
                   voxelX + dir[0],
                   voxelY + dir[1],
                   voxelZ + dir[2]);
               if (!neighbor) {
-                // this voxel has no neighbor in this direction so we need a face.
+                // ce voxel n'a pas de voisin dans cette direction, nous avons donc besoin d'une face.
                 const ndx = positions.length / 3;
-                for (const pos of corners) {
+                for (const {pos, uv} of corners) {
                   positions.push(pos[0] + x, pos[1] + y, pos[2] + z);
                   normals.push(...dir);
+                  uvs.push(
+                        (uvVoxel +   uv[0]) * tileSize / tileTextureWidth,
+                    1 - (uvRow + 1 - uv[1]) * tileSize / tileTextureHeight);
                 }
                 indices.push(
                   ndx, ndx + 1, ndx + 2,
                   ndx + 2, ndx + 1, ndx + 3,
                 );
               }
             }
           }
         }
       }
     }

     return {
       positions,
       normals,
+      uvs,
       indices,
     };
   }
}
</pre>
<p>Nous devons ensuite <a href="textures.html">charger la texture</a></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const loader = new THREE.TextureLoader();
const texture = loader.load('resources/images/minecraft/flourish-cc-by-nc-sa.png', render);
texture.magFilter = THREE.NearestFilter;
texture.minFilter = THREE.NearestFilter;
texture.colorSpace = THREE.SRGBColorSpace;
</pre>
<p>et passer les param√®tres √† la classe <code class="notranslate" translate="no">VoxelWorld</code></p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const tileSize = 16;
+const tileTextureWidth = 256;
+const tileTextureHeight = 64;
-const world = new VoxelWorld(cellSize);
+const world = new VoxelWorld({
+  cellSize,
+  tileSize,
+  tileTextureWidth,
+  tileTextureHeight,
+});
</pre>
<p>Utilisons r√©ellement les UV lorsque nous cr√©ons la g√©om√©trie
et la texture lorsque nous cr√©ons le mat√©riau</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const {positions, normals, indices} = world.generateGeometryDataForCell(0, 0, 0);
+const {positions, normals, uvs, indices} = world.generateGeometryDataForCell(0, 0, 0);
 const geometry = new THREE.BufferGeometry();
 -const material = new THREE.MeshLambertMaterial({color: 'green'});
+const material = new THREE.MeshLambertMaterial({
+  map: texture,
+  side: THREE.DoubleSide,
+  alphaTest: 0.1,
+  transparent: true,
+});

 const positionNumComponents = 3;
 const normalNumComponents = 3;
+const uvNumComponents = 2;
 geometry.setAttribute(
     'position',
     new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
 geometry.setAttribute(
     'normal',
     new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
+geometry.setAttribute(
+    'uv',
+    new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
 geometry.setIndex(indices);
 const mesh = new THREE.Mesh(geometry, material);
 scene.add(mesh);
</pre>
<p>Une derni√®re chose, nous devons effectivement configurer certains voxels
pour utiliser diff√©rentes textures.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const height = (Math.sin(x / cellSize * Math.PI * 2) + Math.sin(z / cellSize * Math.PI * 3)) * (cellSize / 6) + (cellSize / 2);
      if (y &lt; height) {
-        world.setVoxel(x, y, z, 1);
+        world.setVoxel(x, y, z, randInt(1, 17));
       }
     }
   }
 }

+function randInt(min, max) {
+  return Math.floor(Math.random() * (max - min) + min);
+}
</pre>
<p>et avec cela, nous obtenons des textures !</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/voxel-geometry-culled-faces-with-textures.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/voxel-geometry-culled-faces-with-textures.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Faisons en sorte qu'il supporte plus d'une cellule.</p>
<p>Pour ce faire, stockons les cellules dans un objet en utilisant des identifiants de cellule.
Un identifiant de cellule sera simplement les coordonn√©es d'une cellule s√©par√©es par
une virgule. En d'autres termes, si nous demandons le voxel 35,0,0
qui est dans la cellule 1,0,0, son identifiant est <code class="notranslate" translate="no">"1,0,0"</code>.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(options) {
    this.cellSize = options.cellSize;
    this.tileSize = options.tileSize;
    this.tileTextureWidth = options.tileTextureWidth;
    this.tileTextureHeight = options.tileTextureHeight;
    const {cellSize} = this;
    this.cellSliceSize = cellSize * cellSize;
-    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
+    this.cells = {};
  }
+  computeCellId(x, y, z) {
+    const {cellSize} = this;
+    const cellX = Math.floor(x / cellSize);
+    const cellY = Math.floor(y / cellSize);
+    const cellZ = Math.floor(z / cellSize);
+    return `${cellX},${cellY},${cellZ}`;
+  }
+  getCellForVoxel(x, y, z) {
-    const cellX = Math.floor(x / cellSize);
-    const cellY = Math.floor(y / cellSize);
-    const cellZ = Math.floor(z / cellSize);
-    if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
-      return null;
-    }
-    return this.cell;
+    return this.cells[this.computeCellId(x, y, z)];
   }

   ...
}
</pre>
<p>et maintenant nous pouvons faire en sorte que <code class="notranslate" translate="no">setVoxel</code> ajoute de nouvelles cellules si
nous essayons de d√©finir un voxel dans une cellule qui n'existe pas encore</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  setVoxel(x, y, z, v) {
-    const cell = this.getCellForVoxel(x, y, z);
+    let cell = this.getCellForVoxel(x, y, z);
     if (!cell) {
-      return 0;
+      cell = this.addCellForVoxel(x, y, z);
     }
     const voxelOffset = this.computeVoxelOffset(x, y, z);
     cell[voxelOffset] = v;
   }
+  addCellForVoxel(x, y, z) {
+    const cellId = this.computeCellId(x, y, z);
+    let cell = this.cells[cellId];
+    if (!cell) {
+      const {cellSize} = this;
+      cell = new Uint8Array(cellSize * cellSize * cellSize);
+      this.cells[cellId] = cell;
+    }
+    return cell;
+  }
</pre>
<p>Rendons cela modifiable.</p>
<p>Tout d'abord, nous allons ajouter une interface utilisateur. En utilisant des boutons radio, nous pouvons cr√©er un
tableau de tuiles 8x2</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;body&gt;
  &lt;canvas id="c"&gt;&lt;/canvas&gt;
+  &lt;div id="ui"&gt;
+    &lt;div class="tiles"&gt;
+      &lt;input type="radio" name="voxel" id="voxel1" value="1"&gt;&lt;label for="voxel1" style="background-position:   -0% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel2" value="2"&gt;&lt;label for="voxel2" style="background-position: -100% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel3" value="3"&gt;&lt;label for="voxel3" style="background-position: -200% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel4" value="4"&gt;&lt;label for="voxel4" style="background-position: -300% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel5" value="5"&gt;&lt;label for="voxel5" style="background-position: -400% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel6" value="6"&gt;&lt;label for="voxel6" style="background-position: -500% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel7" value="7"&gt;&lt;label for="voxel7" style="background-position: -600% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel8" value="8"&gt;&lt;label for="voxel8" style="background-position: -700% -0%"&gt;&lt;/label&gt;
+    &lt;/div&gt;
+    &lt;div class="tiles"&gt;
+      &lt;input type="radio" name="voxel" id="voxel9"  value="9" &gt;&lt;label for="voxel9"  style="background-position:  -800% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel10" value="10"&gt;&lt;label for="voxel10" style="background-position:  -900% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel11" value="11"&gt;&lt;label for="voxel11" style="background-position: -1000% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel12" value="12"&gt;&lt;label for="voxel12" style="background-position: -1100% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel13" value="13"&gt;&lt;label for="voxel13" style="background-position: -1200% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel14" value="14"&gt;&lt;label for="voxel14" style="background-position: -1300% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel15" value="15"&gt;&lt;label for="voxel15" style="background-position: -1400% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel16" value="16"&gt;&lt;label for="voxel16" style="background-position: -1500% -0%"&gt;&lt;/label&gt;
+    &lt;/div&gt;
+  &lt;/div&gt;
&lt;/body&gt;
</pre>
<p>Et ajoutons un peu de CSS pour le styliser, afficher les tuiles et mettre en √©vidence
la s√©lection actuelle</p>
<pre class="prettyprint showlinemods notranslate lang-css" translate="no">body {
    margin: 0;
}
#c {
    width: 100%;
    height: 100%;
    display: block;
}
+#ui {
+    position: absolute;
+    left: 10px;
+    top: 10px;
+    background: rgba(0, 0, 0, 0.8);
+    padding: 5px;
+}
+#ui input[type=radio] {
+  width: 0;
+  height: 0;
+  display: none;
+}
+#ui input[type=radio] + label {
+  background-image: url('resources/images/minecraft/flourish-cc-by-nc-sa.png');
+  background-size: 1600% 400%;
+  image-rendering: pixelated;
+  width: 64px;
+  height: 64px;
+  display: inline-block;
+}
+#ui input[type=radio]:checked + label {
+  outline: 3px solid red;
+}
+@media (max-width: 600px), (max-height: 600px) {
+  #ui input[type=radio] + label {
+    width: 32px;
+    height: 32px;
+  }
+}
</pre>
<p>L'UX sera la suivante. Si aucune tuile n'est s√©lectionn√©e et que vous cliquez sur un voxel,
ce voxel sera effac√©, ou si vous cliquez sur un voxel et maintenez la touche Maj enfonc√©e,
il sera effac√©. Sinon, si une tuile est s√©lectionn√©e, elle sera ajout√©e. Vous pouvez
d√©s√©lectionner le type de tuile s√©lectionn√© en cliquant √† nouveau dessus.</p>
<p>Ce code permettra √† l'utilisateur de d√©s√©lectionner le
bouton radio mis en √©vidence.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">let currentVoxel = 0;
let currentId;

document.querySelectorAll('#ui .tiles input[type=radio][name=voxel]').forEach((elem) =&gt; {
  elem.addEventListener('click', allowUncheck);
});

function allowUncheck() {
  if (this.id === currentId) {
    this.checked = false;
    currentId = undefined;
    currentVoxel = 0;
  } else {
    currentId = this.id;
    currentVoxel = parseInt(this.value);
  }
}
</pre>
<p>Et le code ci-dessous nous permettra de d√©finir un voxel en fonction de l'endroit o√π
l'utilisateur clique. Il utilise un code similaire √† celui que nous
avons cr√©√© dans <a href="picking.html">l'article sur le picking</a>,
mais il n'utilise pas le <code class="notranslate" translate="no">RayCaster</code> int√©gr√©. Au lieu de cela,
il utilise <code class="notranslate" translate="no">VoxelWorld.intersectRay</code> qui renvoie
la position de l'intersection et la normale de la face
touch√©e.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function getCanvasRelativePosition(event) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (event.clientX - rect.left) * canvas.width  / rect.width,
    y: (event.clientY - rect.top ) * canvas.height / rect.height,
  };
}

function placeVoxel(event) {
  const pos = getCanvasRelativePosition(event);
  const x = (pos.x / canvas.width ) *  2 - 1;
  const y = (pos.y / canvas.height) * -2 + 1;  // noter que nous inversons Y

  const start = new THREE.Vector3();
  const end = new THREE.Vector3();
  start.setFromMatrixPosition(camera.matrixWorld);
  end.set(x, y, 1).unproject(camera);

  const intersection = world.intersectRay(start, end);
  if (intersection) {
    const voxelId = event.shiftKey ? 0 : currentVoxel;
    // le point d'intersection est sur la face. Cela signifie
    // l'impr√©cision math√©matique pourrait nous placer de chaque c√¥t√© de la face.
    // donc entrer d'une demi-normale dans le voxel si suppression (currentVoxel = 0)
    // ou sortir du voxel si ajout (currentVoxel  &gt; 0)
    const pos = intersection.position.map((v, ndx) =&gt; {
      return v + intersection.normal[ndx] * (voxelId &gt; 0 ? 0.5 : -0.5);
    });
    world.setVoxel(...pos, voxelId);
    updateVoxelGeometry(...pos);
    requestRenderIfNotRequested();
  }
}

const mouse = {
  x: 0,
  y: 0,
};

function recordStartPosition(event) {
  mouse.x = event.clientX;
  mouse.y = event.clientY;
  mouse.moveX = 0;
  mouse.moveY = 0;
}
function recordMovement(event) {
  mouse.moveX += Math.abs(mouse.x - event.clientX);
  mouse.moveY += Math.abs(mouse.y - event.clientY);
}
function placeVoxelIfNoMovement(event) {
  if (mouse.moveX &lt; 5 &amp;&amp; mouse.moveY &lt; 5) {
    placeVoxel(event);
  }
  window.removeEventListener('pointermove', recordMovement);
  window.removeEventListener('pointerup', placeVoxelIfNoMovement);
}
canvas.addEventListener('pointerdown', (event) =&gt; {
  event.preventDefault();
  recordStartPosition(event);
  window.addEventListener('pointermove', recordMovement);
  window.addEventListener('pointerup', placeVoxelIfNoMovement);
}, {passive: false});
canvas.addEventListener('touchstart', (event) =&gt; {
  // arr√™ter le d√©filement
  event.preventDefault();
}, {passive: false});
</pre>
<p>Il se passe beaucoup de choses dans le code ci-dessus. Fondamentalement, la souris
a un double usage. L'un est de d√©placer la cam√©ra. L'autre est d'√©diter le monde.
Placer/effacer un voxel se produit lorsque vous rel√¢chez la souris,
mais seulement si vous n'avez pas d√©plac√© la souris depuis que vous avez appuy√© pour la premi√®re fois.
C'est juste une supposition que si vous avez boug√© la souris, vous essayiez de d√©placer la cam√©ra, pas de placer un bloc. <code class="notranslate" translate="no">moveX</code> et <code class="notranslate" translate="no">moveY</code> sont
en mouvement absolu, donc si vous vous d√©placez de 10 vers la gauche puis de 10 vers la droite, vous aurez boug√© de 20 unit√©s. Dans ce cas, l'utilisateur √©tait probablement
juste en train de faire pivoter le mod√®le et ne voulait pas
placer de bloc. Je n'ai fait aucun test pour voir si <code class="notranslate" translate="no">5</code> est une bonne plage ou non. </p>
<p>Dans le code, nous appelons <code class="notranslate" translate="no">world.setVoxel</code> pour d√©finir un voxel, puis
<code class="notranslate" translate="no">updateVoxelGeometry</code> pour mettre √† jour la g√©om√©trie three.js
en fonction des changements.</p>
<p>Cr√©ons cela maintenant. Si l'utilisateur clique sur un
voxel au bord d'une cellule, la g√©om√©trie du voxel
dans la cellule adjacente pourrait n√©cessiter une nouvelle g√©om√©trie. Cela signifie
que nous devons v√©rifier la cellule du voxel que nous venons de modifier,
ainsi que dans les 6 directions √† partir de cette cellule.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const neighborOffsets = [
  [ 0,  0,  0], // soi-m√™me
  [-1,  0,  0], // gauche
  [ 1,  0,  0], // droite
  [ 0, -1,  0], // bas
  [ 0,  1,  0], // haut
  [ 0,  0, -1], // arri√®re
  [ 0,  0,  1], // avant
];
function updateVoxelGeometry(x, y, z) {
  const updatedCellIds = {};
  for (const offset of neighborOffsets) {
    const ox = x + offset[0];
    const oy = y + offset[1];
    const oz = z + offset[2];
    const cellId = world.computeCellId(ox, oy, oz);
    if (!updatedCellIds[cellId]) {
      updatedCellIds[cellId] = true;
      updateCellGeometry(ox, oy, oz);
    }
  }
}
</pre>
<p>J'ai pens√© √† v√©rifier les cellules adjacentes comme ceci </p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
if (voxelX === 0) {
  // mettre √† jour la cellule √† gauche
} else if (voxelX === cellSize - 1) {
  // mettre √† jour la cellule √† droite
}
</pre>
<p>et il y aurait 4 autres v√©rifications pour les 4 autres directions,
mais il m'est apparu que le code serait beaucoup plus simple avec
juste un tableau d'offsets et en enregistrant les identifiants des cellules
d√©j√† mises √† jour. Si le voxel modifi√© n'est pas
sur le bord d'une cellule, le test rejettera rapidement la mise √† jour de la m√™me cellule.</p>
<p>Pour <code class="notranslate" translate="no">updateCellGeometry</code>, nous allons simplement reprendre le code que nous
avions auparavant qui g√©n√©rait la g√©om√©trie pour une cellule
et le faire g√©rer plusieurs cellules.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const cellIdToMesh = {};
function updateCellGeometry(x, y, z) {
  const cellX = Math.floor(x / cellSize);
  const cellY = Math.floor(y / cellSize);
  const cellZ = Math.floor(z / cellSize);
  const cellId = world.computeCellId(x, y, z);
  let mesh = cellIdToMesh[cellId];
  const geometry = mesh ? mesh.geometry : new THREE.BufferGeometry();

  const {positions, normals, uvs, indices} = world.generateGeometryDataForCell(cellX, cellY, cellZ);
  const positionNumComponents = 3;
  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
  const normalNumComponents = 3;
  geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
  const uvNumComponents = 2;
  geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
  geometry.setIndex(indices);
  geometry.computeBoundingSphere();

  if (!mesh) {
    mesh = new THREE.Mesh(geometry, material);
    mesh.name = cellId;
    cellIdToMesh[cellId] = mesh;
    scene.add(mesh);
    mesh.position.set(cellX * cellSize, cellY * cellSize, cellZ * cellZ * cellSize);
  }
}
</pre>
<p>Le code ci-dessus v√©rifie une correspondance entre les identifiants de cellule et les maillages. Si
nous demandons une cellule qui n'existe pas, un nouveau <a href="/docs/#api/en/objects/Mesh"><code class="notranslate" translate="no">Mesh</code></a> est cr√©√©
et ajout√© √† la bonne position dans l'espace mondial.
√Ä la fin, nous mettons √† jour les attributs et les indices avec les nouvelles donn√©es.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/voxel-geometry-culled-faces-ui.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/voxel-geometry-culled-faces-ui.html" target="_blank">cliquez ici pour ouvrir dans une fen√™tre s√©par√©e</a>
</div>

<p></p>
<p>Quelques remarques :</p>
<p><code class="notranslate" translate="no">RayCaster</code> aurait pu fonctionner parfaitement. Je ne l'ai pas essay√©.
√Ä la place, j'ai trouv√© <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.42.3443&rep=rep1&type=pdf">un raycaster sp√©cifique aux voxels</a>
qui est optimis√© pour les voxels.</p>
<p>J'ai int√©gr√© <code class="notranslate" translate="no">intersectRay</code> √† VoxelWorld car il semblait
que si cela devenait trop lent, nous pourrions lancer des rayons contre les cellules
avant de le faire sur les voxels, comme simple acc√©l√©ration si cela devient
trop lent.</p>
<p>Vous pourriez vouloir modifier la longueur du lancer de rayon
car actuellement, il va jusqu'au Z-far. Je m'attends √† ce que si l'utilisateur clique sur quelque chose de trop √©loign√©, il ne veuille pas vraiment
placer des blocs de l'autre c√¥t√© du monde qui
sont de 1 ou 2 pixels de large.</p>
<p>Appeler <code class="notranslate" translate="no">geometry.computeBoundingSphere</code> pourrait √™tre lent.
Nous pourrions simplement d√©finir manuellement la sph√®re englobante pour qu'elle corresponde √†
la cellule enti√®re.</p>
<p>Voulons-nous supprimer les cellules si tous les voxels de cette cellule sont 0 ?
Ce serait probablement un changement raisonnable si nous voulions livrer cela.</p>
<p>En r√©fl√©chissant √† la fa√ßon dont cela fonctionne, il est clair que le
pire cas absolu est un damier de voxels activ√©s et d√©sactiv√©s. Je ne sais pas
imm√©diatement quelles autres strat√©gies utiliser
si les choses deviennent trop lentes. Peut-√™tre que le fait que cela devienne trop lent
encouragerait simplement l'utilisateur √† ne pas cr√©er d'√©normes zones en damier.</p>
<p>Pour rester simple, la carte de textures est juste 1 colonne
par type de voxel. Il serait pr√©f√©rable de faire quelque chose de plus
flexible o√π nous aurions un tableau des types de voxels et o√π chaque
type pourrait sp√©cifier l'emplacement de ses textures de face dans la carte.
En l'√©tat, beaucoup d'espace est gaspill√©.</p>
<p>En regardant le vrai Minecraft, il y a des tuiles qui ne sont pas
des voxels, pas des cubes. Comme une tuile de cl√¥ture ou des fleurs. Pour cela,
il nous faudrait √† nouveau un tableau des types de voxels et, pour chaque
voxel, si c'est un cube ou une autre g√©om√©trie. Si ce n'est
pas un cube, la v√©rification des voisins lors de la g√©n√©ration de la g√©om√©trie
devrait √©galement changer. Un voxel de fleur √† c√¥t√© d'un autre
voxel ne devrait pas supprimer les faces entre eux.</p>
<p>Si vous souhaitez cr√©er quelque chose de similaire √† Minecraft en utilisant three.js,
j'esp√®re que cela vous a donn√© quelques id√©es sur les points de d√©part et sur la mani√®re
de g√©n√©rer une g√©om√©trie plus ou moins efficace.</p>
<p><canvas id="c"></canvas></p>
<script type="module" src="../resources/threejs-voxel-geometry.js"></script>


        </div>
      </div>
    </div>

  <script src="../resources/prettify.js"></script>
  <script src="../resources/lesson.js"></script>




</body></html>