<!DOCTYPE html><html lang="ko"><head>
    <meta charset="utf-8">
    <title>ë³µì…€ Geometry</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@threejs">
    <meta name="twitter:title" content="Three.js â€“ ë³µì…€ Geometry">
    <meta property="og:image" content="https://threejs.org/files/share.png">
    <link rel="shortcut icon" href="/files/favicon_white.ico" media="(prefers-color-scheme: dark)">
    <link rel="shortcut icon" href="/files/favicon.ico" media="(prefers-color-scheme: light)">

    <link rel="stylesheet" href="/manual/resources/lesson.css">
    <link rel="stylesheet" href="/manual/resources/lang.css">
    <link rel="stylesheet" href="/manual/ko/lang.css">
  </head>
  <body>
    <div class="container">
      <div class="lesson-title">
        <h1>ë³µì…€ Geometry</h1>
      </div>
      <div class="lesson">
        <div class="lesson-main">
          <p>â€» <a href="https://ko.wikipedia.org/wiki/%EB%B3%B5%EC%85%80">ë³µì…€</a>: Voxel, ë³¼ë¥¨(volume, ë¶€í”¼)ê³¼ í”½ì…€(pixel)ì˜ í•©ì„±ì–´ë¡œ, ë§ˆì¸í¬ë˜í”„íŠ¸ì˜ ë¸”ë¡ì²˜ëŸ¼ ë¶€í”¼ê°€ ìˆëŠ” í”½ì…€ì„ ë§í•©ë‹ˆë‹¤. ì—­ì£¼.</p>
<p>ì´ ì£¼ì œëŠ” ê½¤ ë§ì€ ì»¤ë®¤ë‹ˆí‹°ì— ê³µí†µì ìœ¼ë¡œ ì˜¬ë¼ì˜¤ëŠ” ì£¼ì œì…ë‹ˆë‹¤. "ë§ˆì¸í¬ë˜í”„íŠ¸ ë¸”ë¡ ê°™ì€ ë³µì…€ì„ ì–´ë–»ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‚˜ìš”?"ë¼ëŠ” ê²ƒì´ì£ .</p>
<p>ëŒ€ë¶€ë¶„ì˜ ì´ˆì‹¬ìê°€ ì´ë¥¼ ì •ìœ¡ë©´ì²´ geometryë¥¼ ë§Œë“¤ê³  ê° ë³µì…€ì˜ ìœ„ì¹˜ì— meshë¥¼ ë”°ë¡œ ë§Œë“¤ì–´ êµ¬í˜„í•˜ë ¤ê³  í•©ë‹ˆë‹¤. ì¬ë¯¸ì‚¼ì•„ ì´ ë°©ì‹ìœ¼ë¡œ í•œ ë²ˆ êµ¬í˜„í•´ë³´ì£ . ë¨¼ì € 256x256x256ì§œë¦¬ ë³µì…€ íë¸Œë¥¼ ë§Œë“¤ê¸° ìœ„í•´ 16,777,216ê°œì˜ ìš”ì†Œë¥¼ ê°€ì§„ <code class="notranslate" translate="no">Uint8Array</code>ë¥¼ ë§Œë“­ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const cellSize = 256;
const cell = new Uint8Array(cellSize * cellSize * cellSize);
</pre>
<p>ê·¸ë¦¬ê³  ì‚¬ì¸(sine) í•¨ìˆ˜ ê³¡ì„ ìœ¼ë¡œ ì–¸ë•ì„ í•œ ê²¹ ë§Œë“­ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const height = (Math.sin(x / cellSize * Math.PI * 4) + Math.sin(z / cellSize * Math.PI * 6)) * 20 + cellSize / 2;
      if (height &gt; y &amp;&amp; height &lt; y + 1) {
        const offset = y * cellSize * cellSize +
                       z * cellSize +
                       x;
        cell[offset] = 1;
      }
    }
  }
}
</pre>
<p>ë‹¤ìŒìœ¼ë¡œ ëª¨ë“  ë¸”ëŸ­ì„ ëŒë©´ì„œ 0ì´ ì•„ë‹ ê²½ìš° ì •ìœ¡ë©´ì²´ë¥¼ ìƒˆë¡œ ë§Œë“­ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshPhongMaterial({ color: 'green' });

for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const offset = y * cellSize * cellSize +
                     z * cellSize +
                     x;
      const block = cell[offset];
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, y, z);
      scene.add(mesh);
    }
  }
}
</pre>
<p>ë‚˜ë¨¸ì§€ ì½”ë“œëŠ” <a href="rendering-on-demand.html">ë¶ˆí•„ìš”í•œ ë Œë”ë§ ì œê±°í•˜ê¸°</a>ì—ì„œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/voxel-geometry-separate-cubes.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/voxel-geometry-separate-cubes.html" target="_blank">ìƒˆ íƒ­ì—ì„œ ë³´ê¸°</a>
</div>

<p></p>
<p>ì²˜ìŒ ì´ˆê¸°í™”í•˜ëŠ” ë°ë„ ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¬ê³  ì¹´ë©”ë¼ë¥¼ ì›€ì§ì´ë©´ êµ‰ì¥íˆ ë²„ë²…ì¼ ê²ë‹ˆë‹¤. <a href="optimize-lots-of-objects.html">ë‹¤ì¤‘ ìš”ì†Œ ìµœì í™”í•˜ê¸°</a>ì˜ ê²½ìš°ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ë„ˆë¬´ ë§ì€ ë¬¼ì²´ê°€ ìˆëŠ” íƒ“ì´ì£ . 256x256, ìœ¡ë©´ì²´ê°€ ì´ 65,536ê°œë‚˜ ìˆìœ¼ë‹ˆ ê·¸ëŸ´ ë§Œí•©ë‹ˆë‹¤.</p>
<p><a href="rendering-on-demand.html">geometryë¥¼ í•©ì¹˜ë©´</a> ì´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‚´ì¹œê¹€ì— ì–¸ë• í•œ ê²¹ì´ ì•„ë‹ˆë¼ ë•…ê¹Œì§€ ë³µì…€ì„ ì±„ì›Œë³´ë„ë¡ í•˜ì£ . ë°˜ë³µë¬¸ì„ ë‹¤ìŒì²˜ëŸ¼ ìˆ˜ì •í•´ ë¹ˆ ê³µê°„ì„ ì „ë¶€ ì±„ìš°ë„ë¡ í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const height = (Math.sin(x / cellSize * Math.PI * 4) + Math.sin(z / cellSize * Math.PI * 6)) * 20 + cellSize / 2;
-      if (height &gt; y &amp;&amp; height &lt; y + 1) {
+      if (height &lt; y + 1) {
        const offset = y * cellSize * cellSize +
                       z * cellSize +
                       x;
        cell[offset] = 1;
      }
    }
  }
}
</pre>
<p>í…ŒìŠ¤íŠ¸ë¥¼ ëŒë ¤ë´¤ë”ë‹ˆ ì ì‹œ ë©ˆì·„ë‹¤ê°€ <em>out of memery</em> ì˜¤ë¥˜ê°€ ëœ¹ë‹ˆë‹¤ ğŸ˜….</p>
<p>ëª‡ ê°€ì§€ ë¬¸ì œê°€ ìˆì„ í…Œì§€ë§Œ í˜„ì¬ ê°€ì¥ í° ë¬¸ì œëŠ” ì „í˜€ ë³¼ ì¼ì´ ì—†ëŠ” ì •ìœ¡ë©´ì²´ ì•ˆìª½ë„ ë Œë”ë§í•œë‹¤ëŠ” ê²ë‹ˆë‹¤.</p>
<p>ì‰½ê²Œ ì„¤ëª…í•´ ë³µì…€ë¡œ ì´ë£¨ì–´ì§„ 3x2x2ì§œë¦¬ ìœ¡ë©´ì²´ê°€ ìˆë‹¤ê³  í•´ë³´ì£ . ê° ë³µì…€ì„ í•©ì¹˜ë©´ ì•„ë˜ì™€ ê°™ì€ ëª¨ìŠµì´ ë  ê²ë‹ˆë‹¤.</p>
<div class="spread">
  <div data-diagram="mergedCubes" style="height: 300px;"></div>
</div>

<p>ë¬¸ì œë¥¼ í•´ê²°í•˜ë ¤ë©´ ì•„ë˜ì™€ ê°™ì€ í˜•íƒœë¡œ êµ¬í˜„í•´ì•¼ í•˜ì£ .</p>
<div class="spread">
  <div data-diagram="culledCubes" style="height: 300px;"></div>
</div>

<p>ìœ„ìª½ ì˜ˆì œì—ëŠ” ë³µì…€ ì‚¬ì´ì— ë©´ë“¤ì´ ìˆìŠµë‹ˆë‹¤. ë°–ì—ì„œëŠ” ì „í˜€ ë³¼ ì¼ì´ ì—†ê¸°ì— ë¶ˆí•„ìš”í•œ ê²ƒë“¤ì´ì£ . ê±°ê¸°ë‹¤ ê° ë³µì…€ ì‚¬ì´ì—ëŠ” ë©´ì´ í•˜ë‚˜ë„ ì•„ë‹ˆê³  ë§ˆì£¼ ë³´ëŠ” ë©´ë‹¹ í•˜ë‚˜ì”©, ì´ ë‘ ê°œê°€ ìˆìŠµë‹ˆë‹¤. ì´ ì—­ì‹œ ë‚­ë¹„ì´ì£ . ë³µì…€ì— ì´ëŸ° ë©´ë“¤ì´ ë§ì•„ì§ˆìˆ˜ë¡ ì„±ëŠ¥ì€ ì²˜ì°¸í•´ì§ˆ ê²ë‹ˆë‹¤.</p>
<p>ì´ì¯¤ì—ì„œ ê·¸ëƒ¥ ë§í•´ì•¼ê² ë„¤ìš”. ë‹¨ìˆœíˆ geometryë¥¼ í•©ì³ë²„ë ¤ì„œëŠ” ì´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë³µì…€ì´ ì„œë¡œ ë§ˆì£¼ ë³¸ë‹¤ë©´ í•´ë‹¹ ë©´ì„ ë§Œë“¤ì§€ ì•Šë„ë¡ ì§ì ‘ ë³µì…€ì„ ë§Œë“¤ì–´ì•¼ í•˜ì£ .</p>
<p>ë‹¤ë¥¸ ë¬¸ì œëŠ” í¬ê¸°ê°€ ë„ˆë¬´ í¬ë‹¤ëŠ” ê²ë‹ˆë‹¤. 256x256x256ì´ë©´ 16MB ì •ë„ë¡œ ë©”ëª¨ë¦¬ ì ìœ ìœ¨ì´ ê½¤ í° í¸ì— ì†í•˜ì£ . íŠ¹íˆ ë¹ˆ ê³µê°„ì€ ì•„ë¬´ê²ƒë„ ìˆì„ í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. ë³µì…€ì˜ ìˆ«ìë„ ì•½ ì²œìœ¡ë°±ë§Œ ê°œê°€ ë„˜ìœ¼ë‹ˆ ì—°ì‚°ì´ ë²„ê±°ìš¸ ë§Œí•©ë‹ˆë‹¤.</p>
<p>í•œ ê°€ì§€ í•´ê²° ë°©ë²•ì€ ì˜ì—­ì„ ì‘ì€ ì˜ì—­ìœ¼ë¡œ ìª¼ê°œëŠ” ê²ë‹ˆë‹¤. ì•„ë¬´ê²ƒë„ ì—†ëŠ” ì˜ì—­ì—ëŠ” ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•  í•„ìš”ê°€ ì—†ìœ¼ë‹ˆ, 32x32x32 í¬ê¸°(32KB)ì˜ ì˜ì—­ì„ ë§Œë“¤ì–´ ì•ˆì— ìš”ì†Œê°€ ìˆëŠ” ì˜ì—­ë§Œ ë Œë”ë§í•˜ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤. ì´ 32x32x32 ì˜ì—­ì€ í¸ì˜ìƒ "cell"ì´ë¼ê³  ë¶€ë¥´ë„ë¡ í•˜ì£ .</p>
<p>ë¨¼ì € ë³µì…€ ë°ì´í„°ë¥¼ ê´€ë¦¬í•  í´ë˜ìŠ¤ë¥¼ ë§Œë“­ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
  }
}
</pre>
<p>ë‹¤ìŒìœ¼ë¡œ ê° cellì˜ geometryë¥¼ ìƒì„±í•˜ëŠ” ë©”ì„œë“œë¥¼ ì‘ì„±í•©ë‹ˆë‹¤. ì´ ë©”ì„œë“œëŠ” cellì˜ ìœ„ì¹˜ê°’ì„ ì¸ìë¡œ ë°›ëŠ”ë°, ì‰½ê²Œ ë§í•´ (xì¶• 0-31, yì¶• 0-31, zì¶• 0-31)ì„ í¬í•¨í•˜ëŠ” ë³µì…€ë“¤ì„ ìƒì„±í•˜ë ¤ë©´ (0,0,0)ì„ ë„˜ê²¨ì£¼ë©´ ë©ë‹ˆë‹¤. (xì¶• 32-63, yì¶• 0-31, zì¶• 0-31)ì„ í¬í•¨í•˜ëŠ” ë³µì…€ì„ ìƒì„±í•˜ë ¤ë©´ (1,0,0)ì„ ë„˜ê²¨ì£¼ë©´ ë˜ì£ .</p>
<p>ê·¸ë¦¬ê³  ì´ì›ƒí•˜ëŠ” ë³µì…€ì„ ê²€ì‚¬í•´ì•¼ í•©ë‹ˆë‹¤. ì¼ë‹¨ í•´ë‹¹ ìœ„ì¹˜ì˜ ë³µì…€ê°’ì„ ë°˜í™˜í•˜ëŠ” <code class="notranslate" translate="no">getVoxel</code> ë©”ì„œë“œê°€ ìˆë‹¤ê³  ê°€ì •í•©ì‹œë‹¤. ì˜ˆë¥¼ ë“¤ì–´ cellì˜ í¬ê¸°ê°€ 32ì¼ ê²½ìš°, ì´ ë©”ì„œë“œì— (35,0,0)ì„ ë„˜ê²¨ì£¼ë©´ (1,0,0) ìª½ cellì„ ì°¾ì•„ í•´ë‹¹ cellì˜ (3,0,0)ì— ìœ„ì¹˜í•œ ë³µì…€ê°’ì„ ë°˜í™˜í•  ê²ë‹ˆë‹¤. ë‹¤ë¥¸ cellì˜ ë³µì…€ì´ë¼ê³  í•´ë„ ì´ì›ƒ ë³µì…€ì„ ì–¼ë§ˆë“ ì§€ ì°¾ì•„ë‚¼ ìˆ˜ ìˆë‹¤ëŠ” ì´ì•¼ê¸°ì£ .</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
  }
+  generateGeometryDataForCell(cellX, cellY, cellZ) {
+    const { cellSize } = this;
+    const startX = cellX * cellSize;
+    const startY = cellY * cellSize;
+    const startZ = cellZ * cellSize;
+
+    for (let y = 0; y &lt; cellSize; ++y) {
+      const voxelY = startY + y;
+      for (let z = 0; z &lt; cellSize; ++z) {
+        const voxelZ = startZ + z;
+        for (let x = 0; x &lt; cellSize; ++x) {
+          const voxelX = startX + x;
+          const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
+          if (voxel) {
+            for (const { dir } of VoxelWorld.faces) {
+              const neighbor = this.getVoxel(
+                  voxelX + dir[0],
+                  voxelY + dir[1],
+                  voxelZ + dir[2]);
+              if (!neighbor) {
+                // ì´ ë³µì…€ì€ ì´ ë°©í–¥ì— ì´ì›ƒí•˜ëŠ” ë³µì…€ì´ ì—†ìœ¼ë¯€ë¡œ
+                // ì´ìª½ì— ë©´ì„ ë§Œë“­ë‹ˆë‹¤.
+              }
+            }
+          }
+        }
+      }
+    }
+  }
}

+VoxelWorld.faces = [
+  { // ì™¼ìª½
+    dir: [ -1,  0,  0, ],
+  },
+  { // ì˜¤ë¥¸ìª½
+    dir: [  1,  0,  0, ],
+  },
+  { // ì•„ë˜
+    dir: [  0, -1,  0, ],
+  },
+  { // ìœ„
+    dir: [  0,  1,  0, ],
+  },
+  { // ë’¤
+    dir: [  0,  0, -1, ],
+  },
+  { // ì•
+    dir: [  0,  0,  1, ],
+  },
+];
</pre>
<p>ì´ì œ ì–¸ì œ ë©´ì„ ë§Œë“¤ ê¸°ì¤€ì´ ìƒê²¼ìœ¼ë‹ˆ í•œ ë²ˆ ë©´ë“¤ì„ ë§Œë“¤ì–´ë´…ì‹œë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
  }
  generateGeometryDataForCell(cellX, cellY, cellZ) {
    const { cellSize } = this;
+    const positions = [];
+    const normals = [];
+    const indices = [];
    const startX = cellX * cellSize;
    const startY = cellY * cellSize;
    const startZ = cellZ * cellSize;

    for (let y = 0; y &lt; cellSize; ++y) {
      const voxelY = startY + y;
      for (let z = 0; z &lt; cellSize; ++z) {
        const voxelZ = startZ + z;
        for (let x = 0; x &lt; cellSize; ++x) {
          const voxelX = startX + x;
          const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
          if (voxel) {
-            for (const { dir } of VoxelWorld.faces) {
+            for (const { dir, corners } of VoxelWorld.faces) {
              const neighbor = this.getVoxel(
                  voxelX + dir[0],
                  voxelY + dir[1],
                  voxelZ + dir[2]);
              if (!neighbor) {
+                // ì´ ë³µì…€ì€ ì´ ë°©í–¥ì— ì´ì›ƒí•˜ëŠ” ë³µì…€ì´ ì—†ìœ¼ë¯€ë¡œ
+                // ì´ìª½ì— ë©´ì„ ë§Œë“­ë‹ˆë‹¤.
+                const ndx = positions.length / 3;
+                for (const pos of corners) {
+                  positions.push(pos[0] + x, pos[1] + y, pos[2] + z);
+                  normals.push(...dir);
+                }
+                indices.push(
+                  ndx, ndx + 1, ndx + 2,
+                  ndx + 2, ndx + 1, ndx + 3,
+                );
              }
            }
          }
        }
      }
    }
+    return {
+      positions,
+      normals,
+      indices,
    };
  }
}

VoxelWorld.faces = [
  { // ì™¼ìª½
    dir: [ -1,  0,  0, ],
+    corners: [
+      [ 0, 1, 0 ],
+      [ 0, 0, 0 ],
+      [ 0, 1, 1 ],
+      [ 0, 0, 1 ],
+    ],
  },
  { // ì˜¤ë¥¸ìª½
    dir: [  1,  0,  0, ],
+    corners: [
+      [ 1, 1, 1 ],
+      [ 1, 0, 1 ],
+      [ 1, 1, 0 ],
+      [ 1, 0, 0 ],
+    ],
  },
  { // ì•„ë˜
    dir: [  0, -1,  0, ],
+    corners: [
+      [ 1, 0, 1 ],
+      [ 0, 0, 1 ],
+      [ 1, 0, 0 ],
+      [ 0, 0, 0 ],
+    ],
  },
  { // ìœ„
    dir: [  0,  1,  0, ],
+    corners: [
+      [ 0, 1, 1 ],
+      [ 1, 1, 1 ],
+      [ 0, 1, 0 ],
+      [ 1, 1, 0 ],
+    ],
  },
  { // ë’¤
    dir: [  0,  0, -1, ],
+    corners: [
+      [ 1, 0, 0 ],
+      [ 0, 0, 0 ],
+      [ 1, 1, 0 ],
+      [ 0, 1, 0 ],
+    ],
  },
  { // ì•
    dir: [  0,  0,  1, ],
+    corners: [
+      [ 0, 0, 1 ],
+      [ 1, 0, 1 ],
+      [ 0, 1, 1 ],
+      [ 1, 1, 1 ],
+    ],
  },
];
</pre>
<p>ìœ„ ì½”ë“œëŠ” ê¸°ë³¸ geometry ë°ì´í„°ë¥¼ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤. ì´ì œ <code class="notranslate" translate="no">getVoxel</code> ë©”ì„œë“œë§Œ ë§Œë“¤ë©´ ë˜ê² ë„¤ìš”. ì¼ë‹¨ ì•½ê°„ì˜ í•˜ë“œì½”ë”©ì„ ë”í•´ cellì„ ë§Œë“­ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
+    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
  }
+  getCellForVoxel(x, y, z) {
+    const { cellSize } = this;
+    const cellX = Math.floor(x / cellSize);
+    const cellY = Math.floor(y / cellSize);
+    const cellZ = Math.floor(z / cellSize);
+    if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
+      return null
+    }
+    return this.cell;
+  }
+  getVoxel(x, y, z) {
+    const cell = this.getCellForVoxel(x, y, z);
+    if (!cell) {
+      return 0;
+    }
+    const { cellSize } = this;
+    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
+    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
+    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
+    const voxelOffset = voxelY * cellSize * cellSize +
+                        voxelZ * cellSize +
+                        voxelX;
+    return cell[voxelOffset];
+  }
  generateGeometryDataForCell(cellX, cellY, cellZ) {

  ...
}
</pre>
<p>ë”±íˆ ë¬¸ì œëŠ” ì—†ì–´ë³´ì…ë‹ˆë‹¤. ë°ì´í„°ë¥¼ ì§€ì •í•  ìˆ˜ ìˆëŠ” <code class="notranslate" translate="no">setVoxel</code> ë©”ì„œë“œë„ ë§Œë“¤ë„ë¡ í•˜ì£ .</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
  }
  getCellForVoxel(x, y, z) {
    const { cellSize } = this;
    const cellX = Math.floor(x / cellSize);
    const cellY = Math.floor(y / cellSize);
    const cellZ = Math.floor(z / cellSize);
    if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
      return null
    }
    return this.cell;
  }
+  setVoxel(x, y, z, v) {
+    let cell = this.getCellForVoxel(x, y, z);
+    if (!cell) {
+      return;  // í•  ì¼: ìƒˆë¡œìš´ cell ì¶”ê°€ ê¸°ëŠ¥?
+    }
+    const { cellSize } = this;
+    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
+    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
+    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
+    const voxelOffset = voxelY * cellSize * cellSize +
+                        voxelZ * cellSize +
+                        voxelX;
+    cell[voxelOffset] = v;
+  }
  getVoxel(x, y, z) {
    const cell = this.getCellForVoxel(x, y, z);
    if (!cell) {
      return 0;
    }
    const {cellSize} = this;
    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
    const voxelOffset = voxelY * cellSize * cellSize +
                        voxelZ * cellSize +
                        voxelX;
    return cell[voxelOffset];
  }
  generateGeometryDataForCell(cellX, cellY, cellZ) {

  ...
}
</pre>
<p>í , ë°˜ë³µë˜ëŠ” ì½”ë“œê°€ ë§ë„¤ìš”. ì½”ë“œë¥¼ ì¢€ ì •ë¦¬í•´ë´…ì‹œë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(cellSize) {
    this.cellSize = cellSize;
+    this.cellSliceSize = cellSize * cellSize;
    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
  }
  getCellForVoxel(x, y, z) {
    const { cellSize } = this;
    const cellX = Math.floor(x / cellSize);
    const cellY = Math.floor(y / cellSize);
    const cellZ = Math.floor(z / cellSize);
    if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
      return null;
    }
    return this.cell;
  }
+  computeVoxelOffset(x, y, z) {
+    const { cellSize, cellSliceSize } = this;
+    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
+    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
+    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
+    return voxelY * cellSliceSize +
+           voxelZ * cellSize +
+           voxelX;
+  }
  setVoxel(x, y, z, v) {
    const cell = this.getCellForVoxel(x, y, z);
    if (!cell) {
      return;  // í•  ì¼: ìƒˆë¡œìš´ cell ì¶”ê°€ ê¸°ëŠ¥?
    }
-    const { cellSize } = this;
-    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
-    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
-    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
-    const voxelOffset = voxelY * cellSize * cellSize +
-                        voxelZ * cellSize +
-                        voxelX;
+    const voxelOffset = this.computeVoxelOffset(x, y, z);
    cell[voxelOffset] = v;
  }
  getVoxel(x, y, z) {
    const cell = this.getCellForVoxel(x, y, z);
    if (!cell) {
      return 0;
    }
-    const { cellSize } = this;
-    const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
-    const voxelY = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
-    const voxelZ = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
-    const voxelOffset = voxelY * cellSize * cellSize +
-                        voxelZ * cellSize +
-                        voxelX;
+    const voxelOffset = this.computeVoxelOffset(x, y, z);
    return cell[voxelOffset];
  }
  generateGeometryDataForCell(cellX, cellY, cellZ) {

  ...
}
</pre>
<p>ë‹¤ìŒìœ¼ë¡œ ì²« ë²ˆì§¸ cellì„ ë³µì…€ë¡œ ì±„ìš°ëŠ” ì½”ë“œë¥¼ ì‘ì„±í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const cellSize = 32;

const world = new VoxelWorld(cellSize);

for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const height = (Math.sin(x / cellSize * Math.PI * 2) + Math.sin(z / cellSize * Math.PI * 3)) * (cellSize / 6) + (cellSize / 2);
      if (y &lt; height) {
        world.setVoxel(x, y, z, 1);
      }
    }
  }
}
</pre>
<p><a href="custom-buffergeometry.html">BufferGeometryì— ê´€í•œ ê¸€</a>ì—ì„œ ë‹¤ë¤˜ë˜ ëŒ€ë¡œ ì‹¤ì œ geometryë¥¼ ìƒì„±í•˜ëŠ” ì½”ë“œë„ ì‘ì„±í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const { positions, normals, indices } = world.generateGeometryDataForCell(0, 0, 0);
const geometry = new THREE.BufferGeometry();
const material = new THREE.MeshLambertMaterial({ color: 'green' });

const positionNumComponents = 3;
const normalNumComponents = 3;
geometry.setAttribute(
    'position',
    new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
geometry.setAttribute(
    'normal',
    new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
geometry.setIndex(indices);
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);
</pre>
<p>í•œ ë²ˆ í…ŒìŠ¤íŠ¸í•´ë³´ì£ .</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/voxel-geometry-culled-faces.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/voxel-geometry-culled-faces.html" target="_blank">ìƒˆ íƒ­ì—ì„œ ë³´ê¸°</a>
</div>

<p></p>
<p>ì˜ ì™„ì„±í•œ ê²ƒ ê°™ë„¤ìš”! ì—¬ê¸°ì— ì‹¤ì œ ë§ˆì¸í¬ë˜í”„íŠ¸ì²˜ëŸ¼ í…ìŠ¤ì²˜ë¥¼ ë„£ì–´ë´…ì‹œë‹¤.</p>
<p>ì¸í„°ë„·ì„ ë’¤ì ¸ ì´ <a href="https://www.minecraftforum.net/forums/mapping-and-modding-java-edition/resource-packs/1245961-16x-1-7-4-wip-flourish">í…ìŠ¤ì²˜ë“¤</a>ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤(ë¼ì´ì„ ìŠ¤: <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA</a>, ì‘ê°€: <a href="https://www.minecraftforum.net/members/Joshtimus">Joshtimus</a>). ê·¸ë¦¬ê³  ì—¬ê¸°ì„œ ëª‡ ê°€ì§€ë¥¼ ì„ì˜ë¡œ ê³¨ë¼ <a href="https://www.google.com/search?q=texture+atlas">í…ìŠ¤ì²˜ ì•„í‹€ë¼ìŠ¤(texture atlas)</a>ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.</p>
<div class="threejs_center"><img class="checkerboard" src="../examples/resources/images/minecraft/flourish-cc-by-nc-sa.png" style="width: 512px; image-rendering: pixelated;"></div>

<p>ì‘ì—…ì„ ê°„ë‹¨íˆ í•˜ê¸° ìœ„í•´ í…ìŠ¤ì²˜ë¥¼ ì—´ë³„ë¡œ ì •ë ¬í–ˆìŠµë‹ˆë‹¤. ì²« ë²ˆì§¸ ì¤„ì€ ë³µì…€ì˜ ì˜†ë©´, ë‘ ë²ˆì§¸ ì¤„ì€ ë³µì…€ì˜ ìœ—ë©´, ì„¸ ë²ˆì§¸ ì¤„ì€ ë³µì…€ì˜ ì•„ë«ë©´ì´ì£ .</p>
<p>ì´ ë°ì´í„°ë¥¼ ë°”íƒ•ìœ¼ë¡œ <code class="notranslate" translate="no">VoxelWorld.faces</code>ì— ê° ë³µì…€ì— ì‚¬ìš©í•  í…ìŠ¤ì²˜ì˜ ì¤„ ë²ˆí˜¸ì™€ ë³µì…€ì˜ ê° ë©´ì— ì‚¬ìš©í•  UV ì¢Œí‘œ ë°ì´í„°ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">VoxelWorld.faces = [
  { // ì™¼ìª½
+    uvRow: 0,
    dir: [ -1,  0,  0, ],
    corners: [
-      [ 0, 1, 0 ],
-      [ 0, 0, 0 ],
-      [ 0, 1, 1 ],
-      [ 0, 0, 1 ],
+      { pos: [ 0, 1, 0 ], uv: [ 0, 1 ], },
+      { pos: [ 0, 0, 0 ], uv: [ 0, 0 ], },
+      { pos: [ 0, 1, 1 ], uv: [ 1, 1 ], },
+      { pos: [ 0, 0, 1 ], uv: [ 1, 0 ], },
    ],
  },
  { // ì˜¤ë¥¸ìª½
+    uvRow: 0,
    dir: [  1,  0,  0, ],
    corners: [
-      [ 1, 1, 1 ],
-      [ 1, 0, 1 ],
-      [ 1, 1, 0 ],
-      [ 1, 0, 0 ],
+      { pos: [ 1, 1, 1 ], uv: [ 0, 1 ], },
+      { pos: [ 1, 0, 1 ], uv: [ 0, 0 ], },
+      { pos: [ 1, 1, 0 ], uv: [ 1, 1 ], },
+      { pos: [ 1, 0, 0 ], uv: [ 1, 0 ], },
    ],
  },
  { // ì•„ë˜
+    uvRow: 1,
    dir: [  0, -1,  0, ],
    corners: [
-      [ 1, 0, 1 ],
-      [ 0, 0, 1 ],
-      [ 1, 0, 0 ],
-      [ 0, 0, 0 ],
+      { pos: [ 1, 0, 1 ], uv: [ 1, 0 ], },
+      { pos: [ 0, 0, 1 ], uv: [ 0, 0 ], },
+      { pos: [ 1, 0, 0 ], uv: [ 1, 1 ], },
+      { pos: [ 0, 0, 0 ], uv: [ 0, 1 ], },
    ],
  },
  { // ìœ„
+    uvRow: 2,
    dir: [  0,  1,  0, ],
    corners: [
-      [ 0, 1, 1 ],
-      [ 1, 1, 1 ],
-      [ 0, 1, 0 ],
-      [ 1, 1, 0 ],
+      { pos: [ 0, 1, 1 ], uv: [ 1, 1 ], },
+      { pos: [ 1, 1, 1 ], uv: [ 0, 1 ], },
+      { pos: [ 0, 1, 0 ], uv: [ 1, 0 ], },
+      { pos: [ 1, 1, 0 ], uv: [ 0, 0 ], },
    ],
  },
  { // ë’¤
+    uvRow: 0,
    dir: [  0,  0, -1, ],
    corners: [
-      [ 1, 0, 0 ],
-      [ 0, 0, 0 ],
-      [ 1, 1, 0 ],
-      [ 0, 1, 0 ],
+      { pos: [ 1, 0, 0 ], uv: [ 0, 0 ], },
+      { pos: [ 0, 0, 0 ], uv: [ 1, 0 ], },
+      { pos: [ 1, 1, 0 ], uv: [ 0, 1 ], },
+      { pos: [ 0, 1, 0 ], uv: [ 1, 1 ], },
    ],
  },
  { // ì•
+    uvRow: 0,
    dir: [  0,  0,  1, ],
    corners: [
-      [ 0, 0, 1 ],
-      [ 1, 0, 1 ],
-      [ 0, 1, 1 ],
-      [ 1, 1, 1 ],
+      { pos: [ 0, 0, 1 ], uv: [ 0, 0 ], },
+      { pos: [ 1, 0, 1 ], uv: [ 1, 0 ], },
+      { pos: [ 0, 1, 1 ], uv: [ 0, 1 ], },
+      { pos: [ 1, 1, 1 ], uv: [ 1, 1 ], },
    ],
  },
];
</pre>
<p>ë°©ê¸ˆ ì§€ì •í•œ ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì½”ë“œë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤. í…ìŠ¤ì²˜ ì•„í‹€ë¼ìŠ¤ íƒ€ì¼ í•˜ë‚˜ì˜ í¬ê¸°ì™€ í…ìŠ¤ì²˜ì˜ í¬ê¸°ë¥¼ ì•Œì•„ì•¼ í•˜ë‹ˆ ìƒì„± ì‹œì— ë„˜ê²¨ ë°›ë„ë¡ í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
-  constructor(cellSize) {
-    this.cellSize = cellSize;
+  constructor(options) {
+    this.cellSize = options.cellSize;
+    this.tileSize = options.tileSize;
+    this.tileTextureWidth = options.tileTextureWidth;
+    this.tileTextureHeight = options.tileTextureHeight;
+    const { cellSize } = this;
+    this.cellSliceSize = cellSize * cellSize;
+    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
  }

  ...

  generateGeometryDataForCell(cellX, cellY, cellZ) {
-    const { cellSize } = this;
+    const { cellSize, tileSize, tileTextureWidth, tileTextureHeight } = this;
    const positions = [];
    const normals = [];
+    const uvs = [];
    const indices = [];
    const startX = cellX * cellSize;
    const startY = cellY * cellSize;
    const startZ = cellZ * cellSize;

    for (let y = 0; y &lt; cellSize; ++y) {
      const voxelY = startY + y;
      for (let z = 0; z &lt; cellSize; ++z) {
        const voxelZ = startZ + z;
        for (let x = 0; x &lt; cellSize; ++x) {
          const voxelX = startX + x;
          const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
          if (voxel) {
            const uvVoxel = voxel - 1;  // 0 ìœ„ì¹˜ì˜ ë³µì…€ì€ í•˜ëŠ˜ì´ë¯€ë¡œ UVì˜ ê²½ìš°ëŠ” 0ì—ì„œ ì‹œì‘í•˜ë„ë¡ í•©ë‹ˆë‹¤.
            // í˜„ì¬ ìœ„ì¹˜ì— ë³µì…€ì´ ìˆì„ ë•Œ í•´ë‹¹ ìœ„ì¹˜ì— ë©´ì´ í•„ìš”í•œì§€ ê²€ì‚¬í•©ë‹ˆë‹¤.
-            for (const { dir, corners } of VoxelWorld.faces) {
+            for (const { dir, corners, uvRow } of VoxelWorld.faces) {
              const neighbor = this.getVoxel(
                  voxelX + dir[0],
                  voxelY + dir[1],
                  voxelZ + dir[2]);
              if (!neighbor) {
                // ì´ ë³µì…€ì€ ì´ ë°©í–¥ì— ì´ì›ƒí•˜ëŠ” ë³µì…€ì´ ì—†ìœ¼ë¯€ë¡œ
                // ì´ìª½ì— ë©´ì„ ë§Œë“­ë‹ˆë‹¤.
                const ndx = positions.length / 3;
-                for (const pos of corners) {
+                for (const {pos, uv} of corners) {
                  positions.push(pos[0] + x, pos[1] + y, pos[2] + z);
                  normals.push(...dir);
+                  uvs.push(
+                        (uvVoxel +   uv[0]) * tileSize / tileTextureWidth,
+                    1 - (uvRow + 1 - uv[1]) * tileSize / tileTextureHeight);
                }
                indices.push(
                  ndx, ndx + 1, ndx + 2,
                  ndx + 2, ndx + 1, ndx + 3,
                );
              }
            }
          }
        }
      }
    }

    return {
      positions,
      normals,
      uvs,
      indices,
    };
  }
}
</pre>
<p>ë‹¤ìŒìœ¼ë¡œ í…ìŠ¤ì²˜ë¥¼ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const loader = new THREE.TextureLoader();
const texture = loader.load('resources/images/minecraft/flourish-cc-by-nc-sa.png', render);
texture.magFilter = THREE.NearestFilter;
texture.minFilter = THREE.NearestFilter;
</pre>
<p>ê·¸ë¦¬ê³  <code class="notranslate" translate="no">VoxelWorld</code>ì— ì„¤ì •ê°’ì„ ë„˜ê²¨ì¤ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">+const tileSize = 16;
+const tileTextureWidth = 256;
+const tileTextureHeight = 64;
-const world = new VoxelWorld(cellSize);
+const world = new VoxelWorld({
+  cellSize,
+  tileSize,
+  tileTextureWidth,
+  tileTextureHeight,
+});
</pre>
<p>geometryë¥¼ ë§Œë“¤ ë•Œ UV ì¢Œí‘œë¥¼, ì¬ì§ˆì„ ë§Œë“¤ ë•Œ í…ìŠ¤ì²˜ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">-const { positions, normals, indices } = world.generateGeometryDataForCell(0, 0, 0);
+const { positions, normals, uvs, indices } = world.generateGeometryDataForCell(0, 0, 0);
const geometry = new THREE.BufferGeometry();
-const material = new THREE.MeshLambertMaterial({ color: 'green' });
+const material = new THREE.MeshLambertMaterial({
+  map: texture,
+  side: THREE.DoubleSide,
+  alphaTest: 0.1,
+  transparent: true,
+});

const positionNumComponents = 3;
const normalNumComponents = 3;
+const uvNumComponents = 2;
geometry.setAttribute(
    'position',
    new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
geometry.setAttribute(
    'normal',
    new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
+geometry.setAttribute(
+    'uv',
+    new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
geometry.setIndex(indices);
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);
</pre>
<p>ë§ˆì§€ë§‰ìœ¼ë¡œ ë³µì…€ì´ ì„œë¡œ ë‹¤ë¥¸ í…ìŠ¤ì²˜ë¥¼ ì“°ë„ë¡ ì„¤ì •í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">for (let y = 0; y &lt; cellSize; ++y) {
  for (let z = 0; z &lt; cellSize; ++z) {
    for (let x = 0; x &lt; cellSize; ++x) {
      const height = (Math.sin(x / cellSize * Math.PI * 2) + Math.sin(z / cellSize * Math.PI * 3)) * (cellSize / 6) + (cellSize / 2);
      if (y &lt; height) {
-        world.setVoxel(x, y, z, 1);
+        world.setVoxel(x, y, z, randInt(1, 17));
      }
    }
  }
}

+function randInt(min, max) {
+  return Math.floor(Math.random() * (max - min) + min);
+}
</pre>
<p>í•œ ë²ˆ ì‹¤í–‰í•´ë³´ì£ !</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/voxel-geometry-culled-faces-with-textures.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/voxel-geometry-culled-faces-with-textures.html" target="_blank">ìƒˆ íƒ­ì—ì„œ ë³´ê¸°</a>
</div>

<p></p>
<p>ì½”ë“œë¥¼ ì¢€ ë” ë°œì „ì‹œì¼œ í•˜ë‚˜ ì´ìƒì˜ cellì„ ì¶”ê°€í•  ìˆ˜ ìˆë„ë¡ í•´ë´…ì‹œë‹¤.</p>
<p>ë¨¼ì € ê° cellì— idë¥¼ ë¶€ì—¬í•´ ê°ì²´ í˜•íƒœë¡œ ì €ì¥í•˜ë„ë¡ í•©ë‹ˆë‹¤. ì´ idëŠ” ê° cellì˜ ìœ„ì¹˜ê°’ì„ ì‰¼í‘œë¡œ ë¶„í• í•œ ë¬¸ìì—´ë¡œ ì§€ì •í•  ê²ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ (35,0,0) ë³µì…€ì€ cell (1,0,0)ì— ìˆì„ í…Œë‹ˆ í•´ë‹¹ cellì˜ idëŠ” <code class="notranslate" translate="no">"1,0,0"</code>ì´ ë˜ê² ì£ .</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">class VoxelWorld {
  constructor(options) {
    this.cellSize = options.cellSize;
    this.tileSize = options.tileSize;
    this.tileTextureWidth = options.tileTextureWidth;
    this.tileTextureHeight = options.tileTextureHeight;
    const { cellSize } = this;
    this.cellSliceSize = cellSize * cellSize;
-    this.cell = new Uint8Array(cellSize * cellSize * cellSize);
+    this.cells = {};
  }
+  computeCellId(x, y, z) {
+    const { cellSize } = this;
+    const cellX = Math.floor(x / cellSize);
+    const cellY = Math.floor(y / cellSize);
+    const cellZ = Math.floor(z / cellSize);
+    return `${cellX},${cellY},${cellZ}`;
+  }
+  getCellForVoxel(x, y, z) {
-    const cellX = Math.floor(x / cellSize);
-    const cellY = Math.floor(y / cellSize);
-    const cellZ = Math.floor(z / cellSize);
-    if (cellX !== 0 || cellY !== 0 || cellZ !== 0) {
-      return null;
-    }
-    return this.cell;
+    return this.cells[this.computeCellId(x, y, z)];
  }

   ...
}
</pre>
<p>ê·¸ë¦¬ê³  <code class="notranslate" translate="no">setVoxel</code> ë©”ì„œë“œë¥¼ ìˆ˜ì •í•´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” cellì˜ ë³µì…€ì„ ì¶”ê°€í•  ë•Œ ìƒˆë¡œìš´ cellì„ ì¶”ê°€í•˜ë„ë¡ í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">  setVoxel(x, y, z, v) {
-    const cell = this.getCellForVoxel(x, y, z);
+    let cell = this.getCellForVoxel(x, y, z);
    if (!cell) {
-      return 0;
+      cell = this.addCellForVoxel(x, y, z);
    }
    const voxelOffset = this.computeVoxelOffset(x, y, z);
    cell[voxelOffset] = v;
  }
+  addCellForVoxel(x, y, z) {
+    const cellId = this.computeCellId(x, y, z);
+    let cell = this.cells[cellId];
+    if (!cell) {
+      const { cellSize } = this;
+      cell = new Uint8Array(cellSize * cellSize * cellSize);
+      this.cells[cellId] = cell;
+    }
+    return cell;
+  }
</pre>
<p>ì¤€ë¹„ë¥¼ ë§ˆì³¤ìœ¼ë‹ˆ ë³µì…€ì„ ë§ˆìŒëŒ€ë¡œ ìˆ˜ì •í•  ìˆ˜ ìˆë„ë¡ í•´ë´…ì‹œë‹¤.</p>
<p>ë¨¼ì € ë¼ë””ì˜¤ ë²„íŠ¼ì„ ì´ìš©í•´ íƒ€ì¼ì„ 8x2ì§œë¦¬ UIë¡œ ë§Œë“­ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-html" translate="no">&lt;body&gt;
  &lt;canvas id="c"&gt;&lt;/canvas&gt;
+  &lt;div id="ui"&gt;
+    &lt;div class="tiles"&gt;
+      &lt;input type="radio" name="voxel" id="voxel1" value="1"&gt;&lt;label for="voxel1" style="background-position:   -0% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel2" value="2"&gt;&lt;label for="voxel2" style="background-position: -100% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel3" value="3"&gt;&lt;label for="voxel3" style="background-position: -200% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel4" value="4"&gt;&lt;label for="voxel4" style="background-position: -300% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel5" value="5"&gt;&lt;label for="voxel5" style="background-position: -400% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel6" value="6"&gt;&lt;label for="voxel6" style="background-position: -500% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel7" value="7"&gt;&lt;label for="voxel7" style="background-position: -600% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel8" value="8"&gt;&lt;label for="voxel8" style="background-position: -700% -0%"&gt;&lt;/label&gt;
+    &lt;/div&gt;
+    &lt;div class="tiles"&gt;
+      &lt;input type="radio" name="voxel" id="voxel9"  value="9" &gt;&lt;label for="voxel9"  style="background-position:  -800% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel10" value="10"&gt;&lt;label for="voxel10" style="background-position:  -900% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel11" value="11"&gt;&lt;label for="voxel11" style="background-position: -1000% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel12" value="12"&gt;&lt;label for="voxel12" style="background-position: -1100% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel13" value="13"&gt;&lt;label for="voxel13" style="background-position: -1200% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel14" value="14"&gt;&lt;label for="voxel14" style="background-position: -1300% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel15" value="15"&gt;&lt;label for="voxel15" style="background-position: -1400% -0%"&gt;&lt;/label&gt;
+      &lt;input type="radio" name="voxel" id="voxel16" value="16"&gt;&lt;label for="voxel16" style="background-position: -1500% -0%"&gt;&lt;/label&gt;
+    &lt;/div&gt;
+  &lt;/div&gt;
&lt;/body&gt;
</pre>
<p>UIê°€ í˜„ì¬ ì„ íƒí•œ íƒ€ì¼ì„ ë³´ì—¬ì£¼ë„ë¡ CSSë„ ì¶”ê°€í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-css" translate="no">body {
    margin: 0;
}
#c {
    width: 100%;
    height: 100%;
    display: block;
}
+#ui {
+    position: absolute;
+    left: 10px;
+    top: 10px;
+    background: rgba(0, 0, 0, 0.8);
+    padding: 5px;
+}
+#ui input[type=radio] {
+  width: 0;
+  height: 0;
+  display: none;
+}
+#ui input[type=radio] + label {
+  background-image: url('resources/images/minecraft/flourish-cc-by-nc-sa.png');
+  background-size: 1600% 400%;
+  image-rendering: pixelated;
+  width: 64px;
+  height: 64px;
+  display: inline-block;
+}
+#ui input[type=radio]:checked + label {
+  outline: 3px solid red;
+}
+@media (max-width: 600px), (max-height: 600px) {
+  #ui input[type=radio] + label {
+    width: 32px;
+    height: 32px;
+  }
+}
</pre>
<p>ê¸°ëŠ¥ì€ ë‹¤ìŒì²˜ëŸ¼ êµ¬í˜„í•  ê²ë‹ˆë‹¤. ì„ íƒí•œ íƒ€ì¼ì´ ì—†ê±°ë‚˜ shift í‚¤ë¥¼ ëˆ„ë¥´ê³  ìˆëŠ” ê²½ìš°, ë³µì…€ì„ í´ë¦­í•˜ë©´ í•´ë‹¹ ë³µì…€ì´ ì§€ì›Œì§‘ë‹ˆë‹¤. ë°˜ëŒ€ë¡œ ì„ íƒí•œ íƒ€ì¼ì´ ìˆëŠ” ê²½ìš° ì„ íƒí•œ íƒ€ì¼ì´ ì¶”ê°€ë˜ì£ . ì„ íƒí•œ íƒ€ì¼ì„ ë‹¤ì‹œ í´ë¦­í•˜ë©´ ì„ íƒì„ í•´ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<p>ì•„ë˜ëŠ” ì‚¬ìš©ìê°€ ì„ íƒí•œ ë¼ë””ì˜¤ ë²„íŠ¼ì„ í•´ì œí•  ìˆ˜ ìˆê²Œë” í•´ì£¼ëŠ” ì½”ë“œì…ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">let currentVoxel = 0;
let currentId;

document.querySelectorAll('#ui .tiles input[type=radio][name=voxel]').forEach((elem) =&gt; {
  elem.addEventListener('click', allowUncheck);
});

function allowUncheck() {
  if (this.id === currentId) {
    this.checked = false;
    currentId = undefined;
    currentVoxel = 0;
  } else {
    currentId = this.id;
    currentVoxel = parseInt(this.value);
  }
}
</pre>
<p>ì•„ë˜ ì½”ë“œëŠ” ì‚¬ìš©ìê°€ í´ë¦­í•œ ì§€ì ì— ë³µì…€ì„ ì¶”ê°€í•˜ëŠ” ì—­í• ì…ë‹ˆë‹¤. <a href="picking.html">í”¼í‚¹ì— ê´€í•œ ê¸€</a>ì—ì„œ ì¼ë˜ ê²ƒê³¼ ë¹„ìŠ·í•œ ë°©ë²•ì„ ì‚¬ìš©í•˜ëŠ”ë°, Three.jsì˜ ë‚´ì¥ <code class="notranslate" translate="no">RayCaster</code>ê°€ ì•„ë‹Œ êµì°¨í•˜ëŠ” ì§€ì ì˜ ì¢Œí‘œì™€ êµì°¨í•œ ì ì˜ ë²•ì„ (normal)ì„ ë°˜í™˜í•˜ëŠ” <code class="notranslate" translate="no">VoxelWorld.intersectRay</code>ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">function getCanvasRelativePosition(event) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (event.clientX - rect.left) * canvas.width  / rect.width,
    y: (event.clientY - rect.top ) * canvas.height / rect.height,
  };
}

function placeVoxel(event) {
  const pos = getCanvasRelativePosition(event);
  const x = (pos.x / canvas.width ) *  2 - 1;
  const y = (pos.y / canvas.height) * -2 + 1;  // Yì¶•ì„ ë’¤ì§‘ì—ˆìŒ

  const start = new THREE.Vector3();
  const end = new THREE.Vector3();
  start.setFromMatrixPosition(camera.matrixWorld);
  end.set(x, y, 1).unproject(camera);

  const intersection = world.intersectRay(start, end);
  if (intersection) {
    const voxelId = event.shiftKey ? 0 : currentVoxel;
    /**
     * êµì°¨ì ì€ ë©´ ìœ„ì— ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ìˆ˜í•™ì  ì˜¤ì°¨ë¡œ ì¸í•´ êµì°¨ì ì´ ë©´ì˜ ì–‘ë©´
     * ì–´ë””ë¡œ ë–¨ì–´ì§ˆì§€ ëª¨ë¥¸ë‹¤ëŠ” ì´ì•¼ê¸°ì£ .
     * ê·¸ë˜ì„œ ë³µì…€ì„ ì œê±°í•˜ëŠ” ê²½ìš°(currentVoxel = 0)ëŠ” normalì˜ ê°’ì„ ë°˜ìœ¼ë¡œ
     * ì¤„ì´ê³ , ì¶”ê°€í•˜ëŠ” ê²½ìš°(currentVoxel &gt; 0)ì—ëŠ” ë°©í–¥ì„ ë°”ê¾¼ ë’¤ ë°˜ë§Œí¼ ì¤„ì…ë‹ˆë‹¤.
     **/
    const pos = intersection.position.map((v, ndx) =&gt; {
      return v + intersection.normal[ndx] * (voxelId &gt; 0 ? 0.5 : -0.5);
    });
    world.setVoxel(...pos, voxelId);
    updateVoxelGeometry(...pos);
    requestRenderIfNotRequested();
  }
}

const mouse = {
  x: 0,
  y: 0,
};

function recordStartPosition(event) {
  mouse.x = event.clientX;
  mouse.y = event.clientY;
  mouse.moveX = 0;
  mouse.moveY = 0;
}
function recordMovement(event) {
  mouse.moveX += Math.abs(mouse.x - event.clientX);
  mouse.moveY += Math.abs(mouse.y - event.clientY);
}
function placeVoxelIfNoMovement(event) {
  if (mouse.moveX &lt; 5 &amp;&amp; mouse.moveY &lt; 5) {
    placeVoxel(event);
  }
  window.removeEventListener('pointermove', recordMovement);
  window.removeEventListener('pointerup', placeVoxelIfNoMovement);
}
canvas.addEventListener('pointerdown', (event) =&gt; {
  event.preventDefault();
  recordStartPosition(event);
  window.addEventListener('pointermove', recordMovement);
  window.addEventListener('pointerup', placeVoxelIfNoMovement);
}, { passive: false });
canvas.addEventListener('touchstart', (event) =&gt; {
  // prevent scrolling
  event.preventDefault();
}, { passive: false });
</pre>
<p>ë§ˆìš°ìŠ¤ëŠ” ë‘ ê°€ì§€ ìš©ë„ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤. í•˜ë‚˜ëŠ” ì¹´ë©”ë¼ë¥¼ ì›€ì§ì´ëŠ” ìš©ë„ì´ê³ , ë‹¤ë¥¸ í•˜ë‚˜ëŠ” ë³µì…€ì„ ìˆ˜ì •í•˜ëŠ” ìš©ë„ì´ì£ . ë³µì…€ì˜ ì¶”ê°€/ì œê±° ì•¡ì…˜ì€ ë§ˆìš°ìŠ¤ë¥¼ ëˆ„ë¥´ê³  ì „í˜€ ì›€ì§ì´ì§€ ì•Šì•˜ì„ ë•Œë§Œ ë°œìƒí•©ë‹ˆë‹¤. ë§ˆìš°ìŠ¤ë¥¼ ëˆ„ë¥¸ ë’¤ ì›€ì§ì˜€ë‹¤ë©´ ì¹´ë©”ë¼ë¥¼ ëŒë¦¬ë ¤ëŠ” ì˜ë„ë¡œ ê°„ì£¼í•œ ê²ƒì´ì£ . <code class="notranslate" translate="no">moveX</code>ì™€ <code class="notranslate" translate="no">moveY</code>ëŠ” ì ˆëŒ€ê°’ìœ¼ë¡œ, ì™¼ìª½ìœ¼ë¡œ 10í”½ì…€, ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë‹¤ì‹œ 10í”½ì…€ì„ ì›€ì§ì˜€ë‹¤ë©´ <code class="notranslate" translate="no">moveX</code>ëŠ” 20í”½ì…€ì´ ë©ë‹ˆë‹¤. ì´ëŸ¬ë©´ í™”ë©´ì„ ëŒë ¸ë‹¤ê°€ ë‹¤ì‹œ ì œìë¦¬ì— ë†“ëŠ” ê²½ìš°ì—ë„ ë³µì…€ì˜ ì¶”ê°€/ì œê±° ì•¡ì…˜ì´ ë°œìƒí•˜ì§€ ì•Šì„ ê²ë‹ˆë‹¤. 5í”½ì…€ ì´ìƒ ì›€ì§ì´ì§€ ì•Šì•˜ì„ ê²½ìš° í´ë¦­ìœ¼ë¡œ ê°„ì£¼í–ˆëŠ”ë°, ë³„ë„ í…ŒìŠ¤íŠ¸ëŠ” ì§„í–‰í•˜ì§€ ì•Šì€ ì„ì˜ì˜ ê°’ì´ë‹ˆ ì°¸ê³  ë°”ëë‹ˆë‹¤.</p>
<p>ìœ„ ì½”ë“œì—ì„œëŠ” <code class="notranslate" translate="no">world.setVoxel</code>ë¡œ ë³µì…€ì„ ì¶”ê°€í•œ ë’¤ <code class="notranslate" translate="no">updateVoxelGeometry</code>ë¥¼ í˜¸ì¶œí•´ Three.jsê°€ ë³€ê²½ëœ geometryë¥¼ ë°˜ì˜í•˜ë„ë¡ í–ˆìŠµë‹ˆë‹¤.</p>
<p>ì´ì œ ì´ <code class="notranslate" translate="no">updateVoxelGeometry</code>ë¥¼ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤. ì‚¬ìš©ìê°€ cell ê°€ì¥ìë¦¬ì˜ ë³µì…€ì„ í´ë¦­í–ˆë‹¤ë©´ ìƒˆë¡œìš´ cell geometryë¥¼ ë§Œë“¤ì–´ì•¼ í•  ìˆ˜ë„ ìˆì£ . ë•Œë¬¸ì— ë°©ê¸ˆ ì¶”ê°€í•œ ë³µì…€ ë¿ë§Œ ì•„ë‹ˆë¼ í•´ë‹¹ ë³µì…€ì˜ cell ì£¼ë³€ cellë“¤ë„ ì „ë¶€ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const neighborOffsets = [
  [ 0,  0,  0], // ìì‹ 
  [-1,  0,  0], // ì™¼ìª½
  [ 1,  0,  0], // ì˜¤ë¥¸ìª½
  [ 0, -1,  0], // ì•„ë˜
  [ 0,  1,  0], // ìœ„
  [ 0,  0, -1], // ë’¤
  [ 0,  0,  1], // ì•
];
function updateVoxelGeometry(x, y, z) {
  const updatedCellIds = {};
  for (const offset of neighborOffsets) {
    const ox = x + offset[0];
    const oy = y + offset[1];
    const oz = z + offset[2];
    const cellId = world.computeCellId(ox, oy, oz);
    if (!updatedCellIds[cellId]) {
      updatedCellIds[cellId] = true;
      updateCellGeometry(ox, oy, oz);
    }
  }
}
</pre>
<p>ì²˜ìŒì—ëŠ” ì•„ë˜ì²˜ëŸ¼ ì¸ì ‘í•œ cellì„ ê²€ì‚¬í•˜ë ¤ í–ˆìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const voxelX = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
if (voxelX === 0) {
  // cellì„ ì™¼ìª½ì— ì¶”ê°€í•©ë‹ˆë‹¤.
} else if (voxelX === cellSize - 1) {
  // cellì„ ì˜¤ë¥¸ìª½ì— ì¶”ê°€í•©ë‹ˆë‹¤.
}
</pre>
<p>ì—¬ê¸°ì— ë‹¤ë¥¸ 4ë°©í–¥ì„ ê²€ì‚¬í•˜ëŠ” ì½”ë“œë¥¼ ì¶”ê°€í•˜ë ¤ í–ˆì§€ë§Œ, ì´ë•Œ ê·¸ëƒ¥ ì¢Œí‘œê°’ ë°°ì—´ì„ ë§Œë“¤ì–´ ì´ë¯¸ ë§Œë“  cellì˜ idë¡œ ì‚¬ìš©í•˜ëŠ” ê²Œ ë” ë‚«ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆìŠµë‹ˆë‹¤. ì¶”ê°€í•œ ë³µì…€ì´ cellì˜ ì•ˆì— ìˆëŠ” ê²Œ ì•„ë‹ˆë¼ë©´ í•´ë‹¹ ë³µì…€ì„ ì¶”ê°€í•˜ê¸¸ ê±°ë¶€í•˜ëŠ” ê²Œ ë” ë¹ ë¥¼ í…Œë‹ˆê¹Œìš”.</p>
<p><code class="notranslate" translate="no">updateCellGeometry</code>ëŠ” ê°„ë‹¨íˆ ì´ì „ì— cellì„ ë§Œë“¤ì—ˆë˜ ì½”ë“œë¥¼ ê°€ì ¸ì™€ ì—¬ëŸ¬ cellì„ ë§Œë“¤ ìˆ˜ ìˆë„ë¡ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤.</p>
<pre class="prettyprint showlinemods notranslate lang-js" translate="no">const cellIdToMesh = {};
function updateCellGeometry(x, y, z) {
  const cellX = Math.floor(x / cellSize);
  const cellY = Math.floor(y / cellSize);
  const cellZ = Math.floor(z / cellSize);
  const cellId = world.computeCellId(x, y, z);
  let mesh = cellIdToMesh[cellId];
  const geometry = mesh ? mesh.geometry : new THREE.BufferGeometry();

  const { positions, normals, uvs, indices } = world.generateGeometryDataForCell(cellX, cellY, cellZ);
  const positionNumComponents = 3;
  geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
  const normalNumComponents = 3;
  geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
  const uvNumComponents = 2;
  geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
  geometry.setIndex(indices);
  geometry.computeBoundingSphere();

  if (!mesh) {
    mesh = new THREE.Mesh(geometry, material);
    mesh.name = cellId;
    cellIdToMesh[cellId] = mesh;
    scene.add(mesh);
    mesh.position.set(cellX * cellSize, cellY * cellSize, cellZ * cellSize);
  }
}
</pre>
<p>ìœ„ í•¨ìˆ˜ëŠ” ì¸ë±ìŠ¤ ë§µê³¼ cellì˜ idë¡œ ë¯¸ë¦¬ ë§Œë“  meshê°€ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. ë§Œì•½ í•´ë‹¹ id(ì¢Œí‘œ)ì— í•´ë‹¹í•˜ëŠ” cellì´ ì—†ë‹¤ë©´ ìƒˆë¡œìš´ cell meshë¥¼ ë§Œë“¤ì–´ ì¥ë©´ì— ì¶”ê°€í•œ ë’¤ meshì˜ ì†ì„±ê³¼ ì¸ë±ìŠ¤ ë§µì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.</p>
<p></p><div translate="no" class="threejs_example_container notranslate">
  <div><iframe class="threejs_example notranslate" translate="no" style=" " src="/manual/examples/resources/editor.html?url=/manual/examples/voxel-geometry-culled-faces-ui.html"></iframe></div>
  <a class="threejs_center" href="/manual/examples/voxel-geometry-culled-faces-ui.html" target="_blank">ìƒˆ íƒ­ì—ì„œ ë³´ê¸°</a>
</div>

<p></p>
<p>ì°¸ê³ :</p>
<p>ì˜ˆì œì˜ ë°©ë²• ëŒ€ì‹  <code class="notranslate" translate="no">RayCaster</code>ë¥¼ ì¨ë„ ê´œì°®ì€ ê²°ê³¼ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¡œ í…ŒìŠ¤íŠ¸ë¥¼ í•´ë³´ì§„ ì•Šì•˜ì§€ë§Œ, ëŒ€ì‹  <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.42.3443&rep=rep1&type=pdf">ë³µì…€ì— ìµœì í™”ëœ raycaster</a>ë¥¼ ì°¾ì•„ ì´ê±¸ ì ìš©í–ˆìŠµë‹ˆë‹¤.</p>
<p><code class="notranslate" translate="no">intersectRay</code>ë¥¼ VoxelWorldì˜ ë©”ì„œë“œë¡œ ë§Œë“  ê±´ ì„±ëŠ¥ ë•Œë¬¸ì…ë‹ˆë‹¤. ë³µì…€ ë‹¨ìœ„ë¡œ ì²´í¬í•˜ëŠ” ê²Œ ë„ˆë¬´ ëŠë¦´ ê²½ìš° cell ë‹¨ìœ„ë¡œ ë¨¼ì € ì²´í¬í•´ ì„±ëŠ¥ì„ ì¢€ ë” ë†’í˜€ë³´ë ¤ëŠ” ê³„íšì´ì—ˆì£ .</p>
<p>í˜„ì¬ raycasterì˜ ê¸¸ì´ëŠ” z-farê¹Œì§€ì¸ë°, ì´ ê°’ì„ ë°”ê¿”ë„ ë©ë‹ˆë‹¤. ì´ê±´ ì œê°€ ì˜ˆì œë¥¼ ë§Œë“¤ ë•Œ 1-2í”½ì…€ ì •ë„ë¡œ ë³´ì´ëŠ” ë¨¼ ê³³ì—ëŠ” ë³µì…€ì„ ë§Œë“¤ ì¼ì´ ì—†ë‹¤ê³  ìƒê°í–ˆê¸° ë•Œë¬¸ì´ë‹ˆê¹Œìš”.</p>
<p><code class="notranslate" translate="no">geometry.computeBoundingSphere</code> ë©”ì„œë“œì˜ ì„±ëŠ¥ì€ ë‹¤ì†Œ ëŠë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê²½ìš° cellì„ ì „ë¶€ í¬í•¨í•˜ëŠ” ê²½ê³„ êµ¬ì²´ë¥¼ ì§ì ‘ ë§Œë“¤ ìˆ˜ ìˆì£ .</p>
<p>ì‹¤ì œ í”„ë¡œì íŠ¸ì˜€ë‹¤ë©´ ì•„ë§ˆ ë³µì…€ì´ ì•„ì˜ˆ ì—†ëŠ” cellë„ ì œê±°í•˜ëŠ” ê²Œ ì¢‹ì•˜ì„ ê²ë‹ˆë‹¤.</p>
<p>ì´ ë°©ë²•ì´ ê°€ì¥ ë³„ë¡œì¼ ê²½ìš°ëŠ” ë‹¹ì—°íˆ ì²´í¬íŒ í˜•íƒœë¡œ ë³µì…€ì„ ë°°ì¹˜í•˜ëŠ” ê²½ìš°(ì˜ˆë¥¼ ë“¤ì–´ ì²´í¬íŒì˜ í°ìƒ‰ ì¹¸ì—ë§Œ ë°°ì¹˜)ì¼ ê²ë‹ˆë‹¤. ë‹¹ì¥ì€ ì´ëŸ° ê²½ìš°ì— ì–´ë–»ê²Œ ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¬ì§€ ìƒê°ë‚˜ëŠ” ë°©ë²•ì´ ì—†ë„¤ìš”. ì•„ë§ˆ ì‚¬ìš©ìê°€ ì„±ëŠ¥ ë•Œë¬¸ì— ê±°ëŒ€í•œ ì²´í¬íŒ ë§Œë“¤ê¸°ë¥¼ í¬ê¸°í•˜ëŠ” ê²Œ ë” ë¹ ë¥¼ ê²ë‹ˆë‹¤.</p>
<p>ì˜ˆì œì—ì„œëŠ” ê°„ë‹¨í•œ í˜•íƒœë§Œ êµ¬í˜„í•˜ê¸° ìœ„í•´ í…ìŠ¤ì²˜ ì•„í‹€ë¼ìŠ¤ë¥¼ í…ìŠ¤ì²˜ í•œ ì¢…ë¥˜ë‹¹ í•œ ì—´ì”©ë§Œ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤. ê° ë³µì…€ì˜ ë©´ì— ë‹¤ë¥¸ í…ìŠ¤ì²˜ë¥¼ ì§€ì •í•  ìˆ˜ ìˆë„ë¡ ë³„ë„ì˜ í…Œì´ë¸”ì„ ë§Œë“¤ë©´ ì¢€ ë” ë²”ìš©ì„±ì„ ì¶”êµ¬í•  ìˆ˜ ìˆê² ì£ . ì˜ˆì œì—ì„œëŠ” ë¶ˆí•„ìš”í•œ ë‚­ë¹„ë¼ê³  ìƒê°í•´ í•´ë‹¹ ë¶€ë¶„ì„ ì œì™¸í–ˆìŠµë‹ˆë‹¤.</p>
<p>ì‹¤ì œ ë§ˆì¸í¬ë˜í”„íŠ¸ì—ëŠ” ë³µì…€ë„, ì •ìœ¡ë©´ì²´ë„ ì•„ë‹Œ íƒ€ì¼(tile)ì´ë¼ëŠ” ê²ƒì´ ìˆìŠµë‹ˆë‹¤. ìš¸íƒ€ë¦¬ë‚˜ ê½ƒ ê°™ì€ ê²ƒì´ ì—¬ê¸°ì— í•´ë‹¹í•˜ì£ . ì´ê±¸ êµ¬í˜„í•˜ë ¤ë©´ ê° ë³µì…€ì´ ì •ìœ¡ë©´ì²´ì¸ì§€, ë‹¤ë¥¸ geometryì¸ì§€ íŒë³„í•˜ëŠ” í…Œì´ë¸”ì„ ë§Œë“¤ì–´ ë³µì…€ì´ ì •ìœ¡ë©´ì²´ê°€ ì•„ë‹ ê²½ìš°, ë§ë‹¿ëŠ” ë©´ì„ ì œê±°í•˜ì§€ ì•Šë„ë¡ í•´ì•¼ í•©ë‹ˆë‹¤. ê½ƒ ë³µì…€ ì•„ë˜ì— ìˆëŠ” ë•… ë³µì…€ì´ ì§€ì›Œì ¸ì„œëŠ” ì•ˆ ë˜ë‹ˆê¹Œìš”.</p>
<p>ì´ ê¸€ì´ Three.jsë¡œ ë§ˆì¸í¬ë˜í”„íŠ¸ ê°™ì€ ê·¸ë˜í”½ì„ êµ¬í˜„í•  ë•Œ ì¢‹ì€ ì‹œì‘ì ì„ ë§ˆë ¨í•˜ê³ , geometryë¥¼ ìµœì í™”í•˜ëŠ” ë° ë„ì›€ì´ ë˜ì—ˆìœ¼ë©´ í•©ë‹ˆë‹¤.</p>
<p><canvas id="c"></canvas></p>
<script type="module" src="../resources/threejs-voxel-geometry.js"></script>

        </div>
      </div>
    </div>

  <script src="/manual/resources/prettify.js"></script>
  <script src="/manual/resources/lesson.js"></script>




</body></html>
