(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("tern/lib/infer"), require("tern/lib/tern"));
  if (typeof define == "function" && define.amd) // AMD
    return define([ "tern/lib/infer", "tern/lib/tern" ], mod);
  mod(tern, tern);
})(function(infer, tern) {
  "use strict";

  tern.registerPlugin("threejs", function(server, options) {
    return {
      defs : {
  "!name": "threejs",
  "THREE": {
    "AmbientLight": {
      "!url": "https://threejs.org/docs/#api/en/lights/AmbientLight",
      "prototype": {
        "!proto": "THREE.Light.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The light's color."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The light's intensity."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new ambient light.",
      "!type": "fn(color: number, intensity: number)"
    },
    "AnimationAction": {
      "!url": "https://threejs.org/docs/#api/en/animation/AnimationAction",
      "prototype": {
        "blendMode": {
          "!type": "+THREE.NormalAnimationBlendMode",
          "!doc": "Defines how the animation is blended/combined when two or more animations are simultaneously played."
        },
        "clampWhenFinished": {
          "!type": "bool",
          "!doc": "If set to true the animation will automatically be paused on its last frame. If set to false, AnimationAction will automatically be switched to false when the last loop of the action has finished, so that this action has no further impact. Note: This member has no impact if the action is interrupted (it has only an effect if its last loop has really finished)."
        },
        "enabled": {
          "!type": "bool",
          "!doc": "If set to false, the action is disabled so it has no impact. When the action is re-enabled, the animation continues from its current time (setting enabled to false doesn't reset the action)."
        },
        "loop": {
          "!type": "+THREE.LoopRepeat",
          "!doc": "The loop mode, set via AnimationAction."
        },
        "paused": {
          "!type": "bool",
          "!doc": "If set to true, the playback of the action is paused."
        },
        "repetitions": {
          "!type": "number",
          "!doc": "The number of repetitions of the performed clip over the course of this action. Can be set via AnimationAction. Setting this number has no effect if AnimationAction is set to THREE:LoopOnce."
        },
        "time": {
          "!type": "number",
          "!doc": "The local time of this action (in seconds, starting with 0). The value gets clamped or wrapped to [0,clip.duration] (according to the loop state)."
        },
        "timeScale": {
          "!type": "number",
          "!doc": "Scaling factor for the AnimationAction. A value of 0 causes the animation to pause. Negative values cause the animation to play backwards."
        },
        "weight": {
          "!type": "number",
          "!doc": "The degree of influence of this action (in the interval [0, 1]). Values between 0 (no impact) and 1 (full impact) can be used to blend between several actions."
        },
        "zeroSlopeAtEnd": {
          "!type": "bool",
          "!doc": "Enables smooth interpolation without separate clips for start, loop and end."
        },
        "zeroSlopeAtStart": {
          "!type": "bool",
          "!doc": "Enables smooth interpolation without separate clips for start, loop and end."
        },
        "crossFadeFrom": {
          "!type": "fn(fadeOutAction: +THREE.AnimationAction, duration: number, warp: bool) -> +THREE.AnimationAction",
          "!doc": "Causes this action to fade in and the given action to fade out, within the passed time interval."
        },
        "crossFadeTo": {
          "!type": "fn(fadeInAction: +THREE.AnimationAction, duration: number, warp: bool) -> +THREE.AnimationAction",
          "!doc": "Causes this action to fade out and the given action to fade in, within the passed time interval."
        },
        "fadeIn": {
          "!type": "fn(duration: number) -> +THREE.AnimationAction",
          "!doc": "Fades the animation in by increasing its weight gradually from 0 to 1, within the passed time interval."
        },
        "fadeOut": {
          "!type": "fn(duration: number) -> +THREE.AnimationAction",
          "!doc": "Fades the animation out by decreasing its weight gradually from 1 to 0, within the passed time interval."
        },
        "getClip": {
          "!type": "fn() -> +THREE.AnimationClip",
          "!doc": "Returns the animation clip of this animation action."
        },
        "getEffectiveTimeScale": {
          "!type": "fn() -> number",
          "!doc": "Returns the effective time scale of this action."
        },
        "getEffectiveWeight": {
          "!type": "fn() -> number",
          "!doc": "Returns the effective weight of this action."
        },
        "getMixer": {
          "!type": "fn() -> +THREE.AnimationMixer",
          "!doc": "Returns the animation mixer of this animation action."
        },
        "getRoot": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Returns the root object of this animation action."
        },
        "halt": {
          "!type": "fn(duration: number) -> +THREE.AnimationAction",
          "!doc": "Decelerates this animation's speed to 0 within the passed time interval."
        },
        "isRunning": {
          "!type": "fn() -> bool",
          "!doc": "Returns true if the animation is running."
        },
        "isScheduled": {
          "!type": "fn() -> bool",
          "!doc": "Returns true when AnimationAction has been called."
        },
        "play": {
          "!type": "fn() -> +THREE.AnimationAction",
          "!doc": "Starts the playback of the animation."
        },
        "reset": {
          "!type": "fn() -> +THREE.AnimationAction",
          "!doc": "Resets the playback of the animation."
        },
        "setDuration": {
          "!type": "fn(duration: number) -> +THREE.AnimationAction",
          "!doc": "Sets the duration for a single loop of this action."
        },
        "setEffectiveTimeScale": {
          "!type": "fn(timeScale: number) -> +THREE.AnimationAction",
          "!doc": "Sets the effective time scale of this action. An action has no effect and thus an effective time scale of zero when the action is paused."
        },
        "setEffectiveWeight": {
          "!type": "fn(weight: number) -> +THREE.AnimationAction",
          "!doc": "Sets the effective weight of this action. An action has no effect and thus an effective weight of zero when the action is disabled."
        },
        "setLoop": {
          "!type": "fn(mode: +THREE.LoopRepeat, repetitions: number) -> +THREE.AnimationAction",
          "!doc": "Configures the loop settings for this action."
        },
        "startAt": {
          "!type": "fn(time: number) -> +THREE.AnimationAction",
          "!doc": "Defines the time when the animation should start."
        },
        "stop": {
          "!type": "fn() -> +THREE.AnimationAction",
          "!doc": "Stops the playback of the animation."
        },
        "stopFading": {
          "!type": "fn() -> +THREE.AnimationAction",
          "!doc": "Stops any fading which is applied to this action."
        },
        "stopWarping": {
          "!type": "fn() -> +THREE.AnimationAction",
          "!doc": "Stops any scheduled warping which is applied to this action."
        },
        "syncWith": {
          "!type": "fn(action: +THREE.AnimationAction) -> +THREE.AnimationAction",
          "!doc": "Synchronizes this action with the passed other action."
        },
        "warp": {
          "!type": "fn(startTimeScale: number, endTimeScale: number, duration: number) -> +THREE.AnimationAction",
          "!doc": "Changes the playback speed, within the passed time interval, by modifying AnimationAction gradually from startTimeScale to endTimeScale."
        }
      },
      "!doc": "Constructs a new animation action.",
      "!type": "fn(mixer: +THREE.AnimationMixer, clip: +THREE.AnimationClip, localRoot: +THREE.Object3D, blendMode: +THREE.NormalAnimationBlendMode)"
    },
    "AnimationClip": {
      "!url": "https://threejs.org/docs/#api/en/animation/AnimationClip",
      "prototype": {
        "blendMode": {
          "!type": "+THREE.NormalAnimationBlendMode",
          "!doc": "Defines how the animation is blended/combined when two or more animations are simultaneously played."
        },
        "duration": {
          "!type": "number",
          "!doc": "The clip's duration in seconds."
        },
        "name": {
          "!type": "string",
          "!doc": "The clip's name."
        },
        "tracks": {
          "!doc": "An array of keyframe tracks."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the animation clip. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the animation clip."
        },
        "clone": {
          "!type": "fn() -> +THREE.AnimationClip",
          "!doc": "Returns a new animation clip with copied values from this instance."
        },
        "optimize": {
          "!type": "fn() -> +THREE.AnimationClip",
          "!doc": "Optimizes each track by removing equivalent sequential keys (which are common in morph target sequences)."
        },
        "resetDuration": {
          "!type": "fn() -> +THREE.AnimationClip",
          "!doc": "Sets the duration of this clip to the duration of its longest keyframe track."
        },
        "toJSON": {
          "!type": "fn(clip: +THREE.AnimationClip) -> object",
          "!doc": "Serializes the given animation clip into JSON."
        },
        "trim": {
          "!type": "fn() -> +THREE.AnimationClip",
          "!doc": "Trims all tracks to the clip's duration."
        },
        "validate": {
          "!type": "fn() -> bool",
          "!doc": "Performs minimal validation on each track in the clip. Returns true if all tracks are valid."
        },
        "CreateClipsFromMorphTargetSequences": {
          "!type": "fn(morphTargets, fps: number, noLoop: bool)",
          "!doc": "Returns an array of new AnimationClips created from the morph target sequences of a geometry, trying to sort morph target names into animation-group-based patterns like \"Walk_001, Walk_002, Run_001, Run_002...\". See MD2Loader as an example for how the method should be used."
        },
        "CreateFromMorphTargetSequence": {
          "!type": "fn(name: string, morphTargetSequence, fps: number, noLoop: bool) -> +THREE.AnimationClip",
          "!doc": "Returns a new animation clip from the passed morph targets array of a geometry, taking a name and the number of frames per second. Note: The fps parameter is required, but the animation speed can be overridden via AnimationAction."
        },
        "findByName": {
          "!type": "fn(objectOrClipArray, name: string) -> +THREE.AnimationClip",
          "!doc": "Searches for an animation clip by name, taking as its first parameter either an array of clips, or a mesh or geometry that contains an array named \"animations\" property."
        },
        "parse": {
          "!type": "fn(json: object) -> +THREE.AnimationClip",
          "!doc": "Factory method for creating an animation clip from the given JSON."
        },
        "parseAnimation": {
          "!type": "fn(animation: object, bones) -> +THREE.AnimationClip",
          "!doc": "Parses the animation.hierarchy format and returns a new animation clip."
        }
      },
      "!doc": "Constructs a new animation clip. Note: Instead of instantiating an AnimationClip directly with the constructor, you can use the static interface of this class for creating clips. In most cases though, animation clips will automatically be created by loaders when importing animated 3D assets.",
      "!type": "fn(name: string, duration: number, tracks, blendMode: +THREE.NormalAnimationBlendMode)"
    },
    "AnimationLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/AnimationLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback)",
          "!doc": "Starts loading from the given URL and pass the loaded animations as an array holding instances of AnimationClip to the onLoad() callback."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(json: object)",
          "!doc": "Parses the given JSON object and returns an array of animation clips."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new animation loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "AnimationMixer": {
      "!url": "https://threejs.org/docs/#api/en/animation/AnimationMixer",
      "prototype": {
        "time": {
          "!type": "number",
          "!doc": "The global mixer time (in seconds; starting with 0 on the mixer's creation)."
        },
        "timeScale": {
          "!type": "number",
          "!doc": "A scaling factor for the global time. Note: Setting this member to 0 and later back to 1 is a possibility to pause/unpause all actions that are controlled by this mixer."
        },
        "clipAction": {
          "!type": "fn(clip: +THREE.AnimationClip, optionalRoot: +THREE.Object3D, blendMode: +THREE.NormalAnimationBlendMode) -> +THREE.AnimationAction",
          "!doc": "Returns an instance of AnimationAction for the passed clip. If an action fitting the clip and root parameters doesn't yet exist, it will be created by this method. Calling this method several times with the same clip and root parameters always returns the same action."
        },
        "existingAction": {
          "!type": "fn(clip: +THREE.AnimationClip, optionalRoot: +THREE.Object3D) -> +THREE.AnimationAction",
          "!doc": "Returns an existing animation action for the passed clip."
        },
        "getRoot": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Returns this mixer's root object."
        },
        "setTime": {
          "!type": "fn(time: number) -> +THREE.AnimationMixer",
          "!doc": "Sets the global mixer to a specific time and updates the animation accordingly. This is useful when you need to jump to an exact time in an animation. The input parameter will be scaled by AnimationMixer"
        },
        "stopAllAction": {
          "!type": "fn() -> +THREE.AnimationMixer",
          "!doc": "Deactivates all previously scheduled actions on this mixer."
        },
        "uncacheAction": {
          "!type": "fn(clip: +THREE.AnimationClip, optionalRoot: +THREE.Object3D)",
          "!doc": "Deallocates all memory resources for an action. The action is identified by the given clip and an optional root object. Before using this method make sure to call AnimationAction to deactivate the action."
        },
        "uncacheClip": {
          "!type": "fn(clip: +THREE.AnimationClip)",
          "!doc": "Deallocates all memory resources for a clip. Before using this method make sure to call AnimationAction for all related actions."
        },
        "uncacheRoot": {
          "!type": "fn(root: +THREE.Object3D)",
          "!doc": "Deallocates all memory resources for a root object. Before using this method make sure to call AnimationAction for all related actions or alternatively AnimationMixer when the mixer operates on a single root."
        },
        "update": {
          "!type": "fn(deltaTime: number) -> +THREE.AnimationMixer",
          "!doc": "Advances the global mixer time and updates the animation. This is usually done in the render loop by passing the delta time from Clock or Timer."
        }
      },
      "!doc": "Constructs a new animation mixer.",
      "!type": "fn(root: +THREE.Object3D)"
    },
    "AnimationObjectGroup": {
      "!url": "https://threejs.org/docs/#api/en/animation/AnimationObjectGroup",
      "prototype": {
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "add": {
          "!type": "fn(arguments: +THREE.Object3D)",
          "!doc": "Adds an arbitrary number of objects to this animation group."
        },
        "remove": {
          "!type": "fn(arguments: +THREE.Object3D)",
          "!doc": "Removes an arbitrary number of objects to this animation group"
        },
        "uncache": {
          "!type": "fn(arguments: +THREE.Object3D)",
          "!doc": "Deallocates all memory resources for the passed 3D objects of this animation group."
        }
      },
      "!doc": "Constructs a new animation group.",
      "!type": "fn(arguments: +THREE.Object3D)"
    },
    "AnimationUtils": {
      "!url": "https://threejs.org/docs/#api/en/animation/AnimationUtils",
      "prototype": {
        "convertArray": {
          "!type": "fn(array: +TypedArray, type) -> +TypedArray",
          "!doc": "Converts an array to a specific type"
        },
        "flattenJSON": {
          "!type": "fn(jsonKeys, times, values, valuePropertyName: string)",
          "!doc": "Used for parsing AOS keyframe formats."
        },
        "getKeyframeOrder": {
          "!type": "fn(times)",
          "!doc": "Returns an array by which times and values can be sorted."
        },
        "isTypedArray": {
          "!type": "fn(object: ?) -> bool",
          "!doc": "Returns true if the given object is a typed array."
        },
        "makeClipAdditive": {
          "!type": "fn(targetClip: +THREE.AnimationClip, referenceFrame: number, referenceClip: +THREE.AnimationClip, fps: number) -> +THREE.AnimationClip",
          "!doc": "Converts the keyframes of the given animation clip to an additive format."
        },
        "sortedArray": {
          "!type": "fn(values, stride: number, order)",
          "!doc": "Sorts the given array by the previously computed order via getKeyframeOrder()."
        },
        "subclip": {
          "!type": "fn(sourceClip: +THREE.AnimationClip, name: string, startFrame: number, endFrame: number, fps: number) -> +THREE.AnimationClip",
          "!doc": "Creates a new clip, containing only the segment of the original clip between the given frames."
        }
      },
      "!type": "fn()"
    },
    "ArcCurve": {
      "!url": "https://threejs.org/docs/#api/en/extras/ArcCurve",
      "prototype": {
        "!proto": "THREE.EllipseCurve.prototype",
        "aClockwise": {
          "!type": "bool",
          "!doc": "Whether the ellipse is drawn clockwise or not."
        },
        "aEndAngle": {
          "!type": "number",
          "!doc": "The end angle of the curve in radians starting from the positive X axis."
        },
        "aRotation": {
          "!type": "number",
          "!doc": "The rotation angle of the ellipse in radians, counterclockwise from the positive X axis."
        },
        "aStartAngle": {
          "!type": "number",
          "!doc": "The start angle of the curve in radians starting from the positive X axis."
        },
        "aX": {
          "!type": "number",
          "!doc": "The X center of the ellipse."
        },
        "aY": {
          "!type": "number",
          "!doc": "The Y center of the ellipse."
        },
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "xRadius": {
          "!type": "number",
          "!doc": "The radius of the ellipse in the x direction. Setting the this value equal to the EllipseCurve will result in a circle."
        },
        "yRadius": {
          "!type": "number",
          "!doc": "The radius of the ellipse in the y direction. Setting the this value equal to the EllipseCurve will result in a circle."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a point on the curve."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new arc curve.",
      "!type": "fn(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool)"
    },
    "ArrayCamera": {
      "!url": "https://threejs.org/docs/#api/en/cameras/ArrayCamera",
      "prototype": {
        "!proto": "THREE.PerspectiveCamera.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "aspect": {
          "!type": "number",
          "!doc": "The aspect ratio, usually the canvas width / canvas height."
        },
        "cameras": {
          "!doc": "An array of perspective sub cameras."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "coordinateSystem": {
          "!type": "+THREE.WebGLCoordinateSystem",
          "!doc": "The coordinate system in which the camera is used."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "far": {
          "!type": "number",
          "!doc": "The camera's far plane. Must be greater than the current value of PerspectiveCamera."
        },
        "filmGauge": {
          "!type": "number",
          "!doc": "Film size used for the larger axis. Default is 35 (millimeters). This parameter does not influence the projection matrix unless PerspectiveCamera is set to a nonzero value."
        },
        "filmOffset": {
          "!type": "number",
          "!doc": "Horizontal off-center offset in the same unit as PerspectiveCamera."
        },
        "focus": {
          "!type": "number",
          "!doc": "Object distance used for stereoscopy and depth-of-field effects. This parameter does not influence the projection matrix unless a StereoCamera is being used."
        },
        "fov": {
          "!type": "number",
          "!doc": "The vertical field of view, from bottom to top of view, in degrees."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldInverse": {
          "!type": "+THREE.Matrix4",
          "!doc": "The inverse of the camera's world matrix."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "near": {
          "!type": "number",
          "!doc": "The camera's near plane. The valid range is greater than 0 and less than the current value of PerspectiveCamera. Note that, unlike for the OrthographicCamera, 0 is not a valid value for a perspective camera's near plane."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "projectionMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "The camera's projection matrix."
        },
        "projectionMatrixInverse": {
          "!type": "+THREE.Matrix4",
          "!doc": "The inverse of the camera's projection matrix."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "reversedDepth": {
          "!type": "bool",
          "!doc": "The flag that indicates whether the camera uses a reversed depth buffer."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "view": {
          "!type": "object",
          "!doc": "Represents the frustum window specification. This property should not be edited directly but via PerspectiveCamera and PerspectiveCamera."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "zoom": {
          "!type": "number",
          "!doc": "The zoom factor of the camera."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clearViewOffset": {
          "!type": "fn()",
          "!doc": "Removes the view offset from the projection matrix."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getEffectiveFOV": {
          "!type": "fn() -> number",
          "!doc": "Returns the current vertical field of view angle in degrees considering PerspectiveCamera."
        },
        "getFilmHeight": {
          "!type": "fn() -> number",
          "!doc": "Returns the height of the image on the film. If PerspectiveCamera is greater than or equal to one (landscape format), the result equals PerspectiveCamera."
        },
        "getFilmWidth": {
          "!type": "fn() -> number",
          "!doc": "Returns the width of the image on the film. If PerspectiveCamera is greater than or equal to one (landscape format), the result equals PerspectiveCamera."
        },
        "getFocalLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the focal length from the current PerspectiveCamera and PerspectiveCamera."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getViewBounds": {
          "!type": "fn(distance: number, minTarget: +THREE.Vector2, maxTarget: +THREE.Vector2)",
          "!doc": "Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction. Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle."
        },
        "getViewSize": {
          "!type": "fn(distance: number, target: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space. This method is overwritten since cameras have a different forward vector compared to other 3D objects. A camera looks down its local, negative z-axis by default."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setFocalLength": {
          "!type": "fn(focalLength: number)",
          "!doc": "Sets the FOV by focal length in respect to the current PerspectiveCamera. The default film gauge is 35, so that the focal length can be specified for a 35mm (full frame) camera."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "setViewOffset": {
          "!type": "fn(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number)",
          "!doc": "Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups. For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this `` +---+---+---+ | A | B | C | +---+---+---+ | D | E | F | +---+---+---+ ` then for each monitor you would call it like this: `js const w = 1920; const h = 1080; const fullWidth = w * 3; const fullHeight = h * 2; // --A-- camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h ); // --B-- camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h ); // --C-- camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h ); // --D-- camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h ); // --E-- camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h ); // --F-- camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); `` Note there is no reason monitors have to be the same size or in a grid."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateProjectionMatrix": {
          "!type": "fn()",
          "!doc": "Updates the camera's projection matrix. Must be called after any change of camera properties."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new array camera.",
      "!type": "fn(array)"
    },
    "ArrowHelper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/ArrowHelper",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "cone": {
          "!type": "+THREE.Mesh",
          "!doc": "The cone part of the arrow helper."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "line": {
          "!type": "+THREE.Line",
          "!doc": "The line part of the arrow helper."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setColor": {
          "!type": "fn(color: number)",
          "!doc": "Sets the color of the helper."
        },
        "setDirection": {
          "!type": "fn(dir: +THREE.Vector3)",
          "!doc": "Sets the direction of the helper."
        },
        "setLength": {
          "!type": "fn(length: number, headLength: number, headWidth: number)",
          "!doc": "Sets the length of the helper."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new arrow helper.",
      "!type": "fn(dir: +THREE.Vector3, origin: +THREE.Vector3, length: number, color: number, headLength: number, headWidth: number)"
    },
    "Audio": {
      "!url": "https://threejs.org/docs/#api/en/audio/Audio",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "autoplay": {
          "!type": "bool",
          "!doc": "Whether to start playback automatically or not."
        },
        "buffer": {
          "!type": "+THREE.AudioBuffer",
          "!doc": "A reference to an audio buffer. Defined via Audio."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "context": {
          "!type": "+THREE.AudioContext",
          "!doc": "The audio context."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "detune": {
          "!type": "number",
          "!doc": "Modify pitch, measured in cents. +/- 100 is a semitone. +/- 1200 is an octave. Defined via Audio."
        },
        "duration": {
          "!type": "undefined",
          "!doc": "Overrides the default duration of the audio."
        },
        "filters": {
          "!doc": "Can be used to apply a variety of low-order filters to create more complex sound effects e.g. via BiquadFilterNode. The property is automatically set by Audio."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "gain": {
          "!type": "+THREE.GainNode",
          "!doc": "The gain node used for volume control."
        },
        "hasPlaybackControl": {
          "!type": "bool",
          "!doc": "Indicates whether the audio playback can be controlled with method like Audio or Audio. This flag will be automatically set when audio sources are defined."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "listener": {
          "!type": "+THREE.AudioListener",
          "!doc": "The global audio listener."
        },
        "loop": {
          "!type": "bool",
          "!doc": "Whether the audio should loop or not. Defined via Audio."
        },
        "loopEnd": {
          "!type": "number",
          "!doc": "Defines where in the audio buffer the replay should stop, in seconds."
        },
        "loopStart": {
          "!type": "number",
          "!doc": "Defines where in the audio buffer the replay should start, in seconds."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "offset": {
          "!type": "number",
          "!doc": "An offset to the time within the audio buffer the playback should begin, in seconds."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "playbackRate": {
          "!type": "number",
          "!doc": "The playback speed. Defined via Audio."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "source": {
          "!type": "+THREE.AudioNode",
          "!doc": "Holds a reference to the current audio source. The property is automatically by one of the set*() methods."
        },
        "sourceType": {
          "!type": "+THREE.empty",
          "!doc": "Defines the source type. The property is automatically set by one of the set*() methods."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "connect": {
          "!type": "fn() -> +THREE.Audio",
          "!doc": "Connects to the audio source. This is used internally on initialisation and when setting / removing filters."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "disconnect": {
          "!type": "fn() -> +THREE.Audio",
          "!doc": "Disconnects to the audio source. This is used internally on initialisation and when setting / removing filters."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getDetune": {
          "!type": "fn() -> number",
          "!doc": "Returns the detuning of oscillation in cents."
        },
        "getFilter": {
          "!type": "fn() -> +THREE.AudioNode",
          "!doc": "Returns the first filter in the list of filters."
        },
        "getFilters": {
          "!type": "fn()",
          "!doc": "Returns the current set filters."
        },
        "getLoop": {
          "!type": "fn() -> bool",
          "!doc": "Returns the loop flag. Can only be used with compatible audio sources that allow playback control."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getOutput": {
          "!type": "fn() -> +THREE.GainNode",
          "!doc": "Returns the output audio node."
        },
        "getPlaybackRate": {
          "!type": "fn() -> number",
          "!doc": "Returns the current playback rate."
        },
        "getVolume": {
          "!type": "fn() -> number",
          "!doc": "Returns the volume."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "onEnded": {
          "!type": "fn()",
          "!doc": "Automatically called when playback finished."
        },
        "pause": {
          "!type": "fn() -> +THREE.Audio",
          "!doc": "Pauses the playback of the audio. Can only be used with compatible audio sources that allow playback control."
        },
        "play": {
          "!type": "fn(delay: number) -> +THREE.Audio",
          "!doc": "Starts the playback of the audio. Can only be used with compatible audio sources that allow playback control."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setBuffer": {
          "!type": "fn(audioBuffer: +THREE.AudioBuffer) -> +THREE.Audio",
          "!doc": "Sets the given audio buffer as the source of this instance. Audio is set to buffer and Audio to true."
        },
        "setDetune": {
          "!type": "fn(value: number) -> +THREE.Audio",
          "!doc": "Defines the detuning of oscillation in cents."
        },
        "setFilter": {
          "!type": "fn(filter: +THREE.AudioNode) -> +THREE.Audio",
          "!doc": "Applies a single filter node to the audio."
        },
        "setFilters": {
          "!type": "fn(value) -> +THREE.Audio",
          "!doc": "Sets an array of filters and connects them with the audio source."
        },
        "setLoop": {
          "!type": "fn(value: bool) -> +THREE.Audio",
          "!doc": "Sets the loop flag. Can only be used with compatible audio sources that allow playback control."
        },
        "setLoopEnd": {
          "!type": "fn(value: number) -> +THREE.Audio",
          "!doc": "Sets the loop end value which defines where in the audio buffer the replay should stop, in seconds."
        },
        "setLoopStart": {
          "!type": "fn(value: number) -> +THREE.Audio",
          "!doc": "Sets the loop start value which defines where in the audio buffer the replay should start, in seconds."
        },
        "setMediaElementSource": {
          "!type": "fn(mediaElement: +THREE.HTMLMediaElement) -> +THREE.Audio",
          "!doc": "Sets the given media element as the source of this instance. Audio is set to mediaNode and Audio to false."
        },
        "setMediaStreamSource": {
          "!type": "fn(mediaStream: +THREE.MediaStream) -> +THREE.Audio",
          "!doc": "Sets the given media stream as the source of this instance. Audio is set to mediaStreamNode and Audio to false."
        },
        "setNodeSource": {
          "!type": "fn(audioNode: +THREE.AudioNode) -> +THREE.Audio",
          "!doc": "Sets the given audio node as the source of this instance. Audio is set to audioNode and Audio to false."
        },
        "setPlaybackRate": {
          "!type": "fn(value: number) -> +THREE.Audio",
          "!doc": "Sets the playback rate. Can only be used with compatible audio sources that allow playback control."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "setVolume": {
          "!type": "fn(value: number) -> +THREE.Audio",
          "!doc": "Sets the volume."
        },
        "stop": {
          "!type": "fn(delay: number) -> +THREE.Audio",
          "!doc": "Stops the playback of the audio. Can only be used with compatible audio sources that allow playback control."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new audio.",
      "!type": "fn(listener: +THREE.AudioListener)"
    },
    "AudioAnalyser": {
      "!url": "https://threejs.org/docs/#api/en/audio/AudioAnalyser",
      "prototype": {
        "analyser": {
          "!type": "+THREE.AnalyserNode",
          "!doc": "The global audio listener."
        },
        "data": {
          "!type": "+Uint8Array",
          "!doc": "Holds the analyzed data."
        },
        "getAverageFrequency": {
          "!type": "fn() -> number",
          "!doc": "Returns the average of the frequencies returned by AudioAnalyser."
        },
        "getFrequencyData": {
          "!type": "fn() -> +Uint8Array",
          "!doc": "Returns an array with frequency data of the audio. Each item in the array represents the decibel value for a specific frequency. The frequencies are spread linearly from 0 to 1/2 of the sample rate. For example, for 48000 sample rate, the last item of the array will represent the decibel value for 24000 Hz."
        }
      },
      "!doc": "Constructs a new audio analyzer.",
      "!type": "fn(audio: +THREE.Audio, fftSize: number)"
    },
    "AudioContext": {
      "!url": "https://threejs.org/docs/#api/en/audio/AudioContext",
      "prototype": {
        "getContext": {
          "!type": "fn() -> +THREE.AudioContext",
          "!doc": "Returns the global native audio context."
        },
        "setContext": {
          "!type": "fn(value: +THREE.AudioContext)",
          "!doc": "Allows to set the global native audio context from outside."
        }
      },
      "!type": "fn()"
    },
    "AudioListener": {
      "!url": "https://threejs.org/docs/#api/en/audio/AudioListener",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "context": {
          "!type": "+THREE.AudioContext",
          "!doc": "The native audio context."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "filter": {
          "!type": "+THREE.AudioNode",
          "!doc": "An optional filter. Defined via AudioListener."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "gain": {
          "!type": "+THREE.GainNode",
          "!doc": "The gain node used for volume control."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "timeDelta": {
          "!type": "number",
          "!doc": "Time delta values required for linearRampToValueAtTime() usage."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getFilter": {
          "!type": "fn() -> +THREE.AudioNode",
          "!doc": "Returns the current set filter."
        },
        "getInput": {
          "!type": "fn() -> +THREE.GainNode",
          "!doc": "Returns the listener's input node. This method is used by other audio nodes to connect to this listener."
        },
        "getMasterVolume": {
          "!type": "fn() -> number",
          "!doc": "Returns the applications master volume."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFilter": {
          "!type": "fn() -> +THREE.AudioListener",
          "!doc": "Removes the current filter from this listener."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setFilter": {
          "!type": "fn(value: +THREE.AudioNode) -> +THREE.AudioListener",
          "!doc": "Sets the given filter to this listener."
        },
        "setMasterVolume": {
          "!type": "fn(value: number) -> +THREE.AudioListener",
          "!doc": "Sets the applications master volume. This volume setting affects all audio nodes in the scene."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new audio listener.",
      "!type": "fn()"
    },
    "AudioLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/AudioLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback)",
          "!doc": "Starts loading from the given URL and passes the loaded audio buffer to the onLoad() callback."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(data: ?)",
          "!doc": "This method needs to be implemented by all concrete loaders. It holds the logic for parsing the asset into three.js entities."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new audio loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "AxesHelper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/AxesHelper",
      "prototype": {
        "!proto": "THREE.LineSegments.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The line geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The line material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeLineDistances": {
          "!type": "fn() -> +THREE.Line",
          "!doc": "Computes an array of distance values which are necessary for rendering dashed lines. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setColors": {
          "!type": "fn(xAxisColor: number, yAxisColor: number, zAxisColor: number) -> +THREE.AxesHelper",
          "!doc": "Defines the colors of the axes helper."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Line and Line to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new axes helper.",
      "!type": "fn(size: number)"
    },
    "BatchedMesh": {
      "!url": "https://threejs.org/docs/#api/en/objects/BatchedMesh",
      "prototype": {
        "!proto": "THREE.Mesh.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "The bounding box of the batched mesh. Can be computed via BatchedMesh."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "The bounding sphere of the batched mesh. Can be computed via BatchedMesh."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "count": {
          "!type": "number",
          "!doc": "The number of instances of this mesh. Can only be used with WebGPURenderer."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "customSort": {
          "!type": "fn()",
          "!doc": "Takes a sort a function that is run before render. The function takes a list of instances to sort and a camera. The objects in the list include a \"z\" field to perform a depth-ordered sort with."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The mesh geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "instanceCount": {
          "!type": "number",
          "!doc": "The instance count."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The mesh material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "maxInstanceCount": {
          "!type": "number",
          "!doc": "The maximum number of individual instances that can be stored in the batch."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "perObjectFrustumCulled": {
          "!type": "bool",
          "!doc": "When set ot true, the individual objects of a batch are frustum culled."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "sortObjects": {
          "!type": "bool",
          "!doc": "When set to true, the individual objects of a batch are sorted to improve overdraw-related artifacts. If the material is marked as \"transparent\" objects are rendered back to front and if not then they are rendered front to back."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "unusedIndexCount": {
          "!type": "number",
          "!doc": "The number of unused indices."
        },
        "unusedVertexCount": {
          "!type": "number",
          "!doc": "The number of unused vertices."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGeometry": {
          "!type": "fn(geometry: +THREE.BufferGeometry, reservedVertexCount: number, reservedIndexCount: number) -> number",
          "!doc": "Adds the given geometry to the batch and returns the associated geometry id referring to it to be used in other functions."
        },
        "addInstance": {
          "!type": "fn(geometryId: number) -> number",
          "!doc": "Adds a new instance to the batch using the geometry of the given ID and returns a new id referring to the new instance to be used by other functions."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box, updating BatchedMesh. Bounding boxes aren't computed by default. They need to be explicitly computed, otherwise they are null."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere, updating BatchedMesh. Bounding spheres aren't computed by default. They need to be explicitly computed, otherwise they are null."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "deleteGeometry": {
          "!type": "fn(geometryId: number) -> +THREE.BatchedMesh",
          "!doc": "Deletes the geometry defined by the given ID from this batch. Any instances referencing this geometry will also be removed as a side effect."
        },
        "deleteInstance": {
          "!type": "fn(instanceId: number) -> +THREE.BatchedMesh",
          "!doc": "Deletes an existing instance from the batch using the given ID."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getBoundingBoxAt": {
          "!type": "fn(geometryId: number, target: +THREE.Box3) -> +THREE.Box3",
          "!doc": "Returns the bounding box for the given geometry."
        },
        "getBoundingSphereAt": {
          "!type": "fn(geometryId: number, target: +THREE.Sphere) -> +THREE.Sphere",
          "!doc": "Returns the bounding sphere for the given geometry."
        },
        "getColorAt": {
          "!type": "fn(instanceId: number, color: +THREE.Color) -> +THREE.Color",
          "!doc": "Returns the color of the defined instance."
        },
        "getGeometryIdAt": {
          "!type": "fn(instanceId: number) -> number",
          "!doc": "Returns the geometry ID of the defined instance."
        },
        "getGeometryRangeAt": {
          "!type": "fn(geometryId: number, target: object) -> object",
          "!doc": "Get the range representing the subset of triangles related to the attached geometry, indicating the starting offset and count, or null if invalid."
        },
        "getMatrixAt": {
          "!type": "fn(instanceId: number, matrix: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Returns the local transformation matrix of the defined instance."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getVertexPosition": {
          "!type": "fn(index: number, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the local-space position of the vertex at the given index, taking into account the current animation state of both morph targets and skinning."
        },
        "getVisibleAt": {
          "!type": "fn(instanceId: number) -> bool",
          "!doc": "Returns the visibility state of the defined instance."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "optimize": {
          "!type": "fn() -> +THREE.BatchedMesh",
          "!doc": "Repacks the sub geometries in BatchedMesh to remove any unused space remaining from previously deleted geometry, freeing up space to add new geometry."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setColorAt": {
          "!type": "fn(instanceId: number, color: +THREE.Color) -> +THREE.BatchedMesh",
          "!doc": "Sets the given color to the defined instance."
        },
        "setCustomSort": {
          "!type": "fn(func: fn()) -> +THREE.BatchedMesh",
          "!doc": "Takes a sort a function that is run before render. The function takes a list of instances to sort and a camera. The objects in the list include a \"z\" field to perform a depth-ordered sort with."
        },
        "setGeometryAt": {
          "!type": "fn(geometryId: number, geometry: +THREE.BufferGeometry) -> number",
          "!doc": "Replaces the geometry at the given ID with the provided geometry. Throws an error if there is not enough space reserved for geometry. Calling this will change all instances that are rendering that geometry."
        },
        "setGeometryIdAt": {
          "!type": "fn(instanceId: number, geometryId: number) -> +THREE.BatchedMesh",
          "!doc": "Sets the geometry ID of the instance at the given index."
        },
        "setGeometrySize": {
          "!type": "fn(maxVertexCount: number, maxIndexCount: number)",
          "!doc": "Resizes the available space in the batch's vertex and index buffer attributes to the provided sizes. If the provided arguments shrink the geometry buffers but there is not enough unused space at the end of the geometry attributes then an error is thrown."
        },
        "setInstanceCount": {
          "!type": "fn(maxInstanceCount: number)",
          "!doc": "Resizes the necessary buffers to support the provided number of instances. If the provided arguments shrink the number of instances but there are not enough unused Ids at the end of the list then an error is thrown."
        },
        "setMatrixAt": {
          "!type": "fn(instanceId: number, matrix: +THREE.Matrix4) -> +THREE.BatchedMesh",
          "!doc": "Sets the given local transformation matrix to the defined instance. Negatively scaled matrices are not supported."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "setVisibleAt": {
          "!type": "fn(instanceId: number, visible: bool) -> +THREE.BatchedMesh",
          "!doc": "Sets the visibility of the instance."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Mesh and Mesh to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "validateGeometryId": {
          "!type": "fn(geometryId: number)",
          "!doc": "Validates the geometry defined by the given ID."
        },
        "validateInstanceId": {
          "!type": "fn(instanceId: number)",
          "!doc": "Validates the instance defined by the given ID."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new batched mesh.",
      "!type": "fn(maxInstanceCount: number, maxVertexCount: number, maxIndexCount: number, material: +THREE.Material)"
    },
    "BezierInterpolant": {
      "!url": "https://threejs.org/docs/#api/en/math/BezierInterpolant",
      "prototype": {
        "!proto": "THREE.Interpolant.prototype",
        "DefaultSettings_": {
          "!type": "object",
          "!doc": "The default settings object."
        },
        "parameterPositions": {
          "!type": "+TypedArray",
          "!doc": "The parameter positions."
        },
        "resultBuffer": {
          "!type": "+TypedArray",
          "!doc": "The result buffer."
        },
        "sampleValues": {
          "!type": "+TypedArray",
          "!doc": "The sample values."
        },
        "settings": {
          "!type": "object",
          "!doc": "The interpolation settings."
        },
        "valueSize": {
          "!type": "+TypedArray",
          "!doc": "The value size."
        },
        "copySampleValue_": {
          "!type": "fn(index: number) -> +TypedArray",
          "!doc": "Copies a sample value to the result buffer."
        },
        "evaluate": {
          "!type": "fn(t: number) -> +TypedArray",
          "!doc": "Evaluate the interpolant at position t."
        },
        "getSettings_": {
          "!type": "fn() -> object",
          "!doc": "Returns the interpolation settings."
        },
        "interpolate_": {
          "!type": "fn(i1: number, t0: number, t: number, t1: number) -> +TypedArray",
          "!doc": "Copies a sample value to the result buffer."
        },
        "intervalChanged_": {
          "!type": "fn(i1: number, t0: number, t: number)",
          "!doc": "Optional method that is executed when the interval has changed."
        }
      },
      "!type": "fn()"
    },
    "Bone": {
      "!url": "https://threejs.org/docs/#api/en/objects/Bone",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new bone.",
      "!type": "fn()"
    },
    "BooleanKeyframeTrack": {
      "!url": "https://threejs.org/docs/#api/en/animation/BooleanKeyframeTrack",
      "prototype": {
        "!proto": "THREE.KeyframeTrack.prototype",
        "DefaultInterpolation": {
          "!type": "+THREE.InterpolateLinear",
          "!doc": "The default interpolation type of this keyframe track."
        },
        "TimeBufferType": {
          "!type": "+TypedArray",
          "!doc": "The time buffer type of this keyframe track."
        },
        "ValueBufferType": {
          "!type": "+TypedArray",
          "!doc": "The value buffer type of this keyframe track."
        },
        "ValueTypeName": {
          "!type": "string",
          "!doc": "The value type name."
        },
        "name": {
          "!type": "string",
          "!doc": "The track's name can refer to morph targets or bones or possibly other values within an animated object. See PropertyBinding for the forms of strings that can be parsed for property binding."
        },
        "times": {
          "!type": "+Float32Array",
          "!doc": "The keyframe times."
        },
        "values": {
          "!type": "+Float32Array",
          "!doc": "The keyframe values."
        },
        "InterpolantFactoryMethodBezier": {
          "!type": "fn(result: +TypedArray) -> +THREE.BezierInterpolant",
          "!doc": "Factory method for creating a new Bezier interpolant. The Bezier interpolant requires tangent data to be set via the settings property on the track before creating the interpolant. The settings should contain: - inTangents: Float32Array with [time, value] pairs per keyframe per component - outTangents: Float32Array with [time, value] pairs per keyframe per component"
        },
        "InterpolantFactoryMethodDiscrete": {
          "!type": "fn(result: +TypedArray) -> +THREE.DiscreteInterpolant",
          "!doc": "Factory method for creating a new discrete interpolant."
        },
        "InterpolantFactoryMethodLinear": {
          "!type": "fn(result: +TypedArray) -> +THREE.LinearInterpolant",
          "!doc": "Factory method for creating a new linear interpolant."
        },
        "InterpolantFactoryMethodSmooth": {
          "!type": "fn(result: +TypedArray) -> +THREE.CubicInterpolant",
          "!doc": "Factory method for creating a new smooth interpolant."
        },
        "clone": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Returns a new keyframe track with copied values from this instance."
        },
        "getInterpolation": {
          "!type": "fn() -> +THREE.InterpolateLinear",
          "!doc": "Returns the current interpolation type."
        },
        "getValueSize": {
          "!type": "fn() -> number",
          "!doc": "Returns the value size."
        },
        "optimize": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Optimizes this keyframe track by removing equivalent sequential keys (which are common in morph target sequences)."
        },
        "scale": {
          "!type": "fn(timeScale: number) -> +THREE.KeyframeTrack",
          "!doc": "Scale all keyframe times by a factor (useful for frame - seconds conversions)."
        },
        "setInterpolation": {
          "!type": "fn(interpolation: +THREE.InterpolateLinear) -> +THREE.KeyframeTrack",
          "!doc": "Defines the interpolation factor method for this keyframe track."
        },
        "shift": {
          "!type": "fn(timeOffset: number) -> +THREE.KeyframeTrack",
          "!doc": "Moves all keyframes either forward or backward in time."
        },
        "trim": {
          "!type": "fn(startTime: number, endTime: number) -> +THREE.KeyframeTrack",
          "!doc": "Removes keyframes before and after animation without changing any values within the defined time range. Note: The method does not shift around keys to the start of the track time, because for interpolated keys this will change their values"
        },
        "validate": {
          "!type": "fn() -> bool",
          "!doc": "Performs minimal validation on the keyframe track. Returns true if the values are valid."
        }
      },
      "!doc": "Constructs a new boolean keyframe track. This keyframe track type has no interpolation parameter because the interpolation is always discrete.",
      "!type": "fn(name: string, times, values)"
    },
    "Box2": {
      "!url": "https://threejs.org/docs/#api/en/math/Box2",
      "prototype": {
        "max": {
          "!type": "+THREE.Vector2",
          "!doc": "The upper boundary of the box."
        },
        "min": {
          "!type": "+THREE.Vector2",
          "!doc": "The lower boundary of the box."
        },
        "clampPoint": {
          "!type": "fn(point: +THREE.Vector2, target: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Clamps the given point within the bounds of this box."
        },
        "clone": {
          "!type": "fn() -> +THREE.Box2",
          "!doc": "Returns a new box with copied values from this instance."
        },
        "containsBox": {
          "!type": "fn(box: +THREE.Box2) -> bool",
          "!doc": "Returns true if this bounding box includes the entirety of the given bounding box. If this box and the given one are identical, this function also returns true."
        },
        "containsPoint": {
          "!type": "fn(point: +THREE.Vector2) -> bool",
          "!doc": "Returns true if the given point lies within or on the boundaries of this box."
        },
        "copy": {
          "!type": "fn(box: +THREE.Box2) -> +THREE.Box2",
          "!doc": "Copies the values of the given box to this instance."
        },
        "distanceToPoint": {
          "!type": "fn(point: +THREE.Vector2) -> number",
          "!doc": "Returns the euclidean distance from any edge of this box to the specified point. If the given point lies inside of this box, the distance will be 0."
        },
        "equals": {
          "!type": "fn(box: +THREE.Box2) -> bool",
          "!doc": "Returns true if this bounding box is equal with the given one."
        },
        "expandByPoint": {
          "!type": "fn(point: +THREE.Vector2) -> +THREE.Box2",
          "!doc": "Expands the boundaries of this box to include the given point."
        },
        "expandByScalar": {
          "!type": "fn(scalar: number) -> +THREE.Box2",
          "!doc": "Expands each dimension of the box by the given scalar. If negative, the dimensions of the box will be contracted."
        },
        "expandByVector": {
          "!type": "fn(vector: +THREE.Vector2) -> +THREE.Box2",
          "!doc": "Expands this box equilaterally by the given vector. The width of this box will be expanded by the x component of the vector in both directions. The height of this box will be expanded by the y component of the vector in both directions."
        },
        "getCenter": {
          "!type": "fn(target: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns the center point of this box."
        },
        "getParameter": {
          "!type": "fn(point: +THREE.Vector2, target: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a point as a proportion of this box's width and height."
        },
        "getSize": {
          "!type": "fn(target: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns the dimensions of this box."
        },
        "intersect": {
          "!type": "fn(box: +THREE.Box2) -> +THREE.Box2",
          "!doc": "Computes the intersection of this bounding box and the given one, setting the upper bound of this box to the lesser of the two boxes' upper bounds and the lower bound of this box to the greater of the two boxes' lower bounds. If there's no overlap, makes this box empty."
        },
        "intersectsBox": {
          "!type": "fn(box: +THREE.Box2) -> bool",
          "!doc": "Returns true if the given bounding box intersects with this bounding box."
        },
        "isEmpty": {
          "!type": "fn() -> bool",
          "!doc": "Returns true if this box includes zero points within its bounds. Note that a box with equal lower and upper bounds still includes one point, the one both bounds share."
        },
        "makeEmpty": {
          "!type": "fn() -> +THREE.Box2",
          "!doc": "Makes this box empty which means in encloses a zero space in 2D."
        },
        "set": {
          "!type": "fn(min: +THREE.Vector2, max: +THREE.Vector2) -> +THREE.Box2",
          "!doc": "Sets the lower and upper boundaries of this box. Please note that this method only copies the values from the given objects."
        },
        "setFromCenterAndSize": {
          "!type": "fn(center: +THREE.Vector2, size: +THREE.Vector2) -> +THREE.Box2",
          "!doc": "Centers this box on the given center vector and sets this box's width, height and depth to the given size values."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.Box2",
          "!doc": "Sets the upper and lower bounds of this box so it encloses the position data in the given array."
        },
        "translate": {
          "!type": "fn(offset: +THREE.Vector2) -> +THREE.Box2",
          "!doc": "Adds the given offset to both the upper and lower bounds of this bounding box, effectively moving it in 2D space."
        },
        "union": {
          "!type": "fn(box: +THREE.Box2) -> +THREE.Box2",
          "!doc": "Computes the union of this box and another and the given one, setting the upper bound of this box to the greater of the two boxes' upper bounds and the lower bound of this box to the lesser of the two boxes' lower bounds."
        }
      },
      "!doc": "Constructs a new bounding box.",
      "!type": "fn(min: +THREE.Vector2, max: +THREE.Vector2)"
    },
    "Box3": {
      "!url": "https://threejs.org/docs/#api/en/math/Box3",
      "prototype": {
        "max": {
          "!type": "+THREE.Vector3",
          "!doc": "The upper boundary of the box."
        },
        "min": {
          "!type": "+THREE.Vector3",
          "!doc": "The lower boundary of the box."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.Box3",
          "!doc": "Transforms this bounding box by the given 4x4 transformation matrix."
        },
        "clampPoint": {
          "!type": "fn(point: +THREE.Vector3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Clamps the given point within the bounds of this box."
        },
        "clone": {
          "!type": "fn() -> +THREE.Box3",
          "!doc": "Returns a new box with copied values from this instance."
        },
        "containsBox": {
          "!type": "fn(box: +THREE.Box3) -> bool",
          "!doc": "Returns true if this bounding box includes the entirety of the given bounding box. If this box and the given one are identical, this function also returns true."
        },
        "containsPoint": {
          "!type": "fn(point: +THREE.Vector3) -> bool",
          "!doc": "Returns true if the given point lies within or on the boundaries of this box."
        },
        "copy": {
          "!type": "fn(box: +THREE.Box3) -> +THREE.Box3",
          "!doc": "Copies the values of the given box to this instance."
        },
        "distanceToPoint": {
          "!type": "fn(point: +THREE.Vector3) -> number",
          "!doc": "Returns the euclidean distance from any edge of this box to the specified point. If the given point lies inside of this box, the distance will be 0."
        },
        "equals": {
          "!type": "fn(box: +THREE.Box3) -> bool",
          "!doc": "Returns true if this bounding box is equal with the given one."
        },
        "expandByObject": {
          "!type": "fn(object: +THREE.Object3D, precise: bool) -> +THREE.Box3",
          "!doc": "Expands the boundaries of this box to include the given 3D object and its children, accounting for the object's, and children's, world transforms. The function may result in a larger box than strictly necessary (unless the precise parameter is set to true)."
        },
        "expandByPoint": {
          "!type": "fn(point: +THREE.Vector3) -> +THREE.Box3",
          "!doc": "Expands the boundaries of this box to include the given point."
        },
        "expandByScalar": {
          "!type": "fn(scalar: number) -> +THREE.Box3",
          "!doc": "Expands each dimension of the box by the given scalar. If negative, the dimensions of the box will be contracted."
        },
        "expandByVector": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Box3",
          "!doc": "Expands this box equilaterally by the given vector. The width of this box will be expanded by the x component of the vector in both directions. The height of this box will be expanded by the y component of the vector in both directions. The depth of this box will be expanded by the z component of the vector in both directions."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Box3",
          "!doc": "Returns a serialized structure of the bounding box."
        },
        "getBoundingSphere": {
          "!type": "fn(target: +THREE.Sphere) -> +THREE.Sphere",
          "!doc": "Returns a bounding sphere that encloses this bounding box."
        },
        "getCenter": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the center point of this box."
        },
        "getParameter": {
          "!type": "fn(point: +THREE.Vector3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a point as a proportion of this box's width, height and depth."
        },
        "getSize": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the dimensions of this box."
        },
        "intersect": {
          "!type": "fn(box: +THREE.Box3) -> +THREE.Box3",
          "!doc": "Computes the intersection of this bounding box and the given one, setting the upper bound of this box to the lesser of the two boxes' upper bounds and the lower bound of this box to the greater of the two boxes' lower bounds. If there's no overlap, makes this box empty."
        },
        "intersectsBox": {
          "!type": "fn(box: +THREE.Box3) -> bool",
          "!doc": "Returns true if the given bounding box intersects with this bounding box."
        },
        "intersectsPlane": {
          "!type": "fn(plane: +THREE.Plane) -> bool",
          "!doc": "Returns true if the given plane intersects with this bounding box."
        },
        "intersectsSphere": {
          "!type": "fn(sphere: +THREE.Sphere) -> bool",
          "!doc": "Returns true if the given bounding sphere intersects with this bounding box."
        },
        "intersectsTriangle": {
          "!type": "fn(triangle: +THREE.Triangle) -> bool",
          "!doc": "Returns true if the given triangle intersects with this bounding box."
        },
        "isEmpty": {
          "!type": "fn() -> bool",
          "!doc": "Returns true if this box includes zero points within its bounds. Note that a box with equal lower and upper bounds still includes one point, the one both bounds share."
        },
        "makeEmpty": {
          "!type": "fn() -> +THREE.Box3",
          "!doc": "Makes this box empty which means in encloses a zero space in 3D."
        },
        "set": {
          "!type": "fn(min: +THREE.Vector3, max: +THREE.Vector3) -> +THREE.Box3",
          "!doc": "Sets the lower and upper boundaries of this box. Please note that this method only copies the values from the given objects."
        },
        "setFromArray": {
          "!type": "fn(array) -> +THREE.Box3",
          "!doc": "Sets the upper and lower bounds of this box so it encloses the position data in the given array."
        },
        "setFromBufferAttribute": {
          "!type": "fn(attribute: +THREE.BufferAttribute) -> +THREE.Box3",
          "!doc": "Sets the upper and lower bounds of this box so it encloses the position data in the given buffer attribute."
        },
        "setFromCenterAndSize": {
          "!type": "fn(center: +THREE.Vector3, size: +THREE.Vector3) -> +THREE.Box3",
          "!doc": "Centers this box on the given center vector and sets this box's width, height and depth to the given size values."
        },
        "setFromObject": {
          "!type": "fn(object: +THREE.Object3D, precise: bool) -> +THREE.Box3",
          "!doc": "Computes the world-axis-aligned bounding box for the given 3D object (including its children), accounting for the object's, and children's, world transforms. The function may result in a larger box than strictly necessary."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.Box3",
          "!doc": "Sets the upper and lower bounds of this box so it encloses the position data in the given array."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Returns a serialized structure of the bounding box."
        },
        "translate": {
          "!type": "fn(offset: +THREE.Vector3) -> +THREE.Box3",
          "!doc": "Adds the given offset to both the upper and lower bounds of this bounding box, effectively moving it in 3D space."
        },
        "union": {
          "!type": "fn(box: +THREE.Box3) -> +THREE.Box3",
          "!doc": "Computes the union of this box and another and the given one, setting the upper bound of this box to the greater of the two boxes' upper bounds and the lower bound of this box to the lesser of the two boxes' lower bounds."
        }
      },
      "!doc": "Constructs a new bounding box.",
      "!type": "fn(min: +THREE.Vector3, max: +THREE.Vector3)"
    },
    "Box3Helper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/Box3Helper",
      "prototype": {
        "!proto": "THREE.LineSegments.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "box": {
          "!type": "+THREE.Box3",
          "!doc": "The box being visualized."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The line geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The line material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeLineDistances": {
          "!type": "fn() -> +THREE.Line",
          "!doc": "Computes an array of distance values which are necessary for rendering dashed lines. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Line and Line to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new box3 helper.",
      "!type": "fn(box: +THREE.Box3, color: number)"
    },
    "BoxGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/BoxGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.BoxGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new box geometry.",
      "!type": "fn(width: number, height: number, depth: number, widthSegments: number, heightSegments: number, depthSegments: number)"
    },
    "BoxHelper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/BoxHelper",
      "prototype": {
        "!proto": "THREE.LineSegments.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The line geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The line material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "object": {
          "!type": "+THREE.Object3D",
          "!doc": "The 3D object being visualized."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeLineDistances": {
          "!type": "fn() -> +THREE.Line",
          "!doc": "Computes an array of distance values which are necessary for rendering dashed lines. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setFromObject": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.BoxHelper",
          "!doc": "Updates the wireframe box for the passed object."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "update": {
          "!type": "fn()",
          "!doc": "Updates the helper's geometry to match the dimensions of the object, including any children."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Line and Line to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new box helper.",
      "!type": "fn(object: +THREE.Object3D, color: number)"
    },
    "BufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/BufferAttribute",
      "prototype": {
        "array": {
          "!type": "+TypedArray",
          "!doc": "The array holding the attribute data. It should have itemSize * numVertices elements, where numVertices is the number of vertices in the associated geometry."
        },
        "count": {
          "!type": "number",
          "!doc": "Represents the number of items this buffer attribute stores. It is internally computed by dividing the array length by the itemSize."
        },
        "gpuType": {
          "!type": "+THREE.FloatType",
          "!doc": "Configures the bound GPU type for use in shaders. Note: this only has an effect for integer arrays and is not configurable for float arrays. For lower precision float types, use Float16BufferAttribute."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the buffer attribute."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The number of values of the array that should be associated with a particular vertex. For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then the value should be 3."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "bool",
          "!doc": "Applies to integer data only. Indicates how the underlying data in the buffer maps to the values in the GLSL code. For instance, if array is an instance of UInt16Array, and normalized is true, the values 0 - +65535 in the array data will be mapped to 0.0f - +1.0f in the GLSL attribute. If normalized is false, the values will be converted to floats unmodified, i.e. 65535 becomes 65535.0f."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 matrix to the given attribute. Works with item size 2 and 3."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 normal matrix to the given attribute. Only works with item size 3."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns a new buffer attribute with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferAttribute) -> +THREE.BufferAttribute",
          "!doc": "Copies the values of the given buffer attribute to this instance."
        },
        "copyArray": {
          "!type": "fn(array: +TypedArray) -> +THREE.BufferAttribute",
          "!doc": "Copies the given array data into this buffer attribute."
        },
        "copyAt": {
          "!type": "fn(index1: number, attribute: +THREE.BufferAttribute, index2: number) -> +THREE.BufferAttribute",
          "!doc": "Copies a vector from the given buffer attribute to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "getComponent": {
          "!type": "fn(index: number, component: number) -> number",
          "!doc": "Returns the given component of the vector at the given index."
        },
        "getW": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the w component of the vector at the given index."
        },
        "getX": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the x component of the vector at the given index."
        },
        "getY": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the y component of the vector at the given index."
        },
        "getZ": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the z component of the vector at the given index."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.BufferAttribute",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the attribute array data to the GPU. Can be used to perform clean-up operations after the upload when attribute data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given array data in the buffer attribute."
        },
        "setComponent": {
          "!type": "fn(index: number, component: number, value: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given value to the given component of the vector at the given index."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.BufferAttribute",
          "!doc": "Sets the usage of this buffer attribute."
        },
        "setW": {
          "!type": "fn(index: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the w component of the vector at the given index."
        },
        "setX": {
          "!type": "fn(index: number, x: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x component of the vector at the given index."
        },
        "setXY": {
          "!type": "fn(index: number, x: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x and y component of the vector at the given index."
        },
        "setXYZ": {
          "!type": "fn(index: number, x: number, y: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y and z component of the vector at the given index."
        },
        "setXYZW": {
          "!type": "fn(index: number, x: number, y: number, z: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y, z and w component of the vector at the given index."
        },
        "setY": {
          "!type": "fn(index: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the y component of the vector at the given index."
        },
        "setZ": {
          "!type": "fn(index: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the z component of the vector at the given index."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the buffer attribute into JSON."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3 and with direction vectors."
        }
      },
      "!doc": "Constructs a new buffer attribute.",
      "!type": "fn(array: +TypedArray, itemSize: number, normalized: bool)"
    },
    "BufferGeometry": {
      "!url": "https://threejs.org/docs/#api/en/core/BufferGeometry",
      "prototype": {
        "!proto": "THREE.EventDispatcher.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        }
      },
      "!doc": "Constructs a new geometry.",
      "!type": "fn()"
    },
    "BufferGeometryLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/BufferGeometryLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback)",
          "!doc": "Starts loading from the given URL and pass the loaded geometry to the onLoad() callback."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(json: object) -> +THREE.BufferGeometry",
          "!doc": "Parses the given JSON object and returns a geometry."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new geometry loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "Cache": {
      "!url": "https://threejs.org/docs/#api/en/loaders/Cache",
      "prototype": {
        "enabled": {
          "!type": "bool",
          "!doc": "Whether caching is enabled or not."
        },
        "files": {
          "!doc": "A dictionary that holds cached files."
        },
        "add": {
          "!type": "fn(key: string, file: object)",
          "!doc": "Adds a cache entry with a key to reference the file. If this key already holds a file, it is overwritten."
        },
        "clear": {
          "!type": "fn()",
          "!doc": "Remove all values from the cache."
        },
        "get": {
          "!type": "fn(key: string) -> object",
          "!doc": "Gets the cached value for the given key."
        },
        "remove": {
          "!type": "fn(key: string)",
          "!doc": "Removes the cached file associated with the given key."
        }
      },
      "!type": "fn()"
    },
    "Camera": {
      "!url": "https://threejs.org/docs/#api/en/cameras/Camera",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "coordinateSystem": {
          "!type": "+THREE.WebGLCoordinateSystem",
          "!doc": "The coordinate system in which the camera is used."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldInverse": {
          "!type": "+THREE.Matrix4",
          "!doc": "The inverse of the camera's world matrix."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "projectionMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "The camera's projection matrix."
        },
        "projectionMatrixInverse": {
          "!type": "+THREE.Matrix4",
          "!doc": "The inverse of the camera's projection matrix."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "reversedDepth": {
          "!type": "bool",
          "!doc": "The flag that indicates whether the camera uses a reversed depth buffer."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space. This method is overwritten since cameras have a different forward vector compared to other 3D objects. A camera looks down its local, negative z-axis by default."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new camera.",
      "!type": "fn()"
    },
    "CameraHelper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/CameraHelper",
      "prototype": {
        "!proto": "THREE.LineSegments.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "camera": {
          "!type": "+THREE.Camera",
          "!doc": "The camera being visualized."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The line geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The line material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "pointMap": {
          "!doc": "This contains the points used to visualize the camera."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeLineDistances": {
          "!type": "fn() -> +THREE.Line",
          "!doc": "Computes an array of distance values which are necessary for rendering dashed lines. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setColors": {
          "!type": "fn(frustum: +THREE.Color, cone: +THREE.Color, up: +THREE.Color, target: +THREE.Color, cross: +THREE.Color) -> +THREE.CameraHelper",
          "!doc": "Defines the colors of the helper."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "update": {
          "!type": "fn()",
          "!doc": "Updates the helper based on the projection matrix of the camera."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Line and Line to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new arrow helper.",
      "!type": "fn(camera: +THREE.Camera)"
    },
    "CanvasTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/CanvasTexture",
      "prototype": {
        "!proto": "THREE.Texture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure the flip on bitmap creation instead."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Set this to false if you are creating mipmaps manually."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image object holding the texture data."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel."
        },
        "mipmaps": {
          "!doc": "An array holding user-defined mipmaps."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries)."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new texture.",
      "!type": "fn(canvas: +THREE.HTMLCanvasElement, mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, format: number, type: number, anisotropy: number)"
    },
    "CapsuleGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/CapsuleGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.CapsuleGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new capsule geometry.",
      "!type": "fn(radius: number, height: number, capSegments: number, radialSegments: number, heightSegments: number)"
    },
    "CatmullRomCurve3": {
      "!url": "https://threejs.org/docs/#api/en/extras/CatmullRomCurve3",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "closed": {
          "!type": "bool",
          "!doc": "Whether the curve is closed or not."
        },
        "curveType": {
          "!type": "+THREE.centripetal",
          "!doc": "The curve type."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "points": {
          "!doc": "An array of 3D points defining the curve."
        },
        "tension": {
          "!type": "number",
          "!doc": "Tension of the curve."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a point on the curve."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new Catmull-Rom curve.",
      "!type": "fn(points, closed: bool, curveType: +THREE.centripetal, tension: number)"
    },
    "CircleGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/CircleGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.CircleGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new circle geometry.",
      "!type": "fn(radius: number, segments: number, thetaStart: number, thetaLength: number)"
    },
    "ClippingGroup": {
      "!url": "https://threejs.org/docs/#api/en/objects/ClippingGroup",
      "prototype": {
        "!proto": "THREE.Group.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Whether the intersection of the clipping planes is used to clip objects, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Whether shadows should be clipped or not."
        },
        "clippingPlanes": {
          "!doc": "An array with clipping planes."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "enabled": {
          "!type": "bool",
          "!doc": "Whether clipping should be enabled or not."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new clipping group.",
      "!type": "fn()"
    },
    "Clock": {
      "!url": "https://threejs.org/docs/#api/en/core/Clock",
      "prototype": {
        "autoStart": {
          "!type": "bool",
          "!doc": "If set to true, the clock starts automatically when getDelta() is called for the first time."
        },
        "elapsedTime": {
          "!type": "number",
          "!doc": "Keeps track of the total time that the clock has been running."
        },
        "oldTime": {
          "!type": "number",
          "!doc": "Holds the time at which the clock's start(), getElapsedTime() or getDelta() methods were last called."
        },
        "running": {
          "!type": "bool",
          "!doc": "Whether the clock is running or not."
        },
        "startTime": {
          "!type": "number",
          "!doc": "Holds the time at which the clock's start() method was last called."
        },
        "getDelta": {
          "!type": "fn() -> number",
          "!doc": "Returns the delta time in seconds."
        },
        "getElapsedTime": {
          "!type": "fn() -> number",
          "!doc": "Returns the elapsed time in seconds."
        },
        "start": {
          "!type": "fn()",
          "!doc": "Starts the clock. When autoStart is set to true, the method is automatically called by the class."
        },
        "stop": {
          "!type": "fn()",
          "!doc": "Stops the clock."
        }
      },
      "!doc": "Constructs a new clock.",
      "!type": "fn(autoStart: bool)"
    },
    "Color": {
      "!url": "https://threejs.org/docs/#api/en/math/Color",
      "prototype": {
        "b": {
          "!type": "number",
          "!doc": "The blue component."
        },
        "g": {
          "!type": "number",
          "!doc": "The green component."
        },
        "r": {
          "!type": "number",
          "!doc": "The red component."
        },
        "NAMES": {
          "!type": "object",
          "!doc": "A dictionary with X11 color names. Note that multiple words such as Dark Orange become the string 'darkorange'."
        },
        "add": {
          "!type": "fn(color: +THREE.Color) -> +THREE.Color",
          "!doc": "Adds the RGB values of the given color to the RGB values of this color."
        },
        "addColors": {
          "!type": "fn(color1: +THREE.Color, color2: +THREE.Color) -> +THREE.Color",
          "!doc": "Adds the RGB values of the given colors and stores the result in this instance."
        },
        "addScalar": {
          "!type": "fn(s: number) -> +THREE.Color",
          "!doc": "Adds the given scalar value to the RGB values of this color."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.Color",
          "!doc": "Transforms this color with the given 3x3 matrix."
        },
        "clone": {
          "!type": "fn() -> +THREE.Color",
          "!doc": "Returns a new color with copied values from this instance."
        },
        "convertLinearToSRGB": {
          "!type": "fn() -> +THREE.Color",
          "!doc": "Converts this color from LinearSRGBColorSpace to SRGBColorSpace."
        },
        "convertSRGBToLinear": {
          "!type": "fn() -> +THREE.Color",
          "!doc": "Converts this color from SRGBColorSpace to LinearSRGBColorSpace."
        },
        "copy": {
          "!type": "fn(color: +THREE.Color) -> +THREE.Color",
          "!doc": "Copies the values of the given color to this instance."
        },
        "copyLinearToSRGB": {
          "!type": "fn(color: +THREE.Color) -> +THREE.Color",
          "!doc": "Copies the given color into this color, and then converts this color from LinearSRGBColorSpace to SRGBColorSpace."
        },
        "copySRGBToLinear": {
          "!type": "fn(color: +THREE.Color) -> +THREE.Color",
          "!doc": "Copies the given color into this color, and then converts this color from SRGBColorSpace to LinearSRGBColorSpace."
        },
        "equals": {
          "!type": "fn(c: +THREE.Color) -> bool",
          "!doc": "Returns true if this color is equal with the given one."
        },
        "fromArray": {
          "!type": "fn(array, offset: number) -> +THREE.Color",
          "!doc": "Sets this color's RGB components from the given array."
        },
        "fromBufferAttribute": {
          "!type": "fn(attribute: +THREE.BufferAttribute, index: number) -> +THREE.Color",
          "!doc": "Sets the components of this color from the given buffer attribute."
        },
        "getHSL": {
          "!type": "fn(target: object, colorSpace: string) -> object",
          "!doc": "Converts the colors RGB values into the HSL format and stores them into the given target object."
        },
        "getHex": {
          "!type": "fn(colorSpace: string) -> number",
          "!doc": "Returns the hexadecimal value of this color."
        },
        "getHexString": {
          "!type": "fn(colorSpace: string) -> string",
          "!doc": "Returns the hexadecimal value of this color as a string (for example, 'FFFFFF')."
        },
        "getRGB": {
          "!type": "fn(target: +THREE.Color, colorSpace: string) -> +THREE.Color",
          "!doc": "Returns the RGB values of this color and stores them into the given target object."
        },
        "getStyle": {
          "!type": "fn(colorSpace: string) -> string",
          "!doc": "Returns the value of this color as a CSS style string. Example: rgb(255,0,0)."
        },
        "lerp": {
          "!type": "fn(color: +THREE.Color, alpha: number) -> +THREE.Color",
          "!doc": "Linearly interpolates this color's RGB values toward the RGB values of the given color. The alpha argument can be thought of as the ratio between the two colors, where 0.0 is this color and 1.0 is the first argument."
        },
        "lerpColors": {
          "!type": "fn(color1: +THREE.Color, color2: +THREE.Color, alpha: number) -> +THREE.Color",
          "!doc": "Linearly interpolates between the given colors and stores the result in this instance. The alpha argument can be thought of as the ratio between the two colors, where 0.0 is the first and 1.0 is the second color."
        },
        "lerpHSL": {
          "!type": "fn(color: +THREE.Color, alpha: number) -> +THREE.Color",
          "!doc": "Linearly interpolates this color's HSL values toward the HSL values of the given color. It differs from Color by not interpolating straight from one color to the other, but instead going through all the hues in between those two colors. The alpha argument can be thought of as the ratio between the two colors, where 0.0 is this color and 1.0 is the first argument."
        },
        "multiply": {
          "!type": "fn(color: +THREE.Color) -> +THREE.Color",
          "!doc": "Multiplies the RGB values of the given color with the RGB values of this color."
        },
        "multiplyScalar": {
          "!type": "fn(s: number) -> +THREE.Color",
          "!doc": "Multiplies the given scalar value with the RGB values of this color."
        },
        "offsetHSL": {
          "!type": "fn(h: number, s: number, l: number) -> +THREE.Color",
          "!doc": "Adds the given HSL values to this color's values. Internally, this converts the color's RGB values to HSL, adds HSL and then converts the color back to RGB."
        },
        "set": {
          "!type": "fn(r: number, g: number, b: number) -> +THREE.Color",
          "!doc": "Sets the colors's components from the given values."
        },
        "setColorName": {
          "!type": "fn(style: string, colorSpace: string) -> +THREE.Color",
          "!doc": "Sets this color from a color name. Faster than Color if you don't need the other CSS-style formats. For convenience, the list of names is exposed in Color.NAMES as a hash. ``js Color.NAMES.aliceblue // returns 0xF0F8FF ``"
        },
        "setFromVector3": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Color",
          "!doc": "Sets the color's RGB components from the given 3D vector."
        },
        "setHSL": {
          "!type": "fn(h: number, s: number, l: number, colorSpace: string) -> +THREE.Color",
          "!doc": "Sets this color from RGB values."
        },
        "setHex": {
          "!type": "fn(hex: number, colorSpace: string) -> +THREE.Color",
          "!doc": "Sets this color from a hexadecimal value."
        },
        "setRGB": {
          "!type": "fn(r: number, g: number, b: number, colorSpace: string) -> +THREE.Color",
          "!doc": "Sets this color from RGB values."
        },
        "setScalar": {
          "!type": "fn(scalar: number) -> +THREE.Color",
          "!doc": "Sets the colors's components to the given scalar value."
        },
        "setStyle": {
          "!type": "fn(style: string, colorSpace: string) -> +THREE.Color",
          "!doc": "Sets this color from a CSS-style string. For example, rgb(250, 0,0), rgb(100%, 0%, 0%), hsl(0, 100%, 50%), #ff0000, #f00, or red ( or any [X11 color name](https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart) - all 140 color names are supported)."
        },
        "sub": {
          "!type": "fn(color: +THREE.Color) -> +THREE.Color",
          "!doc": "Subtracts the RGB values of the given color from the RGB values of this color."
        },
        "toArray": {
          "!type": "fn(array, offset: number)",
          "!doc": "Writes the RGB components of this color to the given array. If no array is provided, the method returns a new instance."
        },
        "toJSON": {
          "!type": "fn() -> number",
          "!doc": "This methods defines the serialization result of this class. Returns the color as a hexadecimal value."
        }
      },
      "!doc": "Constructs a new color. Note that standard method of specifying color in three.js is with a hexadecimal triplet, and that method is used throughout the rest of the documentation.",
      "!type": "fn(r: number, g: number, b: number)"
    },
    "ColorKeyframeTrack": {
      "!url": "https://threejs.org/docs/#api/en/animation/ColorKeyframeTrack",
      "prototype": {
        "!proto": "THREE.KeyframeTrack.prototype",
        "DefaultInterpolation": {
          "!type": "+THREE.InterpolateLinear",
          "!doc": "The default interpolation type of this keyframe track."
        },
        "TimeBufferType": {
          "!type": "+TypedArray",
          "!doc": "The time buffer type of this keyframe track."
        },
        "ValueBufferType": {
          "!type": "+TypedArray",
          "!doc": "The value buffer type of this keyframe track."
        },
        "ValueTypeName": {
          "!type": "string",
          "!doc": "The value type name."
        },
        "name": {
          "!type": "string",
          "!doc": "The track's name can refer to morph targets or bones or possibly other values within an animated object. See PropertyBinding for the forms of strings that can be parsed for property binding."
        },
        "times": {
          "!type": "+Float32Array",
          "!doc": "The keyframe times."
        },
        "values": {
          "!type": "+Float32Array",
          "!doc": "The keyframe values."
        },
        "InterpolantFactoryMethodBezier": {
          "!type": "fn(result: +TypedArray) -> +THREE.BezierInterpolant",
          "!doc": "Factory method for creating a new Bezier interpolant. The Bezier interpolant requires tangent data to be set via the settings property on the track before creating the interpolant. The settings should contain: - inTangents: Float32Array with [time, value] pairs per keyframe per component - outTangents: Float32Array with [time, value] pairs per keyframe per component"
        },
        "InterpolantFactoryMethodDiscrete": {
          "!type": "fn(result: +TypedArray) -> +THREE.DiscreteInterpolant",
          "!doc": "Factory method for creating a new discrete interpolant."
        },
        "InterpolantFactoryMethodLinear": {
          "!type": "fn(result: +TypedArray) -> +THREE.LinearInterpolant",
          "!doc": "Factory method for creating a new linear interpolant."
        },
        "InterpolantFactoryMethodSmooth": {
          "!type": "fn(result: +TypedArray) -> +THREE.CubicInterpolant",
          "!doc": "Factory method for creating a new smooth interpolant."
        },
        "clone": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Returns a new keyframe track with copied values from this instance."
        },
        "getInterpolation": {
          "!type": "fn() -> +THREE.InterpolateLinear",
          "!doc": "Returns the current interpolation type."
        },
        "getValueSize": {
          "!type": "fn() -> number",
          "!doc": "Returns the value size."
        },
        "optimize": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Optimizes this keyframe track by removing equivalent sequential keys (which are common in morph target sequences)."
        },
        "scale": {
          "!type": "fn(timeScale: number) -> +THREE.KeyframeTrack",
          "!doc": "Scale all keyframe times by a factor (useful for frame - seconds conversions)."
        },
        "setInterpolation": {
          "!type": "fn(interpolation: +THREE.InterpolateLinear) -> +THREE.KeyframeTrack",
          "!doc": "Defines the interpolation factor method for this keyframe track."
        },
        "shift": {
          "!type": "fn(timeOffset: number) -> +THREE.KeyframeTrack",
          "!doc": "Moves all keyframes either forward or backward in time."
        },
        "trim": {
          "!type": "fn(startTime: number, endTime: number) -> +THREE.KeyframeTrack",
          "!doc": "Removes keyframes before and after animation without changing any values within the defined time range. Note: The method does not shift around keys to the start of the track time, because for interpolated keys this will change their values"
        },
        "validate": {
          "!type": "fn() -> bool",
          "!doc": "Performs minimal validation on the keyframe track. Returns true if the values are valid."
        }
      },
      "!doc": "Constructs a new color keyframe track.",
      "!type": "fn(name: string, times, values, interpolation: +THREE.InterpolateLinear)"
    },
    "CompressedArrayTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/CompressedArrayTexture",
      "prototype": {
        "!proto": "THREE.CompressedTexture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Overwritten and set to false by default since it is not possible to flip compressed textures."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Overwritten and set to false by default since it is not possible to generate mipmaps for compressed data. Mipmaps must be embedded in the compressed texture file."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image property of a compressed texture just defines its dimensions."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "layerUpdates": {
          "!doc": "A set of all layers which need to be updated in the texture."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel."
        },
        "mipmaps": {
          "!doc": "This array holds for all mipmaps (including the bases mip) the data and dimensions."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries)."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapR": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped in the depth and corresponds to *W* in UVW mapping."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addLayerUpdate": {
          "!type": "fn(layerIndex: number)",
          "!doc": "Describes that a specific layer of the texture needs to be updated. Normally when Texture is set to true, the entire compressed texture array is sent to the GPU. Marking specific layers will only transmit subsets of all mipmaps associated with a specific depth in the array which is often much more performant."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearLayerUpdates": {
          "!type": "fn()",
          "!doc": "Resets the layer updates registry."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new compressed array texture.",
      "!type": "fn(mipmaps, width: number, height: number, depth: number, format: number, type: number)"
    },
    "CompressedCubeTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/CompressedCubeTexture",
      "prototype": {
        "!proto": "THREE.CompressedTexture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Overwritten and set to false by default since it is not possible to flip compressed textures."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Overwritten and set to false by default since it is not possible to generate mipmaps for compressed data. Mipmaps must be embedded in the compressed texture file."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image property of a compressed texture just defines its dimensions."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel."
        },
        "mipmaps": {
          "!doc": "This array holds for all mipmaps (including the bases mip) the data and dimensions."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries)."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new compressed texture.",
      "!type": "fn(images, format: number, type: number)"
    },
    "CompressedTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/CompressedTexture",
      "prototype": {
        "!proto": "THREE.Texture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Overwritten and set to false by default since it is not possible to flip compressed textures."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Overwritten and set to false by default since it is not possible to generate mipmaps for compressed data. Mipmaps must be embedded in the compressed texture file."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image property of a compressed texture just defines its dimensions."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel."
        },
        "mipmaps": {
          "!doc": "This array holds for all mipmaps (including the bases mip) the data and dimensions."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries)."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new compressed texture.",
      "!type": "fn(mipmaps, width: number, height: number, format: number, type: number, mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, anisotropy: number, colorSpace: string)"
    },
    "CompressedTextureLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/CompressedTextureLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback) -> +THREE.CompressedTexture",
          "!doc": "Starts loading from the given URL and passes the loaded compressed texture to the onLoad() callback. The method also returns a new texture object which can directly be used for material creation. If you do it this way, the texture may pop up in your scene once the respective loading process is finished."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(data: ?)",
          "!doc": "This method needs to be implemented by all concrete loaders. It holds the logic for parsing the asset into three.js entities."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new compressed texture loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "ConeGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/ConeGeometry",
      "prototype": {
        "!proto": "THREE.CylinderGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.ConeGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new cone geometry.",
      "!type": "fn(radius: number, height: number, radialSegments: number, heightSegments: number, openEnded: bool, thetaStart: number, thetaLength: number)"
    },
    "Controls": {
      "!url": "https://threejs.org/docs/#api/en/extras/Controls",
      "prototype": {
        "!proto": "THREE.EventDispatcher.prototype",
        "domElement": {
          "!type": "+THREE.HTMLElement",
          "!doc": "The HTML element used for event listeners."
        },
        "enabled": {
          "!type": "bool",
          "!doc": "Whether the controls responds to user input or not."
        },
        "keys": {
          "!type": "object",
          "!doc": "This object defines the keyboard input of the controls."
        },
        "mouseButtons": {
          "!type": "object",
          "!doc": "This object defines what type of actions are assigned to the available mouse buttons. It depends on the control implementation what kind of mouse buttons and actions are supported."
        },
        "object": {
          "!type": "+THREE.Object3D",
          "!doc": "The object that is managed by the controls."
        },
        "state": {
          "!type": "number",
          "!doc": "The internal state of the controls."
        },
        "touches": {
          "!type": "object",
          "!doc": "This object defines what type of actions are assigned to what kind of touch interaction. It depends on the control implementation what kind of touch interaction and actions are supported."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "connect": {
          "!type": "fn(element: +THREE.HTMLElement)",
          "!doc": "Connects the controls to the DOM. This method has so called \"side effects\" since it adds the module's event listeners to the DOM."
        },
        "disconnect": {
          "!type": "fn()",
          "!doc": "Disconnects the controls from the DOM."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Call this method if you no longer want use to the controls. It frees all internal resources and removes all event listeners."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "update": {
          "!type": "fn(delta: number)",
          "!doc": "Controls should implement this method if they have to update their internal state per simulation step."
        }
      },
      "!doc": "Constructs a new controls instance.",
      "!type": "fn(object: +THREE.Object3D, domElement: +THREE.HTMLElement)"
    },
    "CubeCamera": {
      "!url": "https://threejs.org/docs/#api/en/cameras/CubeCamera",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "activeMipmapLevel": {
          "!type": "number",
          "!doc": "The current active mipmap level"
        },
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "coordinateSystem": {
          "!type": "+THREE.WebGLCoordinateSystem",
          "!doc": "The current active coordinate system."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "renderTarget": {
          "!type": "+THREE.WebGLCubeRenderTarget",
          "!doc": "A reference to the cube render target."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "update": {
          "!type": "fn(renderer: +THREE.Renderer, scene: +THREE.Scene)",
          "!doc": "Calling this method will render the given scene with the given renderer into the cube render target of the camera."
        },
        "updateCoordinateSystem": {
          "!type": "fn()",
          "!doc": "Must be called when the coordinate system of the cube camera is changed."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new cube camera.",
      "!type": "fn(near: number, far: number, renderTarget: +THREE.WebGLCubeRenderTarget)"
    },
    "CubeDepthTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/CubeDepthTexture",
      "prototype": {
        "!proto": "THREE.DepthTexture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "compareFunction": {
          "!type": "+THREE.NeverCompare",
          "!doc": "Code corresponding to the depth compare function."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Overwritten and set to false by default."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Overwritten and set to false by default."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image object holding the texture data."
        },
        "images": {
          "!doc": "Alias for CubeDepthTexture."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel."
        },
        "mipmaps": {
          "!doc": "An array holding user-defined mipmaps."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries)."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new cube depth texture.",
      "!type": "fn(size: number, type: number, mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, anisotropy: number, format: number)"
    },
    "CubeTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/CubeTexture",
      "prototype": {
        "!proto": "THREE.Texture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Overwritten and set to false by default."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Set this to false if you are creating mipmaps manually."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image object holding the texture data."
        },
        "images": {
          "!doc": "Alias for CubeTexture."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel."
        },
        "mipmaps": {
          "!doc": "An array holding user-defined mipmaps."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries)."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new cube texture.",
      "!type": "fn(images, mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, format: number, type: number, anisotropy: number, colorSpace: string)"
    },
    "CubeTextureLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/CubeTextureLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "load": {
          "!type": "fn(urls, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback) -> +THREE.CubeTexture",
          "!doc": "Starts loading from the given URL and pass the fully loaded cube texture to the onLoad() callback. The method also returns a new cube texture object which can directly be used for material creation. If you do it this way, the cube texture may pop up in your scene once the respective loading process is finished."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(data: ?)",
          "!doc": "This method needs to be implemented by all concrete loaders. It holds the logic for parsing the asset into three.js entities."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new cube texture loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "CubicBezierCurve": {
      "!url": "https://threejs.org/docs/#api/en/extras/CubicBezierCurve",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "v0": {
          "!type": "+THREE.Vector2",
          "!doc": "The start point."
        },
        "v1": {
          "!type": "+THREE.Vector2",
          "!doc": "The first control point."
        },
        "v2": {
          "!type": "+THREE.Vector2",
          "!doc": "The second control point."
        },
        "v3": {
          "!type": "+THREE.Vector2",
          "!doc": "The end point."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a point on the curve."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new Cubic Bezier curve.",
      "!type": "fn(v0: +THREE.Vector2, v1: +THREE.Vector2, v2: +THREE.Vector2, v3: +THREE.Vector2)"
    },
    "CubicBezierCurve3": {
      "!url": "https://threejs.org/docs/#api/en/extras/CubicBezierCurve3",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "v0": {
          "!type": "+THREE.Vector3",
          "!doc": "The start point."
        },
        "v1": {
          "!type": "+THREE.Vector3",
          "!doc": "The first control point."
        },
        "v2": {
          "!type": "+THREE.Vector3",
          "!doc": "The second control point."
        },
        "v3": {
          "!type": "+THREE.Vector3",
          "!doc": "The end point."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a point on the curve."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new Cubic Bezier curve.",
      "!type": "fn(v0: +THREE.Vector3, v1: +THREE.Vector3, v2: +THREE.Vector3, v3: +THREE.Vector3)"
    },
    "CubicInterpolant": {
      "!url": "https://threejs.org/docs/#api/en/math/CubicInterpolant",
      "prototype": {
        "!proto": "THREE.Interpolant.prototype",
        "DefaultSettings_": {
          "!type": "object",
          "!doc": "The default settings object."
        },
        "parameterPositions": {
          "!type": "+TypedArray",
          "!doc": "The parameter positions."
        },
        "resultBuffer": {
          "!type": "+TypedArray",
          "!doc": "The result buffer."
        },
        "sampleValues": {
          "!type": "+TypedArray",
          "!doc": "The sample values."
        },
        "settings": {
          "!type": "object",
          "!doc": "The interpolation settings."
        },
        "valueSize": {
          "!type": "+TypedArray",
          "!doc": "The value size."
        },
        "copySampleValue_": {
          "!type": "fn(index: number) -> +TypedArray",
          "!doc": "Copies a sample value to the result buffer."
        },
        "evaluate": {
          "!type": "fn(t: number) -> +TypedArray",
          "!doc": "Evaluate the interpolant at position t."
        },
        "getSettings_": {
          "!type": "fn() -> object",
          "!doc": "Returns the interpolation settings."
        },
        "interpolate_": {
          "!type": "fn(i1: number, t0: number, t: number, t1: number) -> +TypedArray",
          "!doc": "Copies a sample value to the result buffer."
        },
        "intervalChanged_": {
          "!type": "fn(i1: number, t0: number, t: number)",
          "!doc": "Optional method that is executed when the interval has changed."
        }
      },
      "!doc": "Constructs a new cubic interpolant.",
      "!type": "fn(parameterPositions: +TypedArray, sampleValues: +TypedArray, sampleSize: number, resultBuffer: +TypedArray)"
    },
    "Curve": {
      "!url": "https://threejs.org/docs/#api/en/extras/Curve",
      "prototype": {
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new curve.",
      "!type": "fn()"
    },
    "CurvePath": {
      "!url": "https://threejs.org/docs/#api/en/extras/CurvePath",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "autoClose": {
          "!type": "bool",
          "!doc": "Whether the path should automatically be closed by a line curve."
        },
        "curves": {
          "!doc": "An array of curves defining the path."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "add": {
          "!type": "fn(curve: +THREE.Curve)",
          "!doc": "Adds a curve to this curve path."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "closePath": {
          "!type": "fn() -> +THREE.CurvePath",
          "!doc": "Adds a line curve to close the path."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getCurveLengths": {
          "!type": "fn()",
          "!doc": "Returns list of cumulative curve lengths of the defined curves."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definitions) for the given interpolation factor."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new curve path.",
      "!type": "fn()"
    },
    "CylinderGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/CylinderGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.CylinderGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new cylinder geometry.",
      "!type": "fn(radiusTop: number, radiusBottom: number, height: number, radialSegments: number, heightSegments: number, openEnded: bool, thetaStart: number, thetaLength: number)"
    },
    "Cylindrical": {
      "!url": "https://threejs.org/docs/#api/en/math/Cylindrical",
      "prototype": {
        "radius": {
          "!type": "number",
          "!doc": "The distance from the origin to a point in the x-z plane."
        },
        "theta": {
          "!type": "number",
          "!doc": "A counterclockwise angle in the x-z plane measured in radians from the positive z-axis."
        },
        "y": {
          "!type": "number",
          "!doc": "The height above the x-z plane."
        },
        "clone": {
          "!type": "fn() -> +THREE.Cylindrical",
          "!doc": "Returns a new cylindrical with copied values from this instance."
        },
        "copy": {
          "!type": "fn(other: +THREE.Cylindrical) -> +THREE.Cylindrical",
          "!doc": "Copies the values of the given cylindrical to this instance."
        },
        "set": {
          "!type": "fn(radius: number, theta: number, y: number) -> +THREE.Cylindrical",
          "!doc": "Sets the cylindrical components by copying the given values."
        },
        "setFromCartesianCoords": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.Cylindrical",
          "!doc": "Sets the cylindrical components from the given Cartesian coordinates."
        },
        "setFromVector3": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Cylindrical",
          "!doc": "Sets the cylindrical components from the given vector which is assumed to hold Cartesian coordinates."
        }
      },
      "!doc": "Constructs a new cylindrical.",
      "!type": "fn(radius: number, theta: number, y: number)"
    },
    "Data3DTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/Data3DTexture",
      "prototype": {
        "!proto": "THREE.Texture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Overwritten and set to false by default."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Overwritten and set to false by default."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image definition of a data texture."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel. Overwritten and set to NearestFilter by default."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel. Overwritten and set to NearestFilter by default."
        },
        "mipmaps": {
          "!doc": "An array holding user-defined mipmaps."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "bool",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. Overwritten and set to 1 by default."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapR": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped in the depth and corresponds to *W* in UVW mapping."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new data array texture.",
      "!type": "fn(data: +TypedArray, width: number, height: number, depth: number)"
    },
    "DataArrayTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/DataArrayTexture",
      "prototype": {
        "!proto": "THREE.Texture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Overwritten and set to false by default."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Overwritten and set to false by default."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image definition of a data texture."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "layerUpdates": {
          "!doc": "A set of all layers which need to be updated in the texture."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel. Overwritten and set to NearestFilter by default."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel. Overwritten and set to NearestFilter by default."
        },
        "mipmaps": {
          "!doc": "An array holding user-defined mipmaps."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "bool",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. Overwritten and set to 1 by default."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapR": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped in the depth and corresponds to *W* in UVW mapping."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addLayerUpdate": {
          "!type": "fn(layerIndex: number)",
          "!doc": "Describes that a specific layer of the texture needs to be updated. Normally when Texture is set to true, the entire data texture array is sent to the GPU. Marking specific layers will only transmit subsets of all mipmaps associated with a specific depth in the array which is often much more performant."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearLayerUpdates": {
          "!type": "fn()",
          "!doc": "Resets the layer updates registry."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new data array texture.",
      "!type": "fn(data: +TypedArray, width: number, height: number, depth: number)"
    },
    "DataTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/DataTexture",
      "prototype": {
        "!proto": "THREE.Texture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Overwritten and set to false by default."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Overwritten and set to false by default."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image definition of a data texture."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel."
        },
        "mipmaps": {
          "!doc": "An array holding user-defined mipmaps."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "bool",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. Overwritten and set to 1 by default."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new data texture.",
      "!type": "fn(data: +TypedArray, width: number, height: number, format: number, type: number, mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, anisotropy: number, colorSpace: string)"
    },
    "DataTextureLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/DataTextureLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback) -> +THREE.DataTexture",
          "!doc": "Starts loading from the given URL and passes the loaded data texture to the onLoad() callback. The method also returns a new texture object which can directly be used for material creation. If you do it this way, the texture may pop up in your scene once the respective loading process is finished."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(data: ?)",
          "!doc": "This method needs to be implemented by all concrete loaders. It holds the logic for parsing the asset into three.js entities."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new data texture loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "DataUtils": {
      "!url": "https://threejs.org/docs/#api/en/extras/DataUtils",
      "prototype": {
        "fromHalfFloat": {
          "!type": "fn(val: number) -> number",
          "!doc": "Returns a single precision floating point value (FP32) from the given half precision floating point value (FP16)."
        },
        "toHalfFloat": {
          "!type": "fn(val: number) -> number",
          "!doc": "Returns a half precision floating point value (FP16) from the given single precision floating point value (FP32)."
        }
      },
      "!type": "fn()"
    },
    "DepthTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/DepthTexture",
      "prototype": {
        "!proto": "THREE.Texture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "compareFunction": {
          "!type": "+THREE.NeverCompare",
          "!doc": "Code corresponding to the depth compare function."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Overwritten and set to false by default."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Overwritten and set to false by default."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image object holding the texture data."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel."
        },
        "mipmaps": {
          "!doc": "An array holding user-defined mipmaps."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries)."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new depth texture.",
      "!type": "fn(width: number, height: number, type: number, mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, anisotropy: number, format: number, depth: number)"
    },
    "DirectionalLight": {
      "!url": "https://threejs.org/docs/#api/en/lights/DirectionalLight",
      "prototype": {
        "!proto": "THREE.Light.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The light's color."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The light's intensity."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "shadow": {
          "!type": "+THREE.DirectionalLightShadow",
          "!doc": "This property holds the light's shadow configuration."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "target": {
          "!type": "+THREE.Object3D",
          "!doc": "The directional light points from its position to the target's position. For the target's position to be changed to anything other than the default, it must be added to the scene. It is also possible to set the target to be another 3D object in the scene. The light will now track the target object."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new directional light.",
      "!type": "fn(color: number, intensity: number)"
    },
    "DirectionalLightHelper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/DirectionalLightHelper",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "number",
          "!doc": "The color parameter passed in the constructor. If not set, the helper will take the color of the light."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "light": {
          "!type": "+THREE.DirectionalLight",
          "!doc": "The light being visualized."
        },
        "lightPlane": {
          "!type": "+THREE.Line",
          "!doc": "Contains the line showing the location of the directional light."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "targetLine": {
          "!type": "+THREE.Line",
          "!doc": "Represents the target line of the directional light."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "update": {
          "!type": "fn()",
          "!doc": "Updates the helper to match the position and direction of the light being visualized."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new directional light helper.",
      "!type": "fn(light: +THREE.DirectionalLight, size: number, color: number)"
    },
    "DirectionalLightShadow": {
      "!url": "https://threejs.org/docs/#api/en/lights/DirectionalLightShadow",
      "prototype": {
        "!proto": "THREE.LightShadow.prototype",
        "autoUpdate": {
          "!type": "bool",
          "!doc": "Enables automatic updates of the light's shadow. If you do not require dynamic lighting / shadows, you may set this to false."
        },
        "bias": {
          "!type": "number",
          "!doc": "Shadow map bias, how much to add or subtract from the normalized depth when deciding whether a surface is in shadow. The default is 0. Very tiny adjustments here (in the order of 0.0001) may help reduce artifacts in shadows."
        },
        "biasNode": {
          "!doc": "A node version of bias. Only supported with WebGPURenderer. If a bias node is defined, bias has no effect."
        },
        "blurSamples": {
          "!type": "number",
          "!doc": "The amount of samples to use when blurring a VSM shadow map."
        },
        "camera": {
          "!type": "+THREE.Camera",
          "!doc": "The light's view of the world."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The intensity of the shadow. The default is 1. Valid values are in the range [0, 1]."
        },
        "map": {
          "!type": "+THREE.RenderTarget",
          "!doc": "The depth map generated using the internal camera; a location beyond a pixel's depth is in shadow. Computed internally during rendering."
        },
        "mapPass": {
          "!type": "+THREE.RenderTarget",
          "!doc": "The distribution map generated using the internal camera; an occlusion is calculated based on the distribution of depths. Computed internally during rendering."
        },
        "mapSize": {
          "!type": "+THREE.Vector2",
          "!doc": "Defines the width and height of the shadow map. Higher values give better quality shadows at the cost of computation time. Values must be powers of two."
        },
        "mapType": {
          "!type": "number",
          "!doc": "The type of shadow texture. The default is UnsignedByteType."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Model to shadow camera space, to compute location and depth in shadow map. This is computed internally during rendering."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, shadow maps will be updated in the next render call. If you have set LightShadow to false, you will need to set this property to true and then make a render call to update the light's shadow."
        },
        "normalBias": {
          "!type": "number",
          "!doc": "Defines how much the position used to query the shadow map is offset along the object normal. The default is 0. Increasing this value can be used to reduce shadow acne especially in large scenes where light shines onto geometry at a shallow angle. The cost is that shadows may appear distorted."
        },
        "radius": {
          "!type": "number",
          "!doc": "Setting this to values greater than 1 will blur the edges of the shadow. High values will cause unwanted banding effects in the shadows - a greater map size will allow for a higher value to be used here before these effects become visible. The property has no effect when the shadow map type is BasicShadowMap."
        },
        "clone": {
          "!type": "fn() -> +THREE.LightShadow",
          "!doc": "Returns a new light shadow instance with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.LightShadow) -> +THREE.LightShadow",
          "!doc": "Copies the values of the given light shadow instance to this instance."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getFrameExtents": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "Returns the frame extends."
        },
        "getFrustum": {
          "!type": "fn() -> +THREE.Frustum",
          "!doc": "Gets the shadow cameras frustum. Used internally by the renderer to cull objects."
        },
        "getViewport": {
          "!type": "fn(viewportIndex: number) -> +THREE.Vector4",
          "!doc": "Returns a viewport definition for the given viewport index."
        },
        "getViewportCount": {
          "!type": "fn() -> number",
          "!doc": "Used internally by the renderer to get the number of viewports that need to be rendered for this shadow."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the light shadow into JSON."
        },
        "updateMatrices": {
          "!type": "fn(light: +THREE.Light)",
          "!doc": "Update the matrices for the camera and shadow, used internally by the renderer."
        }
      },
      "!doc": "Constructs a new directional light shadow.",
      "!type": "fn()"
    },
    "DiscreteInterpolant": {
      "!url": "https://threejs.org/docs/#api/en/math/DiscreteInterpolant",
      "prototype": {
        "!proto": "THREE.Interpolant.prototype",
        "DefaultSettings_": {
          "!type": "object",
          "!doc": "The default settings object."
        },
        "parameterPositions": {
          "!type": "+TypedArray",
          "!doc": "The parameter positions."
        },
        "resultBuffer": {
          "!type": "+TypedArray",
          "!doc": "The result buffer."
        },
        "sampleValues": {
          "!type": "+TypedArray",
          "!doc": "The sample values."
        },
        "settings": {
          "!type": "object",
          "!doc": "The interpolation settings."
        },
        "valueSize": {
          "!type": "+TypedArray",
          "!doc": "The value size."
        },
        "copySampleValue_": {
          "!type": "fn(index: number) -> +TypedArray",
          "!doc": "Copies a sample value to the result buffer."
        },
        "evaluate": {
          "!type": "fn(t: number) -> +TypedArray",
          "!doc": "Evaluate the interpolant at position t."
        },
        "getSettings_": {
          "!type": "fn() -> object",
          "!doc": "Returns the interpolation settings."
        },
        "interpolate_": {
          "!type": "fn(i1: number, t0: number, t: number, t1: number) -> +TypedArray",
          "!doc": "Copies a sample value to the result buffer."
        },
        "intervalChanged_": {
          "!type": "fn(i1: number, t0: number, t: number)",
          "!doc": "Optional method that is executed when the interval has changed."
        }
      },
      "!doc": "Constructs a new discrete interpolant.",
      "!type": "fn(parameterPositions: +TypedArray, sampleValues: +TypedArray, sampleSize: number, resultBuffer: +TypedArray)"
    },
    "DodecahedronGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/DodecahedronGeometry",
      "prototype": {
        "!proto": "THREE.PolyhedronGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.DodecahedronGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new dodecahedron geometry.",
      "!type": "fn(radius: number, detail: number)"
    },
    "Earcut": {
      "!url": "https://threejs.org/docs/#api/en/extras/Earcut",
      "prototype": {
        "triangulate": {
          "!type": "fn(data, holeIndices, dim: number)",
          "!doc": "Triangulates the given shape definition by returning an array of triangles."
        }
      },
      "!type": "fn()"
    },
    "EdgesGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/EdgesGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        }
      },
      "!doc": "Constructs a new edges geometry.",
      "!type": "fn(geometry: +THREE.BufferGeometry, thresholdAngle: number)"
    },
    "EllipseCurve": {
      "!url": "https://threejs.org/docs/#api/en/extras/EllipseCurve",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "aClockwise": {
          "!type": "bool",
          "!doc": "Whether the ellipse is drawn clockwise or not."
        },
        "aEndAngle": {
          "!type": "number",
          "!doc": "The end angle of the curve in radians starting from the positive X axis."
        },
        "aRotation": {
          "!type": "number",
          "!doc": "The rotation angle of the ellipse in radians, counterclockwise from the positive X axis."
        },
        "aStartAngle": {
          "!type": "number",
          "!doc": "The start angle of the curve in radians starting from the positive X axis."
        },
        "aX": {
          "!type": "number",
          "!doc": "The X center of the ellipse."
        },
        "aY": {
          "!type": "number",
          "!doc": "The Y center of the ellipse."
        },
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "xRadius": {
          "!type": "number",
          "!doc": "The radius of the ellipse in the x direction. Setting the this value equal to the EllipseCurve will result in a circle."
        },
        "yRadius": {
          "!type": "number",
          "!doc": "The radius of the ellipse in the y direction. Setting the this value equal to the EllipseCurve will result in a circle."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a point on the curve."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new ellipse curve.",
      "!type": "fn(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool, aRotation: number)"
    },
    "Euler": {
      "!url": "https://threejs.org/docs/#api/en/math/Euler",
      "prototype": {
        "order": {
          "!type": "string",
          "!doc": "A string representing the order that the rotations are applied."
        },
        "x": {
          "!type": "number",
          "!doc": "The angle of the x axis in radians."
        },
        "y": {
          "!type": "number",
          "!doc": "The angle of the y axis in radians."
        },
        "z": {
          "!type": "number",
          "!doc": "The angle of the z axis in radians."
        },
        "DEFAULT_ORDER": {
          "!type": "string",
          "!doc": "The default Euler angle order."
        },
        "clone": {
          "!type": "fn() -> +THREE.Euler",
          "!doc": "Returns a new Euler instance with copied values from this instance."
        },
        "copy": {
          "!type": "fn(euler: +THREE.Euler) -> +THREE.Euler",
          "!doc": "Copies the values of the given Euler instance to this instance."
        },
        "equals": {
          "!type": "fn(euler: +THREE.Euler) -> bool",
          "!doc": "Returns true if this Euler instance is equal with the given one."
        },
        "fromArray": {
          "!type": "fn(array) -> +THREE.Euler",
          "!doc": "Sets this Euler instance's components to values from the given array. The first three entries of the array are assign to the x,y and z components. An optional fourth entry defines the Euler order."
        },
        "reorder": {
          "!type": "fn(newOrder: string) -> +THREE.Euler",
          "!doc": "Resets the euler angle with a new order by creating a quaternion from this euler angle and then setting this euler angle with the quaternion and the new order. Warning: This discards revolution information."
        },
        "set": {
          "!type": "fn(x: number, y: number, z: number, order: string) -> +THREE.Euler",
          "!doc": "Sets the Euler components."
        },
        "setFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion, order: string, update: bool) -> +THREE.Euler",
          "!doc": "Sets the angles of this Euler instance from a normalized quaternion."
        },
        "setFromRotationMatrix": {
          "!type": "fn(m: +THREE.Matrix4, order: string, update: bool) -> +THREE.Euler",
          "!doc": "Sets the angles of this Euler instance from a pure rotation matrix."
        },
        "setFromVector3": {
          "!type": "fn(v: +THREE.Vector3, order: string) -> +THREE.Euler",
          "!doc": "Sets the angles of this Euler instance from the given vector."
        },
        "toArray": {
          "!type": "fn(array, offset: number)",
          "!doc": "Writes the components of this Euler instance to the given array. If no array is provided, the method returns a new instance."
        }
      },
      "!doc": "Constructs a new euler instance.",
      "!type": "fn(x: number, y: number, z: number, order: string)"
    },
    "EventDispatcher": {
      "!url": "https://threejs.org/docs/#api/en/core/EventDispatcher",
      "prototype": {
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        }
      },
      "!type": "fn()"
    },
    "ExternalTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/ExternalTexture",
      "prototype": {
        "!proto": "THREE.Texture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure the flip on bitmap creation instead."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Set this to false if you are creating mipmaps manually."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image object holding the texture data."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel."
        },
        "mipmaps": {
          "!doc": "An array holding user-defined mipmaps."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "sourceTexture": {
          "!type": "+THREE.WebGLTexture",
          "!doc": "The external source texture."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries)."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Creates a new raw texture.",
      "!type": "fn(sourceTexture: +THREE.WebGLTexture)"
    },
    "ExtrudeGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/ExtrudeGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object, shapes) -> +THREE.ExtrudeGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new extrude geometry.",
      "!type": "fn(shapes: +THREE.Shape, options)"
    },
    "FileLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/FileLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "mimeType": {
          "!type": "string",
          "!doc": "The expected mime type. Valid values can be found [here](https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#mimetype)"
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "responseType": {
          "!type": "+THREE.arraybuffer",
          "!doc": "The expected response type."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.FileLoader",
          "!doc": "Aborts ongoing fetch requests."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback) -> ?",
          "!doc": "Starts loading from the given URL and pass the loaded response to the onLoad() callback."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(data: ?)",
          "!doc": "This method needs to be implemented by all concrete loaders. It holds the logic for parsing the asset into three.js entities."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setMimeType": {
          "!type": "fn(value: string) -> +THREE.FileLoader",
          "!doc": "Sets the expected mime type of the loaded file."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setResponseType": {
          "!type": "fn(value: +THREE.arraybuffer) -> +THREE.FileLoader",
          "!doc": "Sets the expected response type."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new file loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "Float16BufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/Float16BufferAttribute",
      "prototype": {
        "!proto": "THREE.BufferAttribute.prototype",
        "array": {
          "!type": "+TypedArray",
          "!doc": "The array holding the attribute data. It should have itemSize * numVertices elements, where numVertices is the number of vertices in the associated geometry."
        },
        "count": {
          "!type": "number",
          "!doc": "Represents the number of items this buffer attribute stores. It is internally computed by dividing the array length by the itemSize."
        },
        "gpuType": {
          "!type": "+THREE.FloatType",
          "!doc": "Configures the bound GPU type for use in shaders. Note: this only has an effect for integer arrays and is not configurable for float arrays. For lower precision float types, use Float16BufferAttribute."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the buffer attribute."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The number of values of the array that should be associated with a particular vertex. For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then the value should be 3."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "bool",
          "!doc": "Applies to integer data only. Indicates how the underlying data in the buffer maps to the values in the GLSL code. For instance, if array is an instance of UInt16Array, and normalized is true, the values 0 - +65535 in the array data will be mapped to 0.0f - +1.0f in the GLSL attribute. If normalized is false, the values will be converted to floats unmodified, i.e. 65535 becomes 65535.0f."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 matrix to the given attribute. Works with item size 2 and 3."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 normal matrix to the given attribute. Only works with item size 3."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns a new buffer attribute with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferAttribute) -> +THREE.BufferAttribute",
          "!doc": "Copies the values of the given buffer attribute to this instance."
        },
        "copyArray": {
          "!type": "fn(array: +TypedArray) -> +THREE.BufferAttribute",
          "!doc": "Copies the given array data into this buffer attribute."
        },
        "copyAt": {
          "!type": "fn(index1: number, attribute: +THREE.BufferAttribute, index2: number) -> +THREE.BufferAttribute",
          "!doc": "Copies a vector from the given buffer attribute to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "getComponent": {
          "!type": "fn(index: number, component: number) -> number",
          "!doc": "Returns the given component of the vector at the given index."
        },
        "getW": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the w component of the vector at the given index."
        },
        "getX": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the x component of the vector at the given index."
        },
        "getY": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the y component of the vector at the given index."
        },
        "getZ": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the z component of the vector at the given index."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.BufferAttribute",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the attribute array data to the GPU. Can be used to perform clean-up operations after the upload when attribute data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given array data in the buffer attribute."
        },
        "setComponent": {
          "!type": "fn(index: number, component: number, value: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given value to the given component of the vector at the given index."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.BufferAttribute",
          "!doc": "Sets the usage of this buffer attribute."
        },
        "setW": {
          "!type": "fn(index: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the w component of the vector at the given index."
        },
        "setX": {
          "!type": "fn(index: number, x: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x component of the vector at the given index."
        },
        "setXY": {
          "!type": "fn(index: number, x: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x and y component of the vector at the given index."
        },
        "setXYZ": {
          "!type": "fn(index: number, x: number, y: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y and z component of the vector at the given index."
        },
        "setXYZW": {
          "!type": "fn(index: number, x: number, y: number, z: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y, z and w component of the vector at the given index."
        },
        "setY": {
          "!type": "fn(index: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the y component of the vector at the given index."
        },
        "setZ": {
          "!type": "fn(index: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the z component of the vector at the given index."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the buffer attribute into JSON."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3 and with direction vectors."
        }
      },
      "!doc": "Constructs a new buffer attribute.",
      "!type": "fn(array, itemSize: number, normalized: bool)"
    },
    "Float32BufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/Float32BufferAttribute",
      "prototype": {
        "!proto": "THREE.BufferAttribute.prototype",
        "array": {
          "!type": "+TypedArray",
          "!doc": "The array holding the attribute data. It should have itemSize * numVertices elements, where numVertices is the number of vertices in the associated geometry."
        },
        "count": {
          "!type": "number",
          "!doc": "Represents the number of items this buffer attribute stores. It is internally computed by dividing the array length by the itemSize."
        },
        "gpuType": {
          "!type": "+THREE.FloatType",
          "!doc": "Configures the bound GPU type for use in shaders. Note: this only has an effect for integer arrays and is not configurable for float arrays. For lower precision float types, use Float16BufferAttribute."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the buffer attribute."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The number of values of the array that should be associated with a particular vertex. For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then the value should be 3."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "bool",
          "!doc": "Applies to integer data only. Indicates how the underlying data in the buffer maps to the values in the GLSL code. For instance, if array is an instance of UInt16Array, and normalized is true, the values 0 - +65535 in the array data will be mapped to 0.0f - +1.0f in the GLSL attribute. If normalized is false, the values will be converted to floats unmodified, i.e. 65535 becomes 65535.0f."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 matrix to the given attribute. Works with item size 2 and 3."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 normal matrix to the given attribute. Only works with item size 3."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns a new buffer attribute with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferAttribute) -> +THREE.BufferAttribute",
          "!doc": "Copies the values of the given buffer attribute to this instance."
        },
        "copyArray": {
          "!type": "fn(array: +TypedArray) -> +THREE.BufferAttribute",
          "!doc": "Copies the given array data into this buffer attribute."
        },
        "copyAt": {
          "!type": "fn(index1: number, attribute: +THREE.BufferAttribute, index2: number) -> +THREE.BufferAttribute",
          "!doc": "Copies a vector from the given buffer attribute to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "getComponent": {
          "!type": "fn(index: number, component: number) -> number",
          "!doc": "Returns the given component of the vector at the given index."
        },
        "getW": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the w component of the vector at the given index."
        },
        "getX": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the x component of the vector at the given index."
        },
        "getY": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the y component of the vector at the given index."
        },
        "getZ": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the z component of the vector at the given index."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.BufferAttribute",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the attribute array data to the GPU. Can be used to perform clean-up operations after the upload when attribute data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given array data in the buffer attribute."
        },
        "setComponent": {
          "!type": "fn(index: number, component: number, value: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given value to the given component of the vector at the given index."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.BufferAttribute",
          "!doc": "Sets the usage of this buffer attribute."
        },
        "setW": {
          "!type": "fn(index: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the w component of the vector at the given index."
        },
        "setX": {
          "!type": "fn(index: number, x: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x component of the vector at the given index."
        },
        "setXY": {
          "!type": "fn(index: number, x: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x and y component of the vector at the given index."
        },
        "setXYZ": {
          "!type": "fn(index: number, x: number, y: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y and z component of the vector at the given index."
        },
        "setXYZW": {
          "!type": "fn(index: number, x: number, y: number, z: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y, z and w component of the vector at the given index."
        },
        "setY": {
          "!type": "fn(index: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the y component of the vector at the given index."
        },
        "setZ": {
          "!type": "fn(index: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the z component of the vector at the given index."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the buffer attribute into JSON."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3 and with direction vectors."
        }
      },
      "!doc": "Constructs a new buffer attribute.",
      "!type": "fn(array, itemSize: number, normalized: bool)"
    },
    "Fog": {
      "!url": "https://threejs.org/docs/#api/en/scenes/Fog",
      "prototype": {
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The fog's color."
        },
        "far": {
          "!type": "number",
          "!doc": "The maximum distance at which fog stops being calculated and applied. Objects that are more than far units away from the active camera won't be affected by fog."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the fog."
        },
        "near": {
          "!type": "number",
          "!doc": "The minimum distance to start applying fog. Objects that are less than near units from the active camera won't be affected by fog."
        },
        "clone": {
          "!type": "fn() -> +THREE.Fog",
          "!doc": "Returns a new fog with copied values from this instance."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the fog into JSON."
        }
      },
      "!doc": "Constructs a new fog.",
      "!type": "fn(color: number, near: number, far: number)"
    },
    "FogExp2": {
      "!url": "https://threejs.org/docs/#api/en/scenes/FogExp2",
      "prototype": {
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The fog's color."
        },
        "density": {
          "!type": "number",
          "!doc": "Defines how fast the fog will grow dense."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the fog."
        },
        "clone": {
          "!type": "fn() -> +THREE.FogExp2",
          "!doc": "Returns a new fog with copied values from this instance."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the fog into JSON."
        }
      },
      "!doc": "Constructs a new fog.",
      "!type": "fn(color: number, density: number)"
    },
    "FramebufferTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/FramebufferTexture",
      "prototype": {
        "!proto": "THREE.Texture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure the flip on bitmap creation instead."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Overwritten and set to false by default."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image object holding the texture data."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel. Overwritten and set to NearestFilter by default to disable filtering."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel. Overwritten and set to NearestFilter by default to disable filtering."
        },
        "mipmaps": {
          "!doc": "An array holding user-defined mipmaps."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries)."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new framebuffer texture.",
      "!type": "fn(width: number, height: number)"
    },
    "Frustum": {
      "!url": "https://threejs.org/docs/#api/en/math/Frustum",
      "prototype": {
        "planes": {
          "!doc": "This array holds the planes that enclose the frustum."
        },
        "clone": {
          "!type": "fn() -> +THREE.Frustum",
          "!doc": "Returns a new frustum with copied values from this instance."
        },
        "containsPoint": {
          "!type": "fn(point: +THREE.Vector3) -> bool",
          "!doc": "Returns true if the given point lies within the frustum."
        },
        "copy": {
          "!type": "fn(frustum: +THREE.Frustum) -> +THREE.Frustum",
          "!doc": "Copies the values of the given frustum to this instance."
        },
        "intersectsBox": {
          "!type": "fn(box: +THREE.Box3) -> bool",
          "!doc": "Returns true if the given bounding box is intersecting this frustum."
        },
        "intersectsObject": {
          "!type": "fn(object: +THREE.Object3D) -> bool",
          "!doc": "Returns true if the 3D object's bounding sphere is intersecting this frustum. Note that the 3D object must have a geometry so that the bounding sphere can be calculated."
        },
        "intersectsSphere": {
          "!type": "fn(sphere: +THREE.Sphere) -> bool",
          "!doc": "Returns true if the given bounding sphere is intersecting this frustum."
        },
        "intersectsSprite": {
          "!type": "fn(sprite: +THREE.Sprite) -> bool",
          "!doc": "Returns true if the given sprite is intersecting this frustum."
        },
        "set": {
          "!type": "fn(p0: +THREE.Plane, p1: +THREE.Plane, p2: +THREE.Plane, p3: +THREE.Plane, p4: +THREE.Plane, p5: +THREE.Plane) -> +THREE.Frustum",
          "!doc": "Sets the frustum planes by copying the given planes."
        },
        "setFromProjectionMatrix": {
          "!type": "fn(m: +THREE.Matrix4, coordinateSystem: +THREE.WebGLCoordinateSystem, reversedDepth: bool) -> +THREE.Frustum",
          "!doc": "Sets the frustum planes from the given projection matrix."
        }
      },
      "!doc": "Constructs a new frustum.",
      "!type": "fn(p0: +THREE.Plane, p1: +THREE.Plane, p2: +THREE.Plane, p3: +THREE.Plane, p4: +THREE.Plane, p5: +THREE.Plane)"
    },
    "FrustumArray": {
      "!url": "https://threejs.org/docs/#api/en/math/FrustumArray",
      "prototype": {
        "coordinateSystem": {
          "!type": "+THREE.WebGLCoordinateSystem",
          "!doc": "The coordinate system to use."
        },
        "clone": {
          "!type": "fn() -> +FrustumArray",
          "!doc": "Returns a new frustum array with copied values from this instance."
        },
        "containsPoint": {
          "!type": "fn(point: +THREE.Vector3, cameraArray: object) -> bool",
          "!doc": "Returns true if the given point lies within any frustum from the camera array."
        },
        "intersectsBox": {
          "!type": "fn(box: +THREE.Box3, cameraArray: object) -> bool",
          "!doc": "Returns true if the given bounding box is intersecting any frustum from the camera array."
        },
        "intersectsObject": {
          "!type": "fn(object: +THREE.Object3D, cameraArray: object) -> bool",
          "!doc": "Returns true if the 3D object's bounding sphere is intersecting any frustum from the camera array."
        },
        "intersectsSphere": {
          "!type": "fn(sphere: +THREE.Sphere, cameraArray: object) -> bool",
          "!doc": "Returns true if the given bounding sphere is intersecting any frustum from the camera array."
        },
        "intersectsSprite": {
          "!type": "fn(sprite: +THREE.Sprite, cameraArray: object) -> bool",
          "!doc": "Returns true if the given sprite is intersecting any frustum from the camera array."
        }
      },
      "!doc": "Constructs a new frustum array.",
      "!type": "fn()"
    },
    "GLBufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/GLBufferAttribute",
      "prototype": {
        "buffer": {
          "!type": "+THREE.WebGLBuffer",
          "!doc": "The native WebGL buffer."
        },
        "count": {
          "!type": "number",
          "!doc": "The expected number of vertices in VBO."
        },
        "elementSize": {
          "!type": "number",
          "!doc": "The corresponding size (in bytes) for the given type parameter."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The item size, see BufferAttribute."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "bool",
          "!doc": "Applies to integer data only. Indicates how the underlying data in the buffer maps to the values in the GLSL code. For instance, if buffer contains data of gl.UNSIGNED_SHORT, and normalized is true, the values 0 - +65535 in the buffer data will be mapped to 0.0f - +1.0f in the GLSL attribute. If normalized is false, the values will be converted to floats unmodified, i.e. 65535 becomes 65535.0f."
        },
        "type": {
          "!type": "number",
          "!doc": "The native data type."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "setBuffer": {
          "!type": "fn(buffer: +THREE.WebGLBuffer) -> +THREE.BufferAttribute",
          "!doc": "Sets the given native WebGL buffer."
        },
        "setCount": {
          "!type": "fn(count: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the count (the expected number of vertices in VBO)."
        },
        "setItemSize": {
          "!type": "fn(itemSize: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the item size."
        },
        "setType": {
          "!type": "fn(type: number, elementSize: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given native data type and element size."
        }
      },
      "!doc": "Constructs a new GL buffer attribute.",
      "!type": "fn(buffer: +THREE.WebGLBuffer, type: number, itemSize: number, elementSize: number, count: number, normalized: bool)"
    },
    "GridHelper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/GridHelper",
      "prototype": {
        "!proto": "THREE.LineSegments.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The line geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The line material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeLineDistances": {
          "!type": "fn() -> +THREE.Line",
          "!doc": "Computes an array of distance values which are necessary for rendering dashed lines. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Line and Line to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new grid helper.",
      "!type": "fn(size: number, divisions: number, color1: number, color2: number)"
    },
    "Group": {
      "!url": "https://threejs.org/docs/#api/en/objects/Group",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!type": "fn()"
    },
    "HemisphereLight": {
      "!url": "https://threejs.org/docs/#api/en/lights/HemisphereLight",
      "prototype": {
        "!proto": "THREE.Light.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The light's color."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "groundColor": {
          "!type": "+THREE.Color",
          "!doc": "The light's ground color."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The light's intensity."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new hemisphere light.",
      "!type": "fn(skyColor: number, groundColor: number, intensity: number)"
    },
    "HemisphereLightHelper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/HemisphereLightHelper",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "number",
          "!doc": "The color parameter passed in the constructor. If not set, the helper will take the color of the light."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "light": {
          "!type": "+THREE.HemisphereLight",
          "!doc": "The light being visualized."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "update": {
          "!type": "fn()",
          "!doc": "Updates the helper to match the position and direction of the light being visualized."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new hemisphere light helper.",
      "!type": "fn(light: +THREE.HemisphereLight, size: number, color: number)"
    },
    "IESSpotLight": {
      "!url": "https://threejs.org/docs/#api/en/lights/IESSpotLight",
      "prototype": {
        "!proto": "THREE.SpotLight.prototype",
        "angle": {
          "!type": "number",
          "!doc": "Maximum angle of light dispersion from its direction whose upper bound is Math.PI/2."
        },
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The light's color."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "decay": {
          "!type": "number",
          "!doc": "The amount the light dims along the distance of the light. In context of physically-correct rendering the default value should not be changed."
        },
        "distance": {
          "!type": "number",
          "!doc": "Maximum range of the light. 0 means no limit."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "iesMap": {
          "!type": "+THREE.Texture",
          "!doc": "The IES map. It's a lookup table that stores normalized attenuation factors (0.0 to 1.0) that represent the light's intensity at a specific angle."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The light's intensity."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "A texture used to modulate the color of the light. The spot light color is mixed with the RGB value of this texture, with a ratio corresponding to its alpha value. The cookie-like masking effect is reproduced using pixel values (0, 0, 0, 1-cookie_value). *Warning*: This property is disabled if Object3D is set to false."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "penumbra": {
          "!type": "number",
          "!doc": "Percent of the spotlight cone that is attenuated due to penumbra. Value range is [0,1]."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "power": {
          "!type": "number",
          "!doc": "The light's power. Power is the luminous power of the light measured in lumens (lm). Changing the power will also change the light's intensity."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "shadow": {
          "!type": "+THREE.SpotLightShadow",
          "!doc": "This property holds the light's shadow configuration."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "target": {
          "!type": "+THREE.Object3D",
          "!doc": "The spot light points from its position to the target's position. For the target's position to be changed to anything other than the default, it must be added to the scene. It is also possible to set the target to be another 3D object in the scene. The light will now track the target object."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new IES spot light.",
      "!type": "fn(color: number, intensity: number, distance: number, angle: number, penumbra: number, decay: number)"
    },
    "IcosahedronGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/IcosahedronGeometry",
      "prototype": {
        "!proto": "THREE.PolyhedronGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.IcosahedronGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new icosahedron geometry.",
      "!type": "fn(radius: number, detail: number)"
    },
    "ImageBitmapLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/ImageBitmapLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "options": {
          "!type": "object",
          "!doc": "Represents the loader options."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.ImageBitmapLoader",
          "!doc": "Aborts ongoing fetch requests."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback) -> +THREE.ImageBitmap",
          "!doc": "Starts loading from the given URL and pass the loaded image bitmap to the onLoad() callback."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(data: ?)",
          "!doc": "This method needs to be implemented by all concrete loaders. It holds the logic for parsing the asset into three.js entities."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setOptions": {
          "!type": "fn(options: object) -> +THREE.ImageBitmapLoader",
          "!doc": "Sets the given loader options. The structure of the object must match the options parameter of [createImageBitmap](https://developer.mozilla.org/en-US/docs/Web/API/Window/createImageBitmap)."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new image bitmap loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "ImageLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/ImageLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback) -> +THREE.Image",
          "!doc": "Starts loading from the given URL and passes the loaded image to the onLoad() callback. The method also returns a new Image object which can directly be used for texture creation. If you do it this way, the texture may pop up in your scene once the respective loading process is finished."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(data: ?)",
          "!doc": "This method needs to be implemented by all concrete loaders. It holds the logic for parsing the asset into three.js entities."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new image loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "ImageUtils": {
      "!url": "https://threejs.org/docs/#api/en/extras/ImageUtils",
      "prototype": {
        "getDataURL": {
          "!type": "fn(image: +THREE.HTMLImageElement, type: string) -> string",
          "!doc": "Returns a data URI containing a representation of the given image."
        },
        "sRGBToLinear": {
          "!type": "fn(image: +THREE.HTMLImageElement) -> +THREE.HTMLCanvasElement",
          "!doc": "Converts the given sRGB image data to linear color space."
        }
      },
      "!type": "fn()"
    },
    "InstancedBufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/InstancedBufferAttribute",
      "prototype": {
        "!proto": "THREE.BufferAttribute.prototype",
        "array": {
          "!type": "+TypedArray",
          "!doc": "The array holding the attribute data. It should have itemSize * numVertices elements, where numVertices is the number of vertices in the associated geometry."
        },
        "count": {
          "!type": "number",
          "!doc": "Represents the number of items this buffer attribute stores. It is internally computed by dividing the array length by the itemSize."
        },
        "gpuType": {
          "!type": "+THREE.FloatType",
          "!doc": "Configures the bound GPU type for use in shaders. Note: this only has an effect for integer arrays and is not configurable for float arrays. For lower precision float types, use Float16BufferAttribute."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the buffer attribute."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The number of values of the array that should be associated with a particular vertex. For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then the value should be 3."
        },
        "meshPerAttribute": {
          "!type": "number",
          "!doc": "Defines how often a value of this buffer attribute should be repeated. A value of one means that each value of the instanced attribute is used for a single instance. A value of two means that each value is used for two consecutive instances (and so on)."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "bool",
          "!doc": "Applies to integer data only. Indicates how the underlying data in the buffer maps to the values in the GLSL code. For instance, if array is an instance of UInt16Array, and normalized is true, the values 0 - +65535 in the array data will be mapped to 0.0f - +1.0f in the GLSL attribute. If normalized is false, the values will be converted to floats unmodified, i.e. 65535 becomes 65535.0f."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 matrix to the given attribute. Works with item size 2 and 3."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 normal matrix to the given attribute. Only works with item size 3."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns a new buffer attribute with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferAttribute) -> +THREE.BufferAttribute",
          "!doc": "Copies the values of the given buffer attribute to this instance."
        },
        "copyArray": {
          "!type": "fn(array: +TypedArray) -> +THREE.BufferAttribute",
          "!doc": "Copies the given array data into this buffer attribute."
        },
        "copyAt": {
          "!type": "fn(index1: number, attribute: +THREE.BufferAttribute, index2: number) -> +THREE.BufferAttribute",
          "!doc": "Copies a vector from the given buffer attribute to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "getComponent": {
          "!type": "fn(index: number, component: number) -> number",
          "!doc": "Returns the given component of the vector at the given index."
        },
        "getW": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the w component of the vector at the given index."
        },
        "getX": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the x component of the vector at the given index."
        },
        "getY": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the y component of the vector at the given index."
        },
        "getZ": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the z component of the vector at the given index."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.BufferAttribute",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the attribute array data to the GPU. Can be used to perform clean-up operations after the upload when attribute data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given array data in the buffer attribute."
        },
        "setComponent": {
          "!type": "fn(index: number, component: number, value: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given value to the given component of the vector at the given index."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.BufferAttribute",
          "!doc": "Sets the usage of this buffer attribute."
        },
        "setW": {
          "!type": "fn(index: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the w component of the vector at the given index."
        },
        "setX": {
          "!type": "fn(index: number, x: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x component of the vector at the given index."
        },
        "setXY": {
          "!type": "fn(index: number, x: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x and y component of the vector at the given index."
        },
        "setXYZ": {
          "!type": "fn(index: number, x: number, y: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y and z component of the vector at the given index."
        },
        "setXYZW": {
          "!type": "fn(index: number, x: number, y: number, z: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y, z and w component of the vector at the given index."
        },
        "setY": {
          "!type": "fn(index: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the y component of the vector at the given index."
        },
        "setZ": {
          "!type": "fn(index: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the z component of the vector at the given index."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the buffer attribute into JSON."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3 and with direction vectors."
        }
      },
      "!doc": "Constructs a new instanced buffer attribute.",
      "!type": "fn(array: +TypedArray, itemSize: number, normalized: bool, meshPerAttribute: number)"
    },
    "InstancedBufferGeometry": {
      "!url": "https://threejs.org/docs/#api/en/core/InstancedBufferGeometry",
      "prototype": {
        "instanceCount": {
          "!type": "number",
          "!doc": "The instance count."
        }
      },
      "!doc": "Constructs a new instanced buffer geometry.",
      "!type": "fn()"
    },
    "InstancedInterleavedBuffer": {
      "!url": "https://threejs.org/docs/#api/en/core/InstancedInterleavedBuffer",
      "prototype": {
        "!proto": "THREE.InterleavedBuffer.prototype",
        "array": {
          "!type": "+TypedArray",
          "!doc": "A typed array with a shared buffer storing attribute data."
        },
        "count": {
          "!type": "number",
          "!doc": "The total number of elements in the array"
        },
        "meshPerAttribute": {
          "!type": "number",
          "!doc": "Defines how often a value of this buffer attribute should be repeated, see InstancedBufferAttribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "stride": {
          "!type": "number",
          "!doc": "The number of typed-array elements per vertex."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the interleaved buffer."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn(data: object) -> +THREE.InterleavedBuffer",
          "!doc": "Returns a new interleaved buffer with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.InterleavedBuffer) -> +THREE.InterleavedBuffer",
          "!doc": "Copies the values of the given interleaved buffer to this instance."
        },
        "copyAt": {
          "!type": "fn(index1: number, interleavedBuffer: +THREE.InterleavedBuffer, index2: number) -> +THREE.InterleavedBuffer",
          "!doc": "Copies a vector from the given interleaved buffer to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.InterleavedBuffer",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the array data to the GPU. Can be used to perform clean-up operations after the upload when data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.InterleavedBuffer",
          "!doc": "Sets the given array data in the interleaved buffer."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.InterleavedBuffer",
          "!doc": "Sets the usage of this interleaved buffer."
        },
        "toJSON": {
          "!type": "fn(data: object) -> object",
          "!doc": "Serializes the interleaved buffer into JSON."
        }
      },
      "!doc": "Constructs a new instanced interleaved buffer.",
      "!type": "fn(array: +TypedArray, stride: number, meshPerAttribute: number)"
    },
    "InstancedMesh": {
      "!url": "https://threejs.org/docs/#api/en/objects/InstancedMesh",
      "prototype": {
        "!proto": "THREE.Mesh.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "The bounding box of the instanced mesh. Can be computed via InstancedMesh."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "The bounding sphere of the instanced mesh. Can be computed via InstancedMesh."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "count": {
          "!type": "number",
          "!doc": "The number of instances."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The mesh geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "instanceColor": {
          "!type": "+THREE.InstancedBufferAttribute",
          "!doc": "Represents the color of all instances. You have to set its BufferAttribute flag to true if you modify instanced data via InstancedMesh."
        },
        "instanceMatrix": {
          "!type": "+THREE.InstancedBufferAttribute",
          "!doc": "Represents the local transformation of all instances. You have to set its BufferAttribute flag to true if you modify instanced data via InstancedMesh."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The mesh material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTexture": {
          "!type": "+THREE.DataTexture",
          "!doc": "Represents the morph target weights of all instances. You have to set its Texture flag to true if you modify instanced data via InstancedMesh."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "previousInstanceMatrix": {
          "!type": "+THREE.InstancedBufferAttribute",
          "!doc": "Represents the local transformation of all instances of the previous frame. Required for computing velocity. Maintained in InstanceNode."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the instanced mesh, and updates InstancedMesh. The bounding box is not automatically computed by the engine; this method must be called by your app. You may need to recompute the bounding box if an instance is transformed via InstancedMesh."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the instanced mesh, and updates InstancedMesh The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if an instance is transformed via InstancedMesh."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getColorAt": {
          "!type": "fn(index: number, color: +THREE.Color)",
          "!doc": "Gets the color of the defined instance."
        },
        "getMatrixAt": {
          "!type": "fn(index: number, matrix: +THREE.Matrix4)",
          "!doc": "Gets the local transformation matrix of the defined instance."
        },
        "getMorphAt": {
          "!type": "fn(index: number, object: +THREE.Mesh)",
          "!doc": "Gets the morph target weights of the defined instance."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getVertexPosition": {
          "!type": "fn(index: number, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the local-space position of the vertex at the given index, taking into account the current animation state of both morph targets and skinning."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setColorAt": {
          "!type": "fn(index: number, color: +THREE.Color)",
          "!doc": "Sets the given color to the defined instance. Make sure you set the needsUpdate flag of InstancedMesh to true after updating all the colors."
        },
        "setMatrixAt": {
          "!type": "fn(index: number, matrix: +THREE.Matrix4)",
          "!doc": "Sets the given local transformation matrix to the defined instance. Make sure you set the needsUpdate flag of InstancedMesh to true after updating all the colors."
        },
        "setMorphAt": {
          "!type": "fn(index: number, object: +THREE.Mesh)",
          "!doc": "Sets the morph target weights to the defined instance. Make sure you set the needsUpdate flag of InstancedMesh to true after updating all the influences."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Mesh and Mesh to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new instanced mesh.",
      "!type": "fn(geometry: +THREE.BufferGeometry, material: +THREE.Material, count: number)"
    },
    "Int16BufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/Int16BufferAttribute",
      "prototype": {
        "!proto": "THREE.BufferAttribute.prototype",
        "array": {
          "!type": "+TypedArray",
          "!doc": "The array holding the attribute data. It should have itemSize * numVertices elements, where numVertices is the number of vertices in the associated geometry."
        },
        "count": {
          "!type": "number",
          "!doc": "Represents the number of items this buffer attribute stores. It is internally computed by dividing the array length by the itemSize."
        },
        "gpuType": {
          "!type": "+THREE.FloatType",
          "!doc": "Configures the bound GPU type for use in shaders. Note: this only has an effect for integer arrays and is not configurable for float arrays. For lower precision float types, use Float16BufferAttribute."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the buffer attribute."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The number of values of the array that should be associated with a particular vertex. For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then the value should be 3."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "bool",
          "!doc": "Applies to integer data only. Indicates how the underlying data in the buffer maps to the values in the GLSL code. For instance, if array is an instance of UInt16Array, and normalized is true, the values 0 - +65535 in the array data will be mapped to 0.0f - +1.0f in the GLSL attribute. If normalized is false, the values will be converted to floats unmodified, i.e. 65535 becomes 65535.0f."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 matrix to the given attribute. Works with item size 2 and 3."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 normal matrix to the given attribute. Only works with item size 3."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns a new buffer attribute with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferAttribute) -> +THREE.BufferAttribute",
          "!doc": "Copies the values of the given buffer attribute to this instance."
        },
        "copyArray": {
          "!type": "fn(array: +TypedArray) -> +THREE.BufferAttribute",
          "!doc": "Copies the given array data into this buffer attribute."
        },
        "copyAt": {
          "!type": "fn(index1: number, attribute: +THREE.BufferAttribute, index2: number) -> +THREE.BufferAttribute",
          "!doc": "Copies a vector from the given buffer attribute to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "getComponent": {
          "!type": "fn(index: number, component: number) -> number",
          "!doc": "Returns the given component of the vector at the given index."
        },
        "getW": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the w component of the vector at the given index."
        },
        "getX": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the x component of the vector at the given index."
        },
        "getY": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the y component of the vector at the given index."
        },
        "getZ": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the z component of the vector at the given index."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.BufferAttribute",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the attribute array data to the GPU. Can be used to perform clean-up operations after the upload when attribute data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given array data in the buffer attribute."
        },
        "setComponent": {
          "!type": "fn(index: number, component: number, value: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given value to the given component of the vector at the given index."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.BufferAttribute",
          "!doc": "Sets the usage of this buffer attribute."
        },
        "setW": {
          "!type": "fn(index: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the w component of the vector at the given index."
        },
        "setX": {
          "!type": "fn(index: number, x: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x component of the vector at the given index."
        },
        "setXY": {
          "!type": "fn(index: number, x: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x and y component of the vector at the given index."
        },
        "setXYZ": {
          "!type": "fn(index: number, x: number, y: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y and z component of the vector at the given index."
        },
        "setXYZW": {
          "!type": "fn(index: number, x: number, y: number, z: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y, z and w component of the vector at the given index."
        },
        "setY": {
          "!type": "fn(index: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the y component of the vector at the given index."
        },
        "setZ": {
          "!type": "fn(index: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the z component of the vector at the given index."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the buffer attribute into JSON."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3 and with direction vectors."
        }
      },
      "!doc": "Constructs a new buffer attribute.",
      "!type": "fn(array, itemSize: number, normalized: bool)"
    },
    "Int32BufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/Int32BufferAttribute",
      "prototype": {
        "!proto": "THREE.BufferAttribute.prototype",
        "array": {
          "!type": "+TypedArray",
          "!doc": "The array holding the attribute data. It should have itemSize * numVertices elements, where numVertices is the number of vertices in the associated geometry."
        },
        "count": {
          "!type": "number",
          "!doc": "Represents the number of items this buffer attribute stores. It is internally computed by dividing the array length by the itemSize."
        },
        "gpuType": {
          "!type": "+THREE.FloatType",
          "!doc": "Configures the bound GPU type for use in shaders. Note: this only has an effect for integer arrays and is not configurable for float arrays. For lower precision float types, use Float16BufferAttribute."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the buffer attribute."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The number of values of the array that should be associated with a particular vertex. For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then the value should be 3."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "bool",
          "!doc": "Applies to integer data only. Indicates how the underlying data in the buffer maps to the values in the GLSL code. For instance, if array is an instance of UInt16Array, and normalized is true, the values 0 - +65535 in the array data will be mapped to 0.0f - +1.0f in the GLSL attribute. If normalized is false, the values will be converted to floats unmodified, i.e. 65535 becomes 65535.0f."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 matrix to the given attribute. Works with item size 2 and 3."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 normal matrix to the given attribute. Only works with item size 3."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns a new buffer attribute with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferAttribute) -> +THREE.BufferAttribute",
          "!doc": "Copies the values of the given buffer attribute to this instance."
        },
        "copyArray": {
          "!type": "fn(array: +TypedArray) -> +THREE.BufferAttribute",
          "!doc": "Copies the given array data into this buffer attribute."
        },
        "copyAt": {
          "!type": "fn(index1: number, attribute: +THREE.BufferAttribute, index2: number) -> +THREE.BufferAttribute",
          "!doc": "Copies a vector from the given buffer attribute to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "getComponent": {
          "!type": "fn(index: number, component: number) -> number",
          "!doc": "Returns the given component of the vector at the given index."
        },
        "getW": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the w component of the vector at the given index."
        },
        "getX": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the x component of the vector at the given index."
        },
        "getY": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the y component of the vector at the given index."
        },
        "getZ": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the z component of the vector at the given index."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.BufferAttribute",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the attribute array data to the GPU. Can be used to perform clean-up operations after the upload when attribute data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given array data in the buffer attribute."
        },
        "setComponent": {
          "!type": "fn(index: number, component: number, value: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given value to the given component of the vector at the given index."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.BufferAttribute",
          "!doc": "Sets the usage of this buffer attribute."
        },
        "setW": {
          "!type": "fn(index: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the w component of the vector at the given index."
        },
        "setX": {
          "!type": "fn(index: number, x: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x component of the vector at the given index."
        },
        "setXY": {
          "!type": "fn(index: number, x: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x and y component of the vector at the given index."
        },
        "setXYZ": {
          "!type": "fn(index: number, x: number, y: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y and z component of the vector at the given index."
        },
        "setXYZW": {
          "!type": "fn(index: number, x: number, y: number, z: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y, z and w component of the vector at the given index."
        },
        "setY": {
          "!type": "fn(index: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the y component of the vector at the given index."
        },
        "setZ": {
          "!type": "fn(index: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the z component of the vector at the given index."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the buffer attribute into JSON."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3 and with direction vectors."
        }
      },
      "!doc": "Constructs a new buffer attribute.",
      "!type": "fn(array, itemSize: number, normalized: bool)"
    },
    "Int8BufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/Int8BufferAttribute",
      "prototype": {
        "!proto": "THREE.BufferAttribute.prototype",
        "array": {
          "!type": "+TypedArray",
          "!doc": "The array holding the attribute data. It should have itemSize * numVertices elements, where numVertices is the number of vertices in the associated geometry."
        },
        "count": {
          "!type": "number",
          "!doc": "Represents the number of items this buffer attribute stores. It is internally computed by dividing the array length by the itemSize."
        },
        "gpuType": {
          "!type": "+THREE.FloatType",
          "!doc": "Configures the bound GPU type for use in shaders. Note: this only has an effect for integer arrays and is not configurable for float arrays. For lower precision float types, use Float16BufferAttribute."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the buffer attribute."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The number of values of the array that should be associated with a particular vertex. For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then the value should be 3."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "bool",
          "!doc": "Applies to integer data only. Indicates how the underlying data in the buffer maps to the values in the GLSL code. For instance, if array is an instance of UInt16Array, and normalized is true, the values 0 - +65535 in the array data will be mapped to 0.0f - +1.0f in the GLSL attribute. If normalized is false, the values will be converted to floats unmodified, i.e. 65535 becomes 65535.0f."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 matrix to the given attribute. Works with item size 2 and 3."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 normal matrix to the given attribute. Only works with item size 3."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns a new buffer attribute with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferAttribute) -> +THREE.BufferAttribute",
          "!doc": "Copies the values of the given buffer attribute to this instance."
        },
        "copyArray": {
          "!type": "fn(array: +TypedArray) -> +THREE.BufferAttribute",
          "!doc": "Copies the given array data into this buffer attribute."
        },
        "copyAt": {
          "!type": "fn(index1: number, attribute: +THREE.BufferAttribute, index2: number) -> +THREE.BufferAttribute",
          "!doc": "Copies a vector from the given buffer attribute to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "getComponent": {
          "!type": "fn(index: number, component: number) -> number",
          "!doc": "Returns the given component of the vector at the given index."
        },
        "getW": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the w component of the vector at the given index."
        },
        "getX": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the x component of the vector at the given index."
        },
        "getY": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the y component of the vector at the given index."
        },
        "getZ": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the z component of the vector at the given index."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.BufferAttribute",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the attribute array data to the GPU. Can be used to perform clean-up operations after the upload when attribute data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given array data in the buffer attribute."
        },
        "setComponent": {
          "!type": "fn(index: number, component: number, value: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given value to the given component of the vector at the given index."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.BufferAttribute",
          "!doc": "Sets the usage of this buffer attribute."
        },
        "setW": {
          "!type": "fn(index: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the w component of the vector at the given index."
        },
        "setX": {
          "!type": "fn(index: number, x: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x component of the vector at the given index."
        },
        "setXY": {
          "!type": "fn(index: number, x: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x and y component of the vector at the given index."
        },
        "setXYZ": {
          "!type": "fn(index: number, x: number, y: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y and z component of the vector at the given index."
        },
        "setXYZW": {
          "!type": "fn(index: number, x: number, y: number, z: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y, z and w component of the vector at the given index."
        },
        "setY": {
          "!type": "fn(index: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the y component of the vector at the given index."
        },
        "setZ": {
          "!type": "fn(index: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the z component of the vector at the given index."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the buffer attribute into JSON."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3 and with direction vectors."
        }
      },
      "!doc": "Constructs a new buffer attribute.",
      "!type": "fn(array, itemSize: number, normalized: bool)"
    },
    "InterleavedBuffer": {
      "!url": "https://threejs.org/docs/#api/en/core/InterleavedBuffer",
      "prototype": {
        "array": {
          "!type": "+TypedArray",
          "!doc": "A typed array with a shared buffer storing attribute data."
        },
        "count": {
          "!type": "number",
          "!doc": "The total number of elements in the array"
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "stride": {
          "!type": "number",
          "!doc": "The number of typed-array elements per vertex."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the interleaved buffer."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn(data: object) -> +THREE.InterleavedBuffer",
          "!doc": "Returns a new interleaved buffer with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.InterleavedBuffer) -> +THREE.InterleavedBuffer",
          "!doc": "Copies the values of the given interleaved buffer to this instance."
        },
        "copyAt": {
          "!type": "fn(index1: number, interleavedBuffer: +THREE.InterleavedBuffer, index2: number) -> +THREE.InterleavedBuffer",
          "!doc": "Copies a vector from the given interleaved buffer to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.InterleavedBuffer",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the array data to the GPU. Can be used to perform clean-up operations after the upload when data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.InterleavedBuffer",
          "!doc": "Sets the given array data in the interleaved buffer."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.InterleavedBuffer",
          "!doc": "Sets the usage of this interleaved buffer."
        },
        "toJSON": {
          "!type": "fn(data: object) -> object",
          "!doc": "Serializes the interleaved buffer into JSON."
        }
      },
      "!doc": "Constructs a new interleaved buffer.",
      "!type": "fn(array: +TypedArray, stride: number)"
    },
    "InterleavedBufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/InterleavedBufferAttribute",
      "prototype": {
        "array": {
          "!type": "+TypedArray",
          "!doc": "The array holding the interleaved buffer attribute data."
        },
        "count": {
          "!type": "number",
          "!doc": "The item count of this buffer attribute."
        },
        "data": {
          "!type": "+THREE.InterleavedBuffer",
          "!doc": "The buffer holding the interleaved data."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The item size, see BufferAttribute."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "+THREE.InterleavedBuffer",
          "!doc": "Whether the data are normalized or not, see BufferAttribute"
        },
        "offset": {
          "!type": "number",
          "!doc": "The attribute offset into the buffer."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.InterleavedBufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.InterleavedBufferAttribute",
          "!doc": "Applies the given 3x3 normal matrix to the given attribute. Only works with item size 3."
        },
        "clone": {
          "!type": "fn(data: object) -> +THREE.BufferAttribute",
          "!doc": "Returns a new buffer attribute with copied values from this instance. If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data."
        },
        "getComponent": {
          "!type": "fn(index: number, component: number) -> number",
          "!doc": "Returns the given component of the vector at the given index."
        },
        "getW": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the w component of the vector at the given index."
        },
        "getX": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the x component of the vector at the given index."
        },
        "getY": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the y component of the vector at the given index."
        },
        "getZ": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the z component of the vector at the given index."
        },
        "setComponent": {
          "!type": "fn(index: number, component: number, value: number) -> +THREE.InterleavedBufferAttribute",
          "!doc": "Sets the given value to the given component of the vector at the given index."
        },
        "setW": {
          "!type": "fn(index: number, w: number) -> +THREE.InterleavedBufferAttribute",
          "!doc": "Sets the w component of the vector at the given index."
        },
        "setX": {
          "!type": "fn(index: number, x: number) -> +THREE.InterleavedBufferAttribute",
          "!doc": "Sets the x component of the vector at the given index."
        },
        "setXY": {
          "!type": "fn(index: number, x: number, y: number) -> +THREE.InterleavedBufferAttribute",
          "!doc": "Sets the x and y component of the vector at the given index."
        },
        "setXYZ": {
          "!type": "fn(index: number, x: number, y: number, z: number) -> +THREE.InterleavedBufferAttribute",
          "!doc": "Sets the x, y and z component of the vector at the given index."
        },
        "setXYZW": {
          "!type": "fn(index: number, x: number, y: number, z: number, w: number) -> +THREE.InterleavedBufferAttribute",
          "!doc": "Sets the x, y, z and w component of the vector at the given index."
        },
        "setY": {
          "!type": "fn(index: number, y: number) -> +THREE.InterleavedBufferAttribute",
          "!doc": "Sets the y component of the vector at the given index."
        },
        "setZ": {
          "!type": "fn(index: number, z: number) -> +THREE.InterleavedBufferAttribute",
          "!doc": "Sets the z component of the vector at the given index."
        },
        "toJSON": {
          "!type": "fn(data: object) -> object",
          "!doc": "Serializes the buffer attribute into JSON. If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.InterleavedBufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3 and with direction vectors."
        }
      },
      "!doc": "Constructs a new interleaved buffer attribute.",
      "!type": "fn(interleavedBuffer: +THREE.InterleavedBuffer, itemSize: number, offset: number, normalized: bool)"
    },
    "Interpolant": {
      "!url": "https://threejs.org/docs/#api/en/math/Interpolant",
      "prototype": {
        "DefaultSettings_": {
          "!type": "object",
          "!doc": "The default settings object."
        },
        "parameterPositions": {
          "!type": "+TypedArray",
          "!doc": "The parameter positions."
        },
        "resultBuffer": {
          "!type": "+TypedArray",
          "!doc": "The result buffer."
        },
        "sampleValues": {
          "!type": "+TypedArray",
          "!doc": "The sample values."
        },
        "settings": {
          "!type": "object",
          "!doc": "The interpolation settings."
        },
        "valueSize": {
          "!type": "+TypedArray",
          "!doc": "The value size."
        },
        "copySampleValue_": {
          "!type": "fn(index: number) -> +TypedArray",
          "!doc": "Copies a sample value to the result buffer."
        },
        "evaluate": {
          "!type": "fn(t: number) -> +TypedArray",
          "!doc": "Evaluate the interpolant at position t."
        },
        "getSettings_": {
          "!type": "fn() -> object",
          "!doc": "Returns the interpolation settings."
        },
        "interpolate_": {
          "!type": "fn(i1: number, t0: number, t: number, t1: number) -> +TypedArray",
          "!doc": "Copies a sample value to the result buffer."
        },
        "intervalChanged_": {
          "!type": "fn(i1: number, t0: number, t: number)",
          "!doc": "Optional method that is executed when the interval has changed."
        }
      },
      "!doc": "Constructs a new interpolant.",
      "!type": "fn(parameterPositions: +TypedArray, sampleValues: +TypedArray, sampleSize: number, resultBuffer: +TypedArray)"
    },
    "KeyframeTrack": {
      "!url": "https://threejs.org/docs/#api/en/animation/KeyframeTrack",
      "prototype": {
        "DefaultInterpolation": {
          "!type": "+THREE.InterpolateLinear",
          "!doc": "The default interpolation type of this keyframe track."
        },
        "TimeBufferType": {
          "!type": "+TypedArray",
          "!doc": "The time buffer type of this keyframe track."
        },
        "ValueBufferType": {
          "!type": "+TypedArray",
          "!doc": "The value buffer type of this keyframe track."
        },
        "ValueTypeName": {
          "!type": "string",
          "!doc": "The value type name."
        },
        "name": {
          "!type": "string",
          "!doc": "The track's name can refer to morph targets or bones or possibly other values within an animated object. See PropertyBinding for the forms of strings that can be parsed for property binding."
        },
        "times": {
          "!type": "+Float32Array",
          "!doc": "The keyframe times."
        },
        "values": {
          "!type": "+Float32Array",
          "!doc": "The keyframe values."
        },
        "InterpolantFactoryMethodBezier": {
          "!type": "fn(result: +TypedArray) -> +THREE.BezierInterpolant",
          "!doc": "Factory method for creating a new Bezier interpolant. The Bezier interpolant requires tangent data to be set via the settings property on the track before creating the interpolant. The settings should contain: - inTangents: Float32Array with [time, value] pairs per keyframe per component - outTangents: Float32Array with [time, value] pairs per keyframe per component"
        },
        "InterpolantFactoryMethodDiscrete": {
          "!type": "fn(result: +TypedArray) -> +THREE.DiscreteInterpolant",
          "!doc": "Factory method for creating a new discrete interpolant."
        },
        "InterpolantFactoryMethodLinear": {
          "!type": "fn(result: +TypedArray) -> +THREE.LinearInterpolant",
          "!doc": "Factory method for creating a new linear interpolant."
        },
        "InterpolantFactoryMethodSmooth": {
          "!type": "fn(result: +TypedArray) -> +THREE.CubicInterpolant",
          "!doc": "Factory method for creating a new smooth interpolant."
        },
        "clone": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Returns a new keyframe track with copied values from this instance."
        },
        "getInterpolation": {
          "!type": "fn() -> +THREE.InterpolateLinear",
          "!doc": "Returns the current interpolation type."
        },
        "getValueSize": {
          "!type": "fn() -> number",
          "!doc": "Returns the value size."
        },
        "optimize": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Optimizes this keyframe track by removing equivalent sequential keys (which are common in morph target sequences)."
        },
        "scale": {
          "!type": "fn(timeScale: number) -> +THREE.KeyframeTrack",
          "!doc": "Scale all keyframe times by a factor (useful for frame - seconds conversions)."
        },
        "setInterpolation": {
          "!type": "fn(interpolation: +THREE.InterpolateLinear) -> +THREE.KeyframeTrack",
          "!doc": "Defines the interpolation factor method for this keyframe track."
        },
        "shift": {
          "!type": "fn(timeOffset: number) -> +THREE.KeyframeTrack",
          "!doc": "Moves all keyframes either forward or backward in time."
        },
        "trim": {
          "!type": "fn(startTime: number, endTime: number) -> +THREE.KeyframeTrack",
          "!doc": "Removes keyframes before and after animation without changing any values within the defined time range. Note: The method does not shift around keys to the start of the track time, because for interpolated keys this will change their values"
        },
        "validate": {
          "!type": "fn() -> bool",
          "!doc": "Performs minimal validation on the keyframe track. Returns true if the values are valid."
        },
        "toJSON": {
          "!type": "fn(track: +THREE.KeyframeTrack) -> object",
          "!doc": "Converts the keyframe track to JSON."
        }
      },
      "!doc": "Constructs a new keyframe track.",
      "!type": "fn(name: string, times, values, interpolation: +THREE.InterpolateLinear)"
    },
    "LOD": {
      "!url": "https://threejs.org/docs/#api/en/objects/LOD",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "autoUpdate": {
          "!type": "bool",
          "!doc": "Whether the LOD object is updated automatically by the renderer per frame or not. If set to false, you have to call LOD in the render loop by yourself."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "levels": {
          "!doc": "This array holds the LOD levels."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addLevel": {
          "!type": "fn(object: +THREE.Object3D, distance: number, hysteresis: number) -> +THREE.LOD",
          "!doc": "Adds a mesh that will display at a certain distance and greater. Typically the further away the distance, the lower the detail on the mesh."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getCurrentLevel": {
          "!type": "fn() -> number",
          "!doc": "Returns the currently active LOD level index."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectForDistance": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Returns a reference to the first 3D object that is greater than the given distance."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this LOD."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "removeLevel": {
          "!type": "fn(distance: number) -> bool",
          "!doc": "Removes an existing level, based on the distance from the camera. Returns true when the level has been removed. Otherwise false."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "update": {
          "!type": "fn(camera: +THREE.Camera)",
          "!doc": "Updates the LOD by computing which LOD level should be visible according to the current distance of the given camera."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new LOD.",
      "!type": "fn()"
    },
    "LatheGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/LatheGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.LatheGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new lathe geometry.",
      "!type": "fn(points, segments: number, phiStart: number, phiLength: number)"
    },
    "Layers": {
      "!url": "https://threejs.org/docs/#api/en/core/Layers",
      "prototype": {
        "mask": {
          "!type": "number",
          "!doc": "A bit mask storing which of the 32 layers this layers object is currently a member of."
        },
        "disable": {
          "!type": "fn(layer: number)",
          "!doc": "Removes membership of the given layer."
        },
        "disableAll": {
          "!type": "fn()",
          "!doc": "Removes the membership from all layers."
        },
        "enable": {
          "!type": "fn(layer: number)",
          "!doc": "Adds membership of the given layer."
        },
        "enableAll": {
          "!type": "fn()",
          "!doc": "Adds membership to all layers."
        },
        "isEnabled": {
          "!type": "fn(layer: number) -> bool",
          "!doc": "Returns true if the given layer is enabled."
        },
        "set": {
          "!type": "fn(layer: number)",
          "!doc": "Sets membership to the given layer, and remove membership all other layers."
        },
        "test": {
          "!type": "fn(layers: +THREE.Layers) -> bool",
          "!doc": "Returns true if this and the given layers object have at least one layer in common."
        },
        "toggle": {
          "!type": "fn(layer: number)",
          "!doc": "Toggles the membership of the given layer."
        }
      },
      "!doc": "Constructs a new layers instance, with membership initially set to layer 0.",
      "!type": "fn()"
    },
    "Light": {
      "!url": "https://threejs.org/docs/#api/en/lights/Light",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The light's color."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The light's intensity."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new light.",
      "!type": "fn(color: number, intensity: number)"
    },
    "LightProbe": {
      "!url": "https://threejs.org/docs/#api/en/lights/LightProbe",
      "prototype": {
        "!proto": "THREE.Light.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The light's color."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The light's intensity."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "sh": {
          "!type": "+THREE.SphericalHarmonics3",
          "!doc": "A light probe uses spherical harmonics to encode lighting information."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new light probe.",
      "!type": "fn(sh: +THREE.SphericalHarmonics3, intensity: number)"
    },
    "LightShadow": {
      "!url": "https://threejs.org/docs/#api/en/lights/LightShadow",
      "prototype": {
        "autoUpdate": {
          "!type": "bool",
          "!doc": "Enables automatic updates of the light's shadow. If you do not require dynamic lighting / shadows, you may set this to false."
        },
        "bias": {
          "!type": "number",
          "!doc": "Shadow map bias, how much to add or subtract from the normalized depth when deciding whether a surface is in shadow. The default is 0. Very tiny adjustments here (in the order of 0.0001) may help reduce artifacts in shadows."
        },
        "biasNode": {
          "!doc": "A node version of bias. Only supported with WebGPURenderer. If a bias node is defined, bias has no effect."
        },
        "blurSamples": {
          "!type": "number",
          "!doc": "The amount of samples to use when blurring a VSM shadow map."
        },
        "camera": {
          "!type": "+THREE.Camera",
          "!doc": "The light's view of the world."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The intensity of the shadow. The default is 1. Valid values are in the range [0, 1]."
        },
        "map": {
          "!type": "+THREE.RenderTarget",
          "!doc": "The depth map generated using the internal camera; a location beyond a pixel's depth is in shadow. Computed internally during rendering."
        },
        "mapPass": {
          "!type": "+THREE.RenderTarget",
          "!doc": "The distribution map generated using the internal camera; an occlusion is calculated based on the distribution of depths. Computed internally during rendering."
        },
        "mapSize": {
          "!type": "+THREE.Vector2",
          "!doc": "Defines the width and height of the shadow map. Higher values give better quality shadows at the cost of computation time. Values must be powers of two."
        },
        "mapType": {
          "!type": "number",
          "!doc": "The type of shadow texture. The default is UnsignedByteType."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Model to shadow camera space, to compute location and depth in shadow map. This is computed internally during rendering."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, shadow maps will be updated in the next render call. If you have set LightShadow to false, you will need to set this property to true and then make a render call to update the light's shadow."
        },
        "normalBias": {
          "!type": "number",
          "!doc": "Defines how much the position used to query the shadow map is offset along the object normal. The default is 0. Increasing this value can be used to reduce shadow acne especially in large scenes where light shines onto geometry at a shallow angle. The cost is that shadows may appear distorted."
        },
        "radius": {
          "!type": "number",
          "!doc": "Setting this to values greater than 1 will blur the edges of the shadow. High values will cause unwanted banding effects in the shadows - a greater map size will allow for a higher value to be used here before these effects become visible. The property has no effect when the shadow map type is BasicShadowMap."
        },
        "clone": {
          "!type": "fn() -> +THREE.LightShadow",
          "!doc": "Returns a new light shadow instance with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.LightShadow) -> +THREE.LightShadow",
          "!doc": "Copies the values of the given light shadow instance to this instance."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getFrameExtents": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "Returns the frame extends."
        },
        "getFrustum": {
          "!type": "fn() -> +THREE.Frustum",
          "!doc": "Gets the shadow cameras frustum. Used internally by the renderer to cull objects."
        },
        "getViewport": {
          "!type": "fn(viewportIndex: number) -> +THREE.Vector4",
          "!doc": "Returns a viewport definition for the given viewport index."
        },
        "getViewportCount": {
          "!type": "fn() -> number",
          "!doc": "Used internally by the renderer to get the number of viewports that need to be rendered for this shadow."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the light shadow into JSON."
        },
        "updateMatrices": {
          "!type": "fn(light: +THREE.Light)",
          "!doc": "Update the matrices for the camera and shadow, used internally by the renderer."
        }
      },
      "!doc": "Constructs a new light shadow.",
      "!type": "fn(camera: +THREE.Camera)"
    },
    "Line": {
      "!url": "https://threejs.org/docs/#api/en/objects/Line",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The line geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The line material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeLineDistances": {
          "!type": "fn() -> +THREE.Line",
          "!doc": "Computes an array of distance values which are necessary for rendering dashed lines. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Line and Line to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new line.",
      "!type": "fn(geometry: +THREE.BufferGeometry, material: +THREE.Material)"
    },
    "Line2NodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/Line2NodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be used or not."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "number",
          "!doc": "Blending is set to NoBlending since transparency is not supported, yet."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "dashOffset": {
          "!type": "number",
          "!doc": "The dash offset."
        },
        "dashScaleNode": {
          "!doc": "Defines the dash scale."
        },
        "dashSizeNode": {
          "!doc": "Defines the dash size."
        },
        "dashed": {
          "!type": "bool",
          "!doc": "Whether the lines should be dashed or not."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "gapSizeNode": {
          "!doc": "Defines the gap size."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Whether this material is affected by lights or not."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "lineColorNode": {
          "!doc": "Defines the lines color."
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "offsetNode": {
          "!doc": "Defines the offset."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "Whether vertex colors should be used or not."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "worldUnits": {
          "!type": "bool",
          "!doc": "Whether the lines should sized in world units or not. When set to false the unit is pixel."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the environment node from the material."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightingModel",
          "!doc": "This method should be implemented by most derived materials since it defines the material's lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Abstract interface method that can be implemented by derived materials to setup material-specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new node material for wide line rendering.",
      "!type": "fn(parameters: object)"
    },
    "Line3": {
      "!url": "https://threejs.org/docs/#api/en/math/Line3",
      "prototype": {
        "end": {
          "!type": "+THREE.Vector3",
          "!doc": "End of the line segment."
        },
        "start": {
          "!type": "+THREE.Vector3",
          "!doc": "Start of the line segment."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.Line3",
          "!doc": "Applies a 4x4 transformation matrix to this line segment."
        },
        "at": {
          "!type": "fn(t: number, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector at a certain position along the line segment."
        },
        "clone": {
          "!type": "fn() -> +THREE.Line3",
          "!doc": "Returns a new line segment with copied values from this instance."
        },
        "closestPointToPoint": {
          "!type": "fn(point: +THREE.Vector3, clampToLine: bool, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the closest point on the line for a given point."
        },
        "closestPointToPointParameter": {
          "!type": "fn(point: +THREE.Vector3, clampToLine: bool) -> number",
          "!doc": "Returns a point parameter based on the closest point as projected on the line segment."
        },
        "copy": {
          "!type": "fn(line: +THREE.Line3) -> +THREE.Line3",
          "!doc": "Copies the values of the given line segment to this instance."
        },
        "delta": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the delta vector of the line segment's start and end point."
        },
        "distance": {
          "!type": "fn() -> number",
          "!doc": "Returns the Euclidean distance between the line' start and end point."
        },
        "distanceSq": {
          "!type": "fn() -> number",
          "!doc": "Returns the squared Euclidean distance between the line' start and end point."
        },
        "distanceSqToLine3": {
          "!type": "fn(line: +THREE.Line3, c1: +THREE.Vector3, c2: +THREE.Vector3) -> number",
          "!doc": "Returns the closest squared distance between this line segment and the given one."
        },
        "equals": {
          "!type": "fn(line: +THREE.Line3) -> bool",
          "!doc": "Returns true if this line segment is equal with the given one."
        },
        "getCenter": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the center of the line segment."
        },
        "set": {
          "!type": "fn(start: +THREE.Vector3, end: +THREE.Vector3) -> +THREE.Line3",
          "!doc": "Sets the start and end values by copying the given vectors."
        }
      },
      "!doc": "Constructs a new line segment.",
      "!type": "fn(start: +THREE.Vector3, end: +THREE.Vector3)"
    },
    "LineBasicMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/LineBasicMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the material."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether the material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "linecap": {
          "!type": "+THREE.butt",
          "!doc": "Defines appearance of line ends. Can only be used with SVGRenderer."
        },
        "linejoin": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of line joints. Can only be used with SVGRenderer."
        },
        "linewidth": {
          "!type": "number",
          "!doc": "Controls line thickness or lines. Can only be used with SVGRenderer. WebGL and WebGPU ignore this setting and always render line primitives with a width of one pixel."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "Sets the color of the lines using data from a texture. The texture map color is modulated by the diffuse color."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new line basic material.",
      "!type": "fn(parameters: object)"
    },
    "LineBasicNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/LineBasicNodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Whether this material is affected by lights or not."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the environment node from the material."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightingModel",
          "!doc": "This method should be implemented by most derived materials since it defines the material's lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Abstract interface method that can be implemented by derived materials to setup material-specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new line basic node material.",
      "!type": "fn(parameters: object)"
    },
    "LineCurve": {
      "!url": "https://threejs.org/docs/#api/en/extras/LineCurve",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "v1": {
          "!type": "+THREE.Vector2",
          "!doc": "The start point."
        },
        "v2": {
          "!type": "+THREE.Vector2",
          "!doc": "The end point."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a point on the line."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new line curve.",
      "!type": "fn(v1: +THREE.Vector2, v2: +THREE.Vector2)"
    },
    "LineCurve3": {
      "!url": "https://threejs.org/docs/#api/en/extras/LineCurve3",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "v1": {
          "!type": "+THREE.Vector3",
          "!doc": "The start point."
        },
        "v2": {
          "!type": "+THREE.Vector2",
          "!doc": "The end point."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a point on the line."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new line curve.",
      "!type": "fn(v1: +THREE.Vector3, v2: +THREE.Vector3)"
    },
    "LineDashedMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/LineDashedMaterial",
      "prototype": {
        "!proto": "THREE.LineBasicMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the material."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "dashSize": {
          "!type": "number",
          "!doc": "The size of the dash. This is both the gap with the stroke."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether the material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "gapSize": {
          "!type": "number",
          "!doc": "The size of the gap."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "linecap": {
          "!type": "+THREE.butt",
          "!doc": "Defines appearance of line ends. Can only be used with SVGRenderer."
        },
        "linejoin": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of line joints. Can only be used with SVGRenderer."
        },
        "linewidth": {
          "!type": "number",
          "!doc": "Controls line thickness or lines. Can only be used with SVGRenderer. WebGL and WebGPU ignore this setting and always render line primitives with a width of one pixel."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "Sets the color of the lines using data from a texture. The texture map color is modulated by the diffuse color."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "scale": {
          "!type": "number",
          "!doc": "The scale of the dashed part of a line."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new line dashed material.",
      "!type": "fn(parameters: object)"
    },
    "LineDashedNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/LineDashedNodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "dashOffset": {
          "!type": "number",
          "!doc": "The dash offset."
        },
        "dashScaleNode": {
          "!doc": "The scale of dash materials is by default inferred from the scale property. This node property allows to overwrite the default and define the scale with a node instead. If you don't want to overwrite the scale but modify the existing value instead, use materialLineScale."
        },
        "dashSizeNode": {
          "!doc": "The dash size of dash materials is by default inferred from the dashSize property. This node property allows to overwrite the default and define the dash size with a node instead. If you don't want to overwrite the dash size but modify the existing value instead, use materialLineDashSize."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "gapSizeNode": {
          "!doc": "The gap size of dash materials is by default inferred from the gapSize property. This node property allows to overwrite the default and define the gap size with a node instead. If you don't want to overwrite the gap size but modify the existing value instead, use materialLineGapSize."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Whether this material is affected by lights or not."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "offsetNode": {
          "!doc": "The offset of dash materials is by default inferred from the dashOffset property. This node property allows to overwrite the default and define the offset with a node instead. If you don't want to overwrite the offset but modify the existing value instead, use materialLineDashOffset."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the environment node from the material."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightingModel",
          "!doc": "This method should be implemented by most derived materials since it defines the material's lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the dash specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new line dashed node material.",
      "!type": "fn(parameters: object)"
    },
    "LineLoop": {
      "!url": "https://threejs.org/docs/#api/en/objects/LineLoop",
      "prototype": {
        "!proto": "THREE.Line.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The line geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The line material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeLineDistances": {
          "!type": "fn() -> +THREE.Line",
          "!doc": "Computes an array of distance values which are necessary for rendering dashed lines. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Line and Line to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new line loop.",
      "!type": "fn(geometry: +THREE.BufferGeometry, material: +THREE.Material)"
    },
    "LineSegments": {
      "!url": "https://threejs.org/docs/#api/en/objects/LineSegments",
      "prototype": {
        "!proto": "THREE.Line.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The line geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The line material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeLineDistances": {
          "!type": "fn() -> +THREE.Line",
          "!doc": "Computes an array of distance values which are necessary for rendering dashed lines. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Line and Line to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new line segments.",
      "!type": "fn(geometry: +THREE.BufferGeometry, material: +THREE.Material)"
    },
    "LinearInterpolant": {
      "!url": "https://threejs.org/docs/#api/en/math/LinearInterpolant",
      "prototype": {
        "!proto": "THREE.Interpolant.prototype",
        "DefaultSettings_": {
          "!type": "object",
          "!doc": "The default settings object."
        },
        "parameterPositions": {
          "!type": "+TypedArray",
          "!doc": "The parameter positions."
        },
        "resultBuffer": {
          "!type": "+TypedArray",
          "!doc": "The result buffer."
        },
        "sampleValues": {
          "!type": "+TypedArray",
          "!doc": "The sample values."
        },
        "settings": {
          "!type": "object",
          "!doc": "The interpolation settings."
        },
        "valueSize": {
          "!type": "+TypedArray",
          "!doc": "The value size."
        },
        "copySampleValue_": {
          "!type": "fn(index: number) -> +TypedArray",
          "!doc": "Copies a sample value to the result buffer."
        },
        "evaluate": {
          "!type": "fn(t: number) -> +TypedArray",
          "!doc": "Evaluate the interpolant at position t."
        },
        "getSettings_": {
          "!type": "fn() -> object",
          "!doc": "Returns the interpolation settings."
        },
        "interpolate_": {
          "!type": "fn(i1: number, t0: number, t: number, t1: number) -> +TypedArray",
          "!doc": "Copies a sample value to the result buffer."
        },
        "intervalChanged_": {
          "!type": "fn(i1: number, t0: number, t: number)",
          "!doc": "Optional method that is executed when the interval has changed."
        }
      },
      "!doc": "Constructs a new linear interpolant.",
      "!type": "fn(parameterPositions: +TypedArray, sampleValues: +TypedArray, sampleSize: number, resultBuffer: +TypedArray)"
    },
    "Loader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/Loader",
      "prototype": {
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "DEFAULT_MATERIAL_NAME": {
          "!type": "string",
          "!doc": "The default material name that is used by loaders when creating materials for loaded 3D objects. Note: Not all loaders might honor this setting."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback)",
          "!doc": "This method needs to be implemented by all concrete loaders. It holds the logic for loading assets from the backend."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(data: ?)",
          "!doc": "This method needs to be implemented by all concrete loaders. It holds the logic for parsing the asset into three.js entities."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "LoaderUtils": {
      "!url": "https://threejs.org/docs/#api/en/loaders/LoaderUtils",
      "prototype": {
        "extractUrlBase": {
          "!type": "fn(url: string) -> string",
          "!doc": "Extracts the base URL from the given URL."
        },
        "resolveURL": {
          "!type": "fn(url: string, path: string) -> string",
          "!doc": "Resolves relative URLs against the given path. Absolute paths, data urls, and blob URLs will be returned as is. Invalid URLs will return an empty string."
        }
      },
      "!type": "fn()"
    },
    "LoadingManager": {
      "!url": "https://threejs.org/docs/#api/en/loaders/LoadingManager",
      "prototype": {
        "abortController": {
          "!type": "+THREE.AbortController",
          "!doc": "Used for aborting ongoing requests in loaders using this manager."
        },
        "onError": {
          "!type": "fn()",
          "!doc": "Executes when an error occurs."
        },
        "onLoad": {
          "!type": "fn()",
          "!doc": "Executes when all items have been loaded."
        },
        "onProgress": {
          "!type": "fn()",
          "!doc": "Executes when single items have been loaded."
        },
        "onStart": {
          "!type": "fn()",
          "!doc": "Executes when an item starts loading."
        },
        "abort": {
          "!type": "fn() -> +THREE.LoadingManager",
          "!doc": "Can be used to abort ongoing loading requests in loaders using this manager. The abort only works if the loaders implement Loader and AbortSignal.any() is supported in the browser."
        },
        "addHandler": {
          "!type": "fn(regex: string, loader: +THREE.Loader) -> +THREE.LoadingManager",
          "!doc": "Registers a loader with the given regular expression. Can be used to define what loader should be used in order to load specific files. A typical use case is to overwrite the default loader for textures. ``js // add handler for TGA textures manager.addHandler( /\\.tga$/i, new TGALoader() ); ``"
        },
        "getHandler": {
          "!type": "fn(file: string) -> +THREE.Loader",
          "!doc": "Can be used to retrieve the registered loader for the given file path."
        },
        "itemEnd": {
          "!type": "fn(url: string)",
          "!doc": "This should be called by any loader using the manager when the loader ended loading an item."
        },
        "itemError": {
          "!type": "fn(url: string)",
          "!doc": "This should be called by any loader using the manager when the loader encounters an error when loading an item."
        },
        "itemStart": {
          "!type": "fn(url: string)",
          "!doc": "This should be called by any loader using the manager when the loader starts loading an item."
        },
        "removeHandler": {
          "!type": "fn(regex: string) -> +THREE.LoadingManager",
          "!doc": "Removes the loader for the given regular expression."
        },
        "resolveURL": {
          "!type": "fn(url: string) -> string",
          "!doc": "Given a URL, uses the URL modifier callback (if any) and returns a resolved URL. If no URL modifier is set, returns the original URL."
        },
        "setURLModifier": {
          "!type": "fn(transform: fn()) -> +THREE.LoadingManager",
          "!doc": "If provided, the callback will be passed each resource URL before a request is sent. The callback may return the original URL, or a new URL to override loading behavior. This behavior can be used to load assets from .ZIP files, drag-and-drop APIs, and Data URIs. ``js const blobs = {'fish.gltf': blob1, 'diffuse.png': blob2, 'normal.png': blob3}; const manager = new THREE.LoadingManager(); // Initialize loading manager with URL callback. const objectURLs = []; manager.setURLModifier( ( url ) => { url = URL.createObjectURL( blobs[ url ] ); objectURLs.push( url ); return url; } ); // Load as usual, then revoke the blob URLs. const loader = new GLTFLoader( manager ); loader.load( 'fish.gltf', (gltf) => { scene.add( gltf.scene ); objectURLs.forEach( ( url ) => URL.revokeObjectURL( url ) ); } ); ``"
        }
      },
      "!doc": "Constructs a new loading manager.",
      "!type": "fn(onLoad: fn(), onProgress: fn(), onError: fn())"
    },
    "Material": {
      "!url": "https://threejs.org/docs/#api/en/materials/Material",
      "prototype": {
        "!proto": "THREE.EventDispatcher.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new material.",
      "!type": "fn()"
    },
    "MaterialLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/MaterialLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "textures": {
          "!doc": "A dictionary holding textures used by the material."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "createMaterialFromType": {
          "!type": "fn(type: string) -> +THREE.Material",
          "!doc": "Creates a material for the given type."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback)",
          "!doc": "Starts loading from the given URL and pass the loaded material to the onLoad() callback."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(json: object) -> +THREE.Material",
          "!doc": "Parses the given JSON object and returns a material."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setTextures": {
          "!type": "fn(value: object) -> +THREE.MaterialLoader",
          "!doc": "Textures are not embedded in the material JSON so they have to be injected before the loading process starts."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new material loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "MathUtils": {
      "!url": "https://threejs.org/docs/#api/en/math/MathUtils",
      "prototype": {
        "ceilPowerOfTwo": {
          "!type": "fn(value: number) -> number",
          "!doc": "Returns the smallest power of two that is greater than or equal to the given number."
        },
        "clamp": {
          "!type": "fn(value: number, min: number, max: number) -> number",
          "!doc": "Clamps the given value between min and max."
        },
        "damp": {
          "!type": "fn(x: number, y: number, lambda: number, dt: number) -> number",
          "!doc": "Smoothly interpolate a number from x to y in a spring-like manner using a delta time to maintain frame rate independent movement. For details, see [Frame rate independent damping using lerp](http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/)."
        },
        "degToRad": {
          "!type": "fn(degrees: number) -> number",
          "!doc": "Converts degrees to radians."
        },
        "denormalize": {
          "!type": "fn(value: number, array: +TypedArray) -> number",
          "!doc": "Denormalizes the given value according to the given typed array."
        },
        "euclideanModulo": {
          "!type": "fn(n: number, m: number) -> number",
          "!doc": "Computes the Euclidean modulo of the given parameters that is ( ( n % m ) + m ) % m."
        },
        "floorPowerOfTwo": {
          "!type": "fn(value: number) -> number",
          "!doc": "Returns the largest power of two that is less than or equal to the given number."
        },
        "generateUUID": {
          "!type": "fn() -> string",
          "!doc": "Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) (universally unique identifier)."
        },
        "inverseLerp": {
          "!type": "fn(x: number, y: number, value: number) -> number",
          "!doc": "Returns the percentage in the closed interval [0, 1] of the given value between the start and end point."
        },
        "isPowerOfTwo": {
          "!type": "fn(value: number) -> bool",
          "!doc": "Returns true if the given number is a power of two."
        },
        "lerp": {
          "!type": "fn(x: number, y: number, t: number) -> number",
          "!doc": "Returns a value linearly interpolated from two known points based on the given interval - t = 0 will return x and t = 1 will return y."
        },
        "mapLinear": {
          "!type": "fn(x: number, a1: number, a2: number, b1: number, b2: number) -> number",
          "!doc": "Performs a linear mapping from range to range for the given value."
        },
        "normalize": {
          "!type": "fn(value: number, array: +TypedArray) -> number",
          "!doc": "Normalizes the given value according to the given typed array."
        },
        "pingpong": {
          "!type": "fn(x: number, length: number) -> number",
          "!doc": "Returns a value that alternates between 0 and the given length parameter."
        },
        "radToDeg": {
          "!type": "fn(radians: number) -> number",
          "!doc": "Converts radians to degrees."
        },
        "randFloat": {
          "!type": "fn(low: number, high: number) -> number",
          "!doc": "Returns a random float from interval."
        },
        "randFloatSpread": {
          "!type": "fn(range: number) -> number",
          "!doc": "Returns a random integer from interval."
        },
        "randInt": {
          "!type": "fn(low: number, high: number) -> number",
          "!doc": "Returns a random integer from interval."
        },
        "seededRandom": {
          "!type": "fn(s: number) -> number",
          "!doc": "Returns a deterministic pseudo-random float in the interval [0, 1]."
        },
        "setQuaternionFromProperEuler": {
          "!type": "fn(q: +THREE.Quaternion, a: number, b: number, c: number, order: +THREE.XYX)",
          "!doc": "Sets the given quaternion from the [Intrinsic Proper Euler Angles](https://en.wikipedia.org/wiki/Euler_angles) defined by the given angles and order. Rotations are applied to the axes in the order specified by order: rotation by angle a is applied first, then by angle b, then by angle c."
        },
        "smootherstep": {
          "!type": "fn(x: number, min: number, max: number) -> number",
          "!doc": "A [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations) that has zero 1st and 2nd order derivatives at x=0 and x=1."
        },
        "smoothstep": {
          "!type": "fn(x: number, min: number, max: number) -> number",
          "!doc": "Returns a value in the range [0,1] that represents the percentage that x has moved between min and max, but smoothed or slowed down the closer x is to the min and max. See [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for more details."
        }
      },
      "!type": "fn()"
    },
    "Matrix2": {
      "!url": "https://threejs.org/docs/#api/en/math/Matrix2",
      "prototype": {
        "elements": {
          "!doc": "A column-major list of matrix values."
        },
        "fromArray": {
          "!type": "fn(array, offset: number) -> +THREE.Matrix2",
          "!doc": "Sets the elements of the matrix from the given array."
        },
        "identity": {
          "!type": "fn() -> +THREE.Matrix2",
          "!doc": "Sets this matrix to the 2x2 identity matrix."
        },
        "set": {
          "!type": "fn(n11: number, n12: number, n21: number, n22: number) -> +THREE.Matrix2",
          "!doc": "Sets the elements of the matrix.The arguments are supposed to be in row-major order."
        }
      },
      "!doc": "Constructs a new 2x2 matrix. The arguments are supposed to be in row-major order. If no arguments are provided, the constructor initializes the matrix as an identity matrix.",
      "!type": "fn(n11: number, n12: number, n21: number, n22: number)"
    },
    "Matrix3": {
      "!url": "https://threejs.org/docs/#api/en/math/Matrix3",
      "prototype": {
        "elements": {
          "!doc": "A column-major list of matrix values."
        },
        "clone": {
          "!type": "fn() -> +THREE.Matrix3",
          "!doc": "Returns a matrix with copied values from this instance."
        },
        "copy": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.Matrix3",
          "!doc": "Copies the values of the given matrix to this instance."
        },
        "determinant": {
          "!type": "fn() -> number",
          "!doc": "Computes and returns the determinant of this matrix."
        },
        "equals": {
          "!type": "fn(matrix: +THREE.Matrix3) -> bool",
          "!doc": "Returns true if this matrix is equal with the given one."
        },
        "extractBasis": {
          "!type": "fn(xAxis: +THREE.Vector3, yAxis: +THREE.Vector3, zAxis: +THREE.Vector3) -> +THREE.Matrix3",
          "!doc": "Extracts the basis of this matrix into the three axis vectors provided."
        },
        "fromArray": {
          "!type": "fn(array, offset: number) -> +THREE.Matrix3",
          "!doc": "Sets the elements of the matrix from the given array."
        },
        "getNormalMatrix": {
          "!type": "fn(matrix4: +THREE.Matrix4) -> +THREE.Matrix3",
          "!doc": "Computes the normal matrix which is the inverse transpose of the upper left 3x3 portion of the given 4x4 matrix."
        },
        "identity": {
          "!type": "fn() -> +THREE.Matrix3",
          "!doc": "Sets this matrix to the 3x3 identity matrix."
        },
        "invert": {
          "!type": "fn() -> +THREE.Matrix3",
          "!doc": "Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution). You can not invert with a determinant of zero. If you attempt this, the method produces a zero matrix instead."
        },
        "makeRotation": {
          "!type": "fn(theta: number) -> +THREE.Matrix3",
          "!doc": "Sets this matrix as a 2D rotational transformation."
        },
        "makeScale": {
          "!type": "fn(x: number, y: number) -> +THREE.Matrix3",
          "!doc": "Sets this matrix as a 2D scale transform."
        },
        "makeTranslation": {
          "!type": "fn(x: number, y: number) -> +THREE.Matrix3",
          "!doc": "Sets this matrix as a 2D translation transform."
        },
        "multiply": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.Matrix3",
          "!doc": "Post-multiplies this matrix by the given 3x3 matrix."
        },
        "multiplyMatrices": {
          "!type": "fn(a: +THREE.Matrix3, b: +THREE.Matrix3) -> +THREE.Matrix3",
          "!doc": "Multiples the given 3x3 matrices and stores the result in this matrix."
        },
        "multiplyScalar": {
          "!type": "fn(s: number) -> +THREE.Matrix3",
          "!doc": "Multiplies every component of the matrix by the given scalar."
        },
        "premultiply": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.Matrix3",
          "!doc": "Pre-multiplies this matrix by the given 3x3 matrix."
        },
        "rotate": {
          "!type": "fn(theta: number) -> +THREE.Matrix3",
          "!doc": "Rotates this matrix by the given angle."
        },
        "scale": {
          "!type": "fn(sx: number, sy: number) -> +THREE.Matrix3",
          "!doc": "Scales this matrix with the given scalar values."
        },
        "set": {
          "!type": "fn(n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) -> +THREE.Matrix3",
          "!doc": "Sets the elements of the matrix.The arguments are supposed to be in row-major order."
        },
        "setFromMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix3",
          "!doc": "Set this matrix to the upper 3x3 matrix of the given 4x4 matrix."
        },
        "setUvTransform": {
          "!type": "fn(tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) -> +THREE.Matrix3",
          "!doc": "Sets the UV transform matrix from offset, repeat, rotation, and center."
        },
        "toArray": {
          "!type": "fn(array, offset: number)",
          "!doc": "Writes the elements of this matrix to the given array. If no array is provided, the method returns a new instance."
        },
        "translate": {
          "!type": "fn(tx: number, ty: number) -> +THREE.Matrix3",
          "!doc": "Translates this matrix by the given scalar values."
        },
        "transpose": {
          "!type": "fn() -> +THREE.Matrix3",
          "!doc": "Transposes this matrix in place."
        },
        "transposeIntoArray": {
          "!type": "fn(r) -> +THREE.Matrix3",
          "!doc": "Transposes this matrix into the supplied array, and returns itself unchanged."
        }
      },
      "!doc": "Constructs a new 3x3 matrix. The arguments are supposed to be in row-major order. If no arguments are provided, the constructor initializes the matrix as an identity matrix.",
      "!type": "fn(n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number)"
    },
    "Matrix4": {
      "!url": "https://threejs.org/docs/#api/en/math/Matrix4",
      "prototype": {
        "elements": {
          "!doc": "A column-major list of matrix values."
        },
        "clone": {
          "!type": "fn() -> +THREE.Matrix4",
          "!doc": "Returns a matrix with copied values from this instance."
        },
        "compose": {
          "!type": "fn(position: +THREE.Vector3, quaternion: +THREE.Quaternion, scale: +THREE.Vector3) -> +THREE.Matrix4",
          "!doc": "Sets this matrix to the transformation composed of the given position, rotation (Quaternion) and scale."
        },
        "copy": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Copies the values of the given matrix to this instance."
        },
        "copyPosition": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Copies the translation component of the given matrix into this matrix's translation component."
        },
        "decompose": {
          "!type": "fn(position: +THREE.Vector3, quaternion: +THREE.Quaternion, scale: +THREE.Vector3) -> +THREE.Matrix4",
          "!doc": "Decomposes this matrix into its position, rotation and scale components and provides the result in the given objects. Note: Not all matrices are decomposable in this way. For example, if an object has a non-uniformly scaled parent, then the object's world matrix may not be decomposable, and this method may not be appropriate."
        },
        "determinant": {
          "!type": "fn() -> number",
          "!doc": "Computes and returns the determinant of this matrix. Based on the method outlined [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html)."
        },
        "equals": {
          "!type": "fn(matrix: +THREE.Matrix4) -> bool",
          "!doc": "Returns true if this matrix is equal with the given one."
        },
        "extractBasis": {
          "!type": "fn(xAxis: +THREE.Vector3, yAxis: +THREE.Vector3, zAxis: +THREE.Vector3) -> +THREE.Matrix4",
          "!doc": "Extracts the basis of this matrix into the three axis vectors provided."
        },
        "extractRotation": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Extracts the rotation component of the given matrix into this matrix's rotation component. Note: This method does not support reflection matrices."
        },
        "fromArray": {
          "!type": "fn(array, offset: number) -> +THREE.Matrix4",
          "!doc": "Sets the elements of the matrix from the given array."
        },
        "getMaxScaleOnAxis": {
          "!type": "fn() -> number",
          "!doc": "Gets the maximum scale value of the three axes."
        },
        "identity": {
          "!type": "fn() -> +THREE.Matrix4",
          "!doc": "Sets this matrix to the 4x4 identity matrix."
        },
        "invert": {
          "!type": "fn() -> +THREE.Matrix4",
          "!doc": "Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution). You can not invert with a determinant of zero. If you attempt this, the method produces a zero matrix instead."
        },
        "lookAt": {
          "!type": "fn(eye: +THREE.Vector3, target: +THREE.Vector3, up: +THREE.Vector3) -> +THREE.Matrix4",
          "!doc": "Sets the rotation component of the transformation matrix, looking from eye towards target, and oriented by the up-direction."
        },
        "makeBasis": {
          "!type": "fn(xAxis: +THREE.Vector3, yAxis: +THREE.Vector3, zAxis: +THREE.Vector3) -> +THREE.Matrix4",
          "!doc": "Sets the given basis vectors to this matrix."
        },
        "makeOrthographic": {
          "!type": "fn(left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem: +THREE.WebGLCoordinateSystem, reversedDepth: bool) -> +THREE.Matrix4",
          "!doc": "Creates a orthographic projection matrix. This is used internally by OrthographicCamera."
        },
        "makePerspective": {
          "!type": "fn(left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem: +THREE.WebGLCoordinateSystem, reversedDepth: bool) -> +THREE.Matrix4",
          "!doc": "Creates a perspective projection matrix. This is used internally by PerspectiveCamera."
        },
        "makeRotationAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as a rotational transformation around the given axis by the given angle. This is a somewhat controversial but mathematically sound alternative to rotating via Quaternions. See the discussion [here](https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199)."
        },
        "makeRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler) -> +THREE.Matrix4",
          "!doc": "Sets the rotation component (the upper left 3x3 matrix) of this matrix to the rotation specified by the given Euler angles. The rest of the matrix is set to the identity. Depending on the Euler, there are six possible outcomes. See [this page](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix) for a complete list."
        },
        "makeRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Matrix4",
          "!doc": "Sets the rotation component of this matrix to the rotation specified by the given Quaternion as outlined [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion) The rest of the matrix is set to the identity."
        },
        "makeRotationX": {
          "!type": "fn(theta: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as a rotational transformation around the X axis by the given angle."
        },
        "makeRotationY": {
          "!type": "fn(theta: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as a rotational transformation around the Y axis by the given angle."
        },
        "makeRotationZ": {
          "!type": "fn(theta: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as a rotational transformation around the Z axis by the given angle."
        },
        "makeScale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as a scale transformation."
        },
        "makeShear": {
          "!type": "fn(xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as a shear transformation."
        },
        "makeTranslation": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.Matrix4",
          "!doc": "Sets this matrix as a translation transform from the given vector."
        },
        "multiply": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Post-multiplies this matrix by the given 4x4 matrix."
        },
        "multiplyMatrices": {
          "!type": "fn(a: +THREE.Matrix4, b: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Multiples the given 4x4 matrices and stores the result in this matrix."
        },
        "multiplyScalar": {
          "!type": "fn(s: number) -> +THREE.Matrix4",
          "!doc": "Multiplies every component of the matrix by the given scalar."
        },
        "premultiply": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Matrix4",
          "!doc": "Pre-multiplies this matrix by the given 4x4 matrix."
        },
        "scale": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Matrix4",
          "!doc": "Multiplies the columns of this matrix by the given vector."
        },
        "set": {
          "!type": "fn(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) -> +THREE.Matrix4",
          "!doc": "Sets the elements of the matrix.The arguments are supposed to be in row-major order."
        },
        "setFromMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.Matrix4",
          "!doc": "Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix."
        },
        "setPosition": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.Matrix4",
          "!doc": "Sets the position component for this matrix from the given vector, without affecting the rest of the matrix."
        },
        "toArray": {
          "!type": "fn(array, offset: number)",
          "!doc": "Writes the elements of this matrix to the given array. If no array is provided, the method returns a new instance."
        },
        "transpose": {
          "!type": "fn() -> +THREE.Matrix4",
          "!doc": "Transposes this matrix in place."
        }
      },
      "!doc": "Constructs a new 4x4 matrix. The arguments are supposed to be in row-major order. If no arguments are provided, the constructor initializes the matrix as an identity matrix.",
      "!type": "fn(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number)"
    },
    "Mesh": {
      "!url": "https://threejs.org/docs/#api/en/objects/Mesh",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "count": {
          "!type": "number",
          "!doc": "The number of instances of this mesh. Can only be used with WebGPURenderer."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The mesh geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The mesh material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getVertexPosition": {
          "!type": "fn(index: number, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the local-space position of the vertex at the given index, taking into account the current animation state of both morph targets and skinning."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Mesh and Mesh to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new mesh.",
      "!type": "fn(geometry: +THREE.BufferGeometry, material: +THREE.Material)"
    },
    "MeshBasicMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshBasicMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoMap": {
          "!type": "+THREE.Texture",
          "!doc": "The red channel of this texture is used as the ambient occlusion map. Requires a second set of UVs."
        },
        "aoMapIntensity": {
          "!type": "number",
          "!doc": "Intensity of the ambient occlusion effect. Range is [0,1], where 0 disables ambient occlusion. Where intensity is 1 and the AO map's red channel is also 1, ambient light is fully occluded on a surface."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the material."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "combine": {
          "!type": "+THREE.MultiplyOperation",
          "!doc": "How to combine the result of the surface's color with the environment map, if any. When set to MixOperation, the MeshBasicMaterial is used to blend between the two colors."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envMap": {
          "!type": "+THREE.Texture",
          "!doc": "The environment map."
        },
        "envMapRotation": {
          "!type": "+THREE.Euler",
          "!doc": "The rotation of the environment map in radians."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether the material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lightMap": {
          "!type": "+THREE.Texture",
          "!doc": "The light map. Requires a second set of UVs."
        },
        "lightMapIntensity": {
          "!type": "number",
          "!doc": "Intensity of the baked light."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "The color map. May optionally include an alpha channel, typically combined with Material or Material. The texture map color is modulated by the diffuse color."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "reflectivity": {
          "!type": "number",
          "!doc": "How much the environment map affects the surface. The valid range is between 0 (no reflections) and 1 (full reflections)."
        },
        "refractionRatio": {
          "!type": "number",
          "!doc": "The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping modes CubeRefractionMapping and EquirectangularRefractionMapping. The refraction ratio should not exceed 1."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "specularMap": {
          "!type": "+THREE.Texture",
          "!doc": "Specular map used by the material."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Renders the geometry as a wireframe."
        },
        "wireframeLinecap": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of wireframe ends. Can only be used with SVGRenderer."
        },
        "wireframeLinejoin": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of wireframe joints. Can only be used with SVGRenderer."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls the thickness of the wireframe. Can only be used with SVGRenderer."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new mesh basic material.",
      "!type": "fn(parameters: object)"
    },
    "MeshBasicNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshBasicNodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Although the basic material is by definition unlit, we set this property to true since we use a lighting model to compute the outgoing light of the fragment shader."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Overwritten since this type of material uses BasicEnvironmentNode to implement the default environment mapping."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "This method must be overwritten since light maps are evaluated with a special scaling factor for basic materials."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn() -> +THREE.BasicLightingModel",
          "!doc": "Setups the lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Basic materials are not affected by normal and bump maps so we return by default normalViewGeometry."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "The material overwrites this method because lights is set to true but we still want to return the diffuse color as the outgoing light."
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Abstract interface method that can be implemented by derived materials to setup material-specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new mesh basic node material.",
      "!type": "fn(parameters: object)"
    },
    "MeshDepthMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshDepthMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthPacking": {
          "!type": "+THREE.BasicDepthPacking",
          "!doc": "Type for depth packing."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "displacementBias": {
          "!type": "number",
          "!doc": "The offset of the displacement map's values on the mesh's vertices. The bias is added to the scaled sample of the displacement map. Without a displacement map set, this value is not applied."
        },
        "displacementMap": {
          "!type": "+THREE.Texture",
          "!doc": "The displacement map affects the position of the mesh's vertices. Unlike other maps which only affect the light and shade of the material the displaced vertices can cast shadows, block other objects, and otherwise act as real geometry. The displacement texture is an image where the value of each pixel (white being the highest) is mapped against, and repositions, the vertices of the mesh."
        },
        "displacementScale": {
          "!type": "number",
          "!doc": "How much the displacement map affects the mesh (where black is no displacement, and white is maximum displacement). Without a displacement map set, this value is not applied."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "The color map. May optionally include an alpha channel, typically combined with Material or Material."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Renders the geometry as a wireframe."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls the thickness of the wireframe. WebGL and WebGPU ignore this property and always render 1 pixel wide lines."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new mesh depth material.",
      "!type": "fn(parameters: object)"
    },
    "MeshDistanceMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshDistanceMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "displacementBias": {
          "!type": "number",
          "!doc": "The offset of the displacement map's values on the mesh's vertices. The bias is added to the scaled sample of the displacement map. Without a displacement map set, this value is not applied."
        },
        "displacementMap": {
          "!type": "+THREE.Texture",
          "!doc": "The displacement map affects the position of the mesh's vertices. Unlike other maps which only affect the light and shade of the material the displaced vertices can cast shadows, block other objects, and otherwise act as real geometry. The displacement texture is an image where the value of each pixel (white being the highest) is mapped against, and repositions, the vertices of the mesh."
        },
        "displacementScale": {
          "!type": "number",
          "!doc": "How much the displacement map affects the mesh (where black is no displacement, and white is maximum displacement). Without a displacement map set, this value is not applied."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "The color map. May optionally include an alpha channel, typically combined with Material or Material."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new mesh distance material.",
      "!type": "fn(parameters: object)"
    },
    "MeshLambertMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshLambertMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoMap": {
          "!type": "+THREE.Texture",
          "!doc": "The red channel of this texture is used as the ambient occlusion map. Requires a second set of UVs."
        },
        "aoMapIntensity": {
          "!type": "number",
          "!doc": "Intensity of the ambient occlusion effect. Range is [0,1], where 0 disables ambient occlusion. Where intensity is 1 and the AO map's red channel is also 1, ambient light is fully occluded on a surface."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "bumpMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a bump map. The black and white values map to the perceived depth in relation to the lights. Bump doesn't actually affect the geometry of the object, only the lighting. If a normal map is defined this will be ignored."
        },
        "bumpScale": {
          "!type": "number",
          "!doc": "How much the bump map affects the material. Typical range is [0,1]."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the material."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "combine": {
          "!type": "+THREE.MultiplyOperation",
          "!doc": "How to combine the result of the surface's color with the environment map, if any. When set to MixOperation, the MeshBasicMaterial is used to blend between the two colors."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "displacementBias": {
          "!type": "number",
          "!doc": "The offset of the displacement map's values on the mesh's vertices. The bias is added to the scaled sample of the displacement map. Without a displacement map set, this value is not applied."
        },
        "displacementMap": {
          "!type": "+THREE.Texture",
          "!doc": "The displacement map affects the position of the mesh's vertices. Unlike other maps which only affect the light and shade of the material the displaced vertices can cast shadows, block other objects, and otherwise act as real geometry. The displacement texture is an image where the value of each pixel (white being the highest) is mapped against, and repositions, the vertices of the mesh."
        },
        "displacementScale": {
          "!type": "number",
          "!doc": "How much the displacement map affects the mesh (where black is no displacement, and white is maximum displacement). Without a displacement map set, this value is not applied."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "emissive": {
          "!type": "+THREE.Color",
          "!doc": "Emissive (light) color of the material, essentially a solid color unaffected by other lighting."
        },
        "emissiveIntensity": {
          "!type": "number",
          "!doc": "Intensity of the emissive light. Modulates the emissive color."
        },
        "emissiveMap": {
          "!type": "+THREE.Texture",
          "!doc": "Set emissive (glow) map. The emissive map color is modulated by the emissive color and the emissive intensity. If you have an emissive map, be sure to set the emissive color to something other than black."
        },
        "envMap": {
          "!type": "+THREE.Texture",
          "!doc": "The environment map."
        },
        "envMapIntensity": {
          "!type": "number",
          "!doc": "Scales the effect of the environment map by multiplying its color."
        },
        "envMapRotation": {
          "!type": "+THREE.Euler",
          "!doc": "The rotation of the environment map in radians."
        },
        "flatShading": {
          "!type": "bool",
          "!doc": "Whether the material is rendered with flat shading or not."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether the material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lightMap": {
          "!type": "+THREE.Texture",
          "!doc": "The light map. Requires a second set of UVs."
        },
        "lightMapIntensity": {
          "!type": "number",
          "!doc": "Intensity of the baked light."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "The color map. May optionally include an alpha channel, typically combined with Material or Material. The texture map color is modulated by the diffuse color."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a normal map. The RGB values affect the surface normal for each pixel fragment and change the way the color is lit. Normal maps do not change the actual shape of the surface, only the lighting. In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness."
        },
        "normalMapType": {
          "!type": "+THREE.TangentSpaceNormalMap",
          "!doc": "The type of normal map."
        },
        "normalScale": {
          "!type": "+THREE.Vector2",
          "!doc": "How much the normal map affects the material. Typical value range is [0,1]."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "reflectivity": {
          "!type": "number",
          "!doc": "How much the environment map affects the surface. The valid range is between 0 (no reflections) and 1 (full reflections)."
        },
        "refractionRatio": {
          "!type": "number",
          "!doc": "The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping modes CubeRefractionMapping and EquirectangularRefractionMapping. The refraction ratio should not exceed 1."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "specularMap": {
          "!type": "+THREE.Texture",
          "!doc": "Specular map used by the material."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Renders the geometry as a wireframe."
        },
        "wireframeLinecap": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of wireframe ends. Can only be used with SVGRenderer."
        },
        "wireframeLinejoin": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of wireframe joints. Can only be used with SVGRenderer."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls the thickness of the wireframe. Can only be used with SVGRenderer."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new mesh lambert material.",
      "!type": "fn(parameters: object)"
    },
    "MeshLambertNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshLambertNodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Set to true because lambert materials react on lights."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Overwritten since this type of material uses BasicEnvironmentNode to implement the default environment mapping."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn() -> +THREE.PhongLightingModel",
          "!doc": "Setups the lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Abstract interface method that can be implemented by derived materials to setup material-specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new mesh lambert node material.",
      "!type": "fn(parameters: object)"
    },
    "MeshMatcapMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshMatcapMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "bumpMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a bump map. The black and white values map to the perceived depth in relation to the lights. Bump doesn't actually affect the geometry of the object, only the lighting. If a normal map is defined this will be ignored."
        },
        "bumpScale": {
          "!type": "number",
          "!doc": "How much the bump map affects the material. Typical range is [0,1]."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the material."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "displacementBias": {
          "!type": "number",
          "!doc": "The offset of the displacement map's values on the mesh's vertices. The bias is added to the scaled sample of the displacement map. Without a displacement map set, this value is not applied."
        },
        "displacementMap": {
          "!type": "+THREE.Texture",
          "!doc": "The displacement map affects the position of the mesh's vertices. Unlike other maps which only affect the light and shade of the material the displaced vertices can cast shadows, block other objects, and otherwise act as real geometry. The displacement texture is an image where the value of each pixel (white being the highest) is mapped against, and repositions, the vertices of the mesh."
        },
        "displacementScale": {
          "!type": "number",
          "!doc": "How much the displacement map affects the mesh (where black is no displacement, and white is maximum displacement). Without a displacement map set, this value is not applied."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "flatShading": {
          "!type": "bool",
          "!doc": "Whether the material is rendered with flat shading or not."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether the material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "The color map. May optionally include an alpha channel, typically combined with Material or Material. The texture map color is modulated by the diffuse color."
        },
        "matcap": {
          "!type": "+THREE.Texture",
          "!doc": "The matcap map."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a normal map. The RGB values affect the surface normal for each pixel fragment and change the way the color is lit. Normal maps do not change the actual shape of the surface, only the lighting. In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness."
        },
        "normalMapType": {
          "!type": "+THREE.TangentSpaceNormalMap",
          "!doc": "The type of normal map."
        },
        "normalScale": {
          "!type": "+THREE.Vector2",
          "!doc": "How much the normal map affects the material. Typical value range is [0,1]."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Renders the geometry as a wireframe."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls the thickness of the wireframe. Can only be used with SVGRenderer."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new mesh matcap material.",
      "!type": "fn(parameters: object)"
    },
    "MeshMatcapNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshMatcapNodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Whether this material is affected by lights or not."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the environment node from the material."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightingModel",
          "!doc": "This method should be implemented by most derived materials since it defines the material's lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the matcap specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new mesh normal node material.",
      "!type": "fn(parameters: object)"
    },
    "MeshNormalMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshNormalMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "bumpMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a bump map. The black and white values map to the perceived depth in relation to the lights. Bump doesn't actually affect the geometry of the object, only the lighting. If a normal map is defined this will be ignored."
        },
        "bumpScale": {
          "!type": "number",
          "!doc": "How much the bump map affects the material. Typical range is [0,1]."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "displacementBias": {
          "!type": "number",
          "!doc": "The offset of the displacement map's values on the mesh's vertices. The bias is added to the scaled sample of the displacement map. Without a displacement map set, this value is not applied."
        },
        "displacementMap": {
          "!type": "+THREE.Texture",
          "!doc": "The displacement map affects the position of the mesh's vertices. Unlike other maps which only affect the light and shade of the material the displaced vertices can cast shadows, block other objects, and otherwise act as real geometry. The displacement texture is an image where the value of each pixel (white being the highest) is mapped against, and repositions, the vertices of the mesh."
        },
        "displacementScale": {
          "!type": "number",
          "!doc": "How much the displacement map affects the mesh (where black is no displacement, and white is maximum displacement). Without a displacement map set, this value is not applied."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "flatShading": {
          "!type": "bool",
          "!doc": "Whether the material is rendered with flat shading or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a normal map. The RGB values affect the surface normal for each pixel fragment and change the way the color is lit. Normal maps do not change the actual shape of the surface, only the lighting. In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness."
        },
        "normalMapType": {
          "!type": "+THREE.TangentSpaceNormalMap",
          "!doc": "The type of normal map."
        },
        "normalScale": {
          "!type": "+THREE.Vector2",
          "!doc": "How much the normal map affects the material. Typical value range is [0,1]."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Renders the geometry as a wireframe."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls the thickness of the wireframe. WebGL and WebGPU ignore this property and always render 1 pixel wide lines."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new mesh normal material.",
      "!type": "fn(parameters: object)"
    },
    "MeshNormalNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshNormalNodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Whether this material is affected by lights or not."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn()",
          "!doc": "Overwrites the default implementation by computing the diffuse color based on the normal data."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the environment node from the material."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightingModel",
          "!doc": "This method should be implemented by most derived materials since it defines the material's lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Abstract interface method that can be implemented by derived materials to setup material-specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new mesh normal node material.",
      "!type": "fn(parameters: object)"
    },
    "MeshPhongMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshPhongMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoMap": {
          "!type": "+THREE.Texture",
          "!doc": "The red channel of this texture is used as the ambient occlusion map. Requires a second set of UVs."
        },
        "aoMapIntensity": {
          "!type": "number",
          "!doc": "Intensity of the ambient occlusion effect. Range is [0,1], where 0 disables ambient occlusion. Where intensity is 1 and the AO map's red channel is also 1, ambient light is fully occluded on a surface."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "bumpMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a bump map. The black and white values map to the perceived depth in relation to the lights. Bump doesn't actually affect the geometry of the object, only the lighting. If a normal map is defined this will be ignored."
        },
        "bumpScale": {
          "!type": "number",
          "!doc": "How much the bump map affects the material. Typical range is [0,1]."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the material."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "combine": {
          "!type": "+THREE.MultiplyOperation",
          "!doc": "How to combine the result of the surface's color with the environment map, if any. When set to MixOperation, the MeshBasicMaterial is used to blend between the two colors."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "displacementBias": {
          "!type": "number",
          "!doc": "The offset of the displacement map's values on the mesh's vertices. The bias is added to the scaled sample of the displacement map. Without a displacement map set, this value is not applied."
        },
        "displacementMap": {
          "!type": "+THREE.Texture",
          "!doc": "The displacement map affects the position of the mesh's vertices. Unlike other maps which only affect the light and shade of the material the displaced vertices can cast shadows, block other objects, and otherwise act as real geometry. The displacement texture is an image where the value of each pixel (white being the highest) is mapped against, and repositions, the vertices of the mesh."
        },
        "displacementScale": {
          "!type": "number",
          "!doc": "How much the displacement map affects the mesh (where black is no displacement, and white is maximum displacement). Without a displacement map set, this value is not applied."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "emissive": {
          "!type": "+THREE.Color",
          "!doc": "Emissive (light) color of the material, essentially a solid color unaffected by other lighting."
        },
        "emissiveIntensity": {
          "!type": "number",
          "!doc": "Intensity of the emissive light. Modulates the emissive color."
        },
        "emissiveMap": {
          "!type": "+THREE.Texture",
          "!doc": "Set emissive (glow) map. The emissive map color is modulated by the emissive color and the emissive intensity. If you have an emissive map, be sure to set the emissive color to something other than black."
        },
        "envMap": {
          "!type": "+THREE.Texture",
          "!doc": "The environment map."
        },
        "envMapIntensity": {
          "!type": "number",
          "!doc": "Scales the effect of the environment map by multiplying its color."
        },
        "envMapRotation": {
          "!type": "+THREE.Euler",
          "!doc": "The rotation of the environment map in radians."
        },
        "flatShading": {
          "!type": "bool",
          "!doc": "Whether the material is rendered with flat shading or not."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether the material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lightMap": {
          "!type": "+THREE.Texture",
          "!doc": "The light map. Requires a second set of UVs."
        },
        "lightMapIntensity": {
          "!type": "number",
          "!doc": "Intensity of the baked light."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "The color map. May optionally include an alpha channel, typically combined with Material or Material. The texture map color is modulated by the diffuse color."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a normal map. The RGB values affect the surface normal for each pixel fragment and change the way the color is lit. Normal maps do not change the actual shape of the surface, only the lighting. In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness."
        },
        "normalMapType": {
          "!type": "+THREE.TangentSpaceNormalMap",
          "!doc": "The type of normal map."
        },
        "normalScale": {
          "!type": "+THREE.Vector2",
          "!doc": "How much the normal map affects the material. Typical value range is [0,1]."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "reflectivity": {
          "!type": "number",
          "!doc": "How much the environment map affects the surface. The valid range is between 0 (no reflections) and 1 (full reflections)."
        },
        "refractionRatio": {
          "!type": "number",
          "!doc": "The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping modes CubeRefractionMapping and EquirectangularRefractionMapping. The refraction ratio should not exceed 1."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "shininess": {
          "!type": "number",
          "!doc": "How shiny the specular highlight is; a higher value gives a sharper highlight."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "specular": {
          "!type": "+THREE.Color",
          "!doc": "Specular color of the material. The default color is set to 0x111111 (very dark grey) This defines how shiny the material is and the color of its shine."
        },
        "specularMap": {
          "!type": "+THREE.Texture",
          "!doc": "The specular map value affects both how much the specular surface highlight contributes and how much of the environment map affects the surface."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Renders the geometry as a wireframe."
        },
        "wireframeLinecap": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of wireframe ends. Can only be used with SVGRenderer."
        },
        "wireframeLinejoin": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of wireframe joints. Can only be used with SVGRenderer."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls the thickness of the wireframe. Can only be used with SVGRenderer."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new mesh phong material.",
      "!type": "fn(parameters: object)"
    },
    "MeshPhongNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshPhongNodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Set to true because phong materials react on lights."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "shininessNode": {
          "!doc": "The shininess of phong materials is by default inferred from the shininess property. This node property allows to overwrite the default and define the shininess with a node instead. If you don't want to overwrite the shininess but modify the existing value instead, use materialShininess."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "specularNode": {
          "!doc": "The specular color of phong materials is by default inferred from the specular property. This node property allows to overwrite the default and define the specular color with a node instead. If you don't want to overwrite the specular color but modify the existing value instead, use materialSpecular."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Overwritten since this type of material uses BasicEnvironmentNode to implement the default environment mapping."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn() -> +THREE.PhongLightingModel",
          "!doc": "Setups the lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the phong specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new mesh lambert node material.",
      "!type": "fn(parameters: object)"
    },
    "MeshPhysicalMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshPhysicalMaterial",
      "prototype": {
        "!proto": "THREE.MeshStandardMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "anisotropy": {
          "!type": "number",
          "!doc": "The anisotropy strength, from 0.0 to 1.0."
        },
        "anisotropyMap": {
          "!type": "+THREE.Texture",
          "!doc": "Red and green channels represent the anisotropy direction in [-1, 1] tangent, bitangent space, to be rotated by anisotropyRotation. The blue channel contains strength as [0, 1] to be multiplied by anisotropy."
        },
        "anisotropyRotation": {
          "!type": "number",
          "!doc": "The rotation of the anisotropy in tangent, bitangent space, measured in radians counter-clockwise from the tangent. When anisotropyMap is present, this property provides additional rotation to the vectors in the texture."
        },
        "aoMap": {
          "!type": "+THREE.Texture",
          "!doc": "The red channel of this texture is used as the ambient occlusion map. Requires a second set of UVs."
        },
        "aoMapIntensity": {
          "!type": "number",
          "!doc": "Intensity of the ambient occlusion effect. Range is [0,1], where 0 disables ambient occlusion. Where intensity is 1 and the AO map's red channel is also 1, ambient light is fully occluded on a surface."
        },
        "attenuationColor": {
          "!type": "+THREE.Color",
          "!doc": "The color that white light turns into due to absorption when reaching the attenuation distance."
        },
        "attenuationDistance": {
          "!type": "number",
          "!doc": "Density of the medium given as the average distance that light travels in the medium before interacting with a particle. The value is given in world space units, and must be greater than zero."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "bumpMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a bump map. The black and white values map to the perceived depth in relation to the lights. Bump doesn't actually affect the geometry of the object, only the lighting. If a normal map is defined this will be ignored."
        },
        "bumpScale": {
          "!type": "number",
          "!doc": "How much the bump map affects the material. Typical range is [0,1]."
        },
        "clearcoat": {
          "!type": "number",
          "!doc": "Represents the intensity of the clear coat layer, from 0.0 to 1.0. Use clear coat related properties to enable multilayer materials that have a thin translucent layer over the base layer."
        },
        "clearcoatMap": {
          "!type": "+THREE.Texture",
          "!doc": "The red channel of this texture is multiplied against clearcoat, for per-pixel control over a coating's intensity."
        },
        "clearcoatNormalMap": {
          "!type": "+THREE.Texture",
          "!doc": "Can be used to enable independent normals for the clear coat layer."
        },
        "clearcoatNormalScale": {
          "!type": "+THREE.Vector2",
          "!doc": "How much clearcoatNormalMap affects the clear coat layer, from (0,0) to (1,1)."
        },
        "clearcoatRoughness": {
          "!type": "number",
          "!doc": "Roughness of the clear coat layer, from 0.0 to 1.0."
        },
        "clearcoatRoughnessMap": {
          "!type": "+THREE.Texture",
          "!doc": "The green channel of this texture is multiplied against clearcoatRoughness, for per-pixel control over a coating's roughness."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the material."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dispersion": {
          "!type": "number",
          "!doc": "Defines the strength of the angular separation of colors (chromatic aberration) transmitting through a relatively clear volume. Any value zero or larger is valid, the typical range of realistic values is [0, 1]. This property can be only be used with transmissive objects."
        },
        "displacementBias": {
          "!type": "number",
          "!doc": "The offset of the displacement map's values on the mesh's vertices. The bias is added to the scaled sample of the displacement map. Without a displacement map set, this value is not applied."
        },
        "displacementMap": {
          "!type": "+THREE.Texture",
          "!doc": "The displacement map affects the position of the mesh's vertices. Unlike other maps which only affect the light and shade of the material the displaced vertices can cast shadows, block other objects, and otherwise act as real geometry. The displacement texture is an image where the value of each pixel (white being the highest) is mapped against, and repositions, the vertices of the mesh."
        },
        "displacementScale": {
          "!type": "number",
          "!doc": "How much the displacement map affects the mesh (where black is no displacement, and white is maximum displacement). Without a displacement map set, this value is not applied."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "emissive": {
          "!type": "+THREE.Color",
          "!doc": "Emissive (light) color of the material, essentially a solid color unaffected by other lighting."
        },
        "emissiveIntensity": {
          "!type": "number",
          "!doc": "Intensity of the emissive light. Modulates the emissive color."
        },
        "emissiveMap": {
          "!type": "+THREE.Texture",
          "!doc": "Set emissive (glow) map. The emissive map color is modulated by the emissive color and the emissive intensity. If you have an emissive map, be sure to set the emissive color to something other than black."
        },
        "envMap": {
          "!type": "+THREE.Texture",
          "!doc": "The environment map. To ensure a physically correct rendering, environment maps are internally pre-processed with PMREMGenerator."
        },
        "envMapIntensity": {
          "!type": "number",
          "!doc": "Scales the effect of the environment map by multiplying its color."
        },
        "envMapRotation": {
          "!type": "+THREE.Euler",
          "!doc": "The rotation of the environment map in radians."
        },
        "flatShading": {
          "!type": "bool",
          "!doc": "Whether the material is rendered with flat shading or not."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether the material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "ior": {
          "!type": "number",
          "!doc": "Index-of-refraction for non-metallic materials, from 1.0 to 2.333."
        },
        "iridescence": {
          "!type": "number",
          "!doc": "The intensity of the iridescence layer, simulating RGB color shift based on the angle between the surface and the viewer, from 0.0 to 1.0."
        },
        "iridescenceIOR": {
          "!type": "number",
          "!doc": "Strength of the iridescence RGB color shift effect, represented by an index-of-refraction. Between 1.0 to 2.333."
        },
        "iridescenceMap": {
          "!type": "+THREE.Texture",
          "!doc": "The red channel of this texture is multiplied against iridescence, for per-pixel control over iridescence."
        },
        "iridescenceThicknessMap": {
          "!type": "+THREE.Texture",
          "!doc": "A texture that defines the thickness of the iridescence layer, stored in the green channel. Minimum and maximum values of thickness are defined by iridescenceThicknessRange array: - 0.0 in the green channel will result in thickness equal to first element of the array. - 1.0 in the green channel will result in thickness equal to second element of the array. - Values in-between will linearly interpolate between the elements of the array."
        },
        "iridescenceThicknessRange": {
          "!doc": "Array of exactly 2 elements, specifying minimum and maximum thickness of the iridescence layer. Thickness of iridescence layer has an equivalent effect of the one thickness has on ior."
        },
        "lightMap": {
          "!type": "+THREE.Texture",
          "!doc": "The light map. Requires a second set of UVs."
        },
        "lightMapIntensity": {
          "!type": "number",
          "!doc": "Intensity of the baked light."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "The color map. May optionally include an alpha channel, typically combined with Material or Material. The texture map color is modulated by the diffuse color."
        },
        "metalness": {
          "!type": "number",
          "!doc": "How much the material is like a metal. Non-metallic materials such as wood or stone use 0.0, metallic use 1.0, with nothing (usually) in between. A value between 0.0 and 1.0 could be used for a rusty metal look. If metalnessMap is also provided, both values are multiplied."
        },
        "metalnessMap": {
          "!type": "+THREE.Texture",
          "!doc": "The blue channel of this texture is used to alter the metalness of the material."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a normal map. The RGB values affect the surface normal for each pixel fragment and change the way the color is lit. Normal maps do not change the actual shape of the surface, only the lighting. In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness."
        },
        "normalMapType": {
          "!type": "+THREE.TangentSpaceNormalMap",
          "!doc": "The type of normal map."
        },
        "normalScale": {
          "!type": "+THREE.Vector2",
          "!doc": "How much the normal map affects the material. Typical value range is [0,1]."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "reflectivity": {
          "!type": "number",
          "!doc": "Degree of reflectivity, from 0.0 to 1.0. Default is 0.5, which corresponds to an index-of-refraction of 1.5. This models the reflectivity of non-metallic materials. It has no effect when metalness is 1.0"
        },
        "roughness": {
          "!type": "number",
          "!doc": "How rough the material appears. 0.0 means a smooth mirror reflection, 1.0 means fully diffuse. If roughnessMap is also provided, both values are multiplied."
        },
        "roughnessMap": {
          "!type": "+THREE.Texture",
          "!doc": "The green channel of this texture is used to alter the roughness of the material."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "sheen": {
          "!type": "number",
          "!doc": "The intensity of the sheen layer, from 0.0 to 1.0."
        },
        "sheenColor": {
          "!type": "+THREE.Color",
          "!doc": "The sheen tint."
        },
        "sheenColorMap": {
          "!type": "+THREE.Texture",
          "!doc": "The RGB channels of this texture are multiplied against sheenColor, for per-pixel control over sheen tint."
        },
        "sheenRoughness": {
          "!type": "number",
          "!doc": "Roughness of the sheen layer, from 0.0 to 1.0."
        },
        "sheenRoughnessMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha channel of this texture is multiplied against sheenRoughness, for per-pixel control over sheen roughness."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "specularColor": {
          "!type": "+THREE.Color",
          "!doc": "Tints the specular reflection at normal incidence for non-metals only."
        },
        "specularColorMap": {
          "!type": "+THREE.Texture",
          "!doc": "The RGB channels of this texture are multiplied against specularColor, for per-pixel control over specular color."
        },
        "specularIntensity": {
          "!type": "number",
          "!doc": "A float that scales the amount of specular reflection for non-metals only. When set to zero, the model is effectively Lambertian. From 0.0 to 1.0."
        },
        "specularIntensityMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha channel of this texture is multiplied against specularIntensity, for per-pixel control over specular intensity."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "thickness": {
          "!type": "number",
          "!doc": "The thickness of the volume beneath the surface. The value is given in the coordinate space of the mesh. If the value is 0 the material is thin-walled. Otherwise the material is a volume boundary."
        },
        "thicknessMap": {
          "!type": "+THREE.Texture",
          "!doc": "A texture that defines the thickness, stored in the green channel. This will be multiplied by thickness."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transmission": {
          "!type": "number",
          "!doc": "Degree of transmission (or optical transparency), from 0.0 to 1.0. Thin, transparent or semitransparent, plastic or glass materials remain largely reflective even if they are fully transmissive. The transmission property can be used to model these materials. When transmission is non-zero, opacity should be set to 1."
        },
        "transmissionMap": {
          "!type": "+THREE.Texture",
          "!doc": "The red channel of this texture is multiplied against transmission, for per-pixel control over optical transparency."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Renders the geometry as a wireframe."
        },
        "wireframeLinecap": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of wireframe ends. Can only be used with SVGRenderer."
        },
        "wireframeLinejoin": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of wireframe joints. Can only be used with SVGRenderer."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls the thickness of the wireframe. Can only be used with SVGRenderer."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new mesh physical material.",
      "!type": "fn(parameters: object)"
    },
    "MeshPhysicalNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshPhysicalNodeMaterial",
      "prototype": {
        "!proto": "THREE.MeshStandardNodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "anisotropyNode": {
          "!doc": "The anisotropy of physical materials is by default inferred from the anisotropy property. This node property allows to overwrite the default and define the anisotropy with a node instead. If you don't want to overwrite the anisotropy but modify the existing value instead, use materialAnisotropy."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "attenuationColorNode": {
          "!doc": "The attenuation color of physical materials is by default inferred from the attenuationColor property. This node property allows to overwrite the default and define the attenuation color with a node instead. If you don't want to overwrite the attenuation color but modify the existing value instead, use materialAttenuationColor."
        },
        "attenuationDistanceNode": {
          "!doc": "The attenuation distance of physical materials is by default inferred from the attenuationDistance property. This node property allows to overwrite the default and define the attenuation distance with a node instead. If you don't want to overwrite the attenuation distance but modify the existing value instead, use materialAttenuationDistance."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clearcoatNode": {
          "!doc": "The clearcoat of physical materials is by default inferred from the clearcoat and clearcoatMap properties. This node property allows to overwrite the default and define the clearcoat with a node instead. If you don't want to overwrite the clearcoat but modify the existing value instead, use materialClearcoat."
        },
        "clearcoatNormalNode": {
          "!doc": "The clearcoat normal of physical materials is by default inferred from the clearcoatNormalMap property. This node property allows to overwrite the default and define the clearcoat normal with a node instead. If you don't want to overwrite the clearcoat normal but modify the existing value instead, use materialClearcoatNormal."
        },
        "clearcoatRoughnessNode": {
          "!doc": "The clearcoat roughness of physical materials is by default inferred from the clearcoatRoughness and clearcoatRoughnessMap properties. This node property allows to overwrite the default and define the clearcoat roughness with a node instead. If you don't want to overwrite the clearcoat roughness but modify the existing value instead, use materialClearcoatRoughness."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dispersionNode": {
          "!doc": "The dispersion of physical materials is by default inferred from the dispersion property. This node property allows to overwrite the default and define the dispersion with a node instead. If you don't want to overwrite the dispersion but modify the existing value instead, use materialDispersion."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "emissiveNode": {
          "!doc": "The emissive color of standard materials is by default inferred from the emissive, emissiveIntensity and emissiveMap properties. This node property allows to overwrite the default and define the emissive color with a node instead. If you don't want to overwrite the emissive color but modify the existing value instead, use materialEmissive."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "iorNode": {
          "!doc": "The ior of physical materials is by default inferred from the ior property. This node property allows to overwrite the default and define the ior with a node instead. If you don't want to overwrite the ior but modify the existing value instead, use materialIOR."
        },
        "iridescenceIORNode": {
          "!doc": "The iridescence IOR of physical materials is by default inferred from the iridescenceIOR property. This node property allows to overwrite the default and define the iridescence IOR with a node instead. If you don't want to overwrite the iridescence IOR but modify the existing value instead, use materialIridescenceIOR."
        },
        "iridescenceNode": {
          "!doc": "The iridescence of physical materials is by default inferred from the iridescence property. This node property allows to overwrite the default and define the iridescence with a node instead. If you don't want to overwrite the iridescence but modify the existing value instead, use materialIridescence."
        },
        "iridescenceThicknessNode": {
          "!doc": "The iridescence thickness of physical materials is by default inferred from the iridescenceThicknessRange and iridescenceThicknessMap properties. This node property allows to overwrite the default and define the iridescence thickness with a node instead. If you don't want to overwrite the iridescence thickness but modify the existing value instead, use materialIridescenceThickness."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Set to true because standard materials react on lights."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "metalnessNode": {
          "!doc": "The metalness of standard materials is by default inferred from the metalness, and metalnessMap properties. This node property allows to overwrite the default and define the metalness with a node instead. If you don't want to overwrite the metalness but modify the existing value instead, use materialMetalness."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "roughnessNode": {
          "!doc": "The roughness of standard materials is by default inferred from the roughness, and roughnessMap properties. This node property allows to overwrite the default and define the roughness with a node instead. If you don't want to overwrite the roughness but modify the existing value instead, use materialRoughness."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "sheenNode": {
          "!doc": "The sheen of physical materials is by default inferred from the sheen, sheenColor and sheenColorMap properties. This node property allows to overwrite the default and define the sheen with a node instead. If you don't want to overwrite the sheen but modify the existing value instead, use materialSheen."
        },
        "sheenRoughnessNode": {
          "!doc": "The sheen roughness of physical materials is by default inferred from the sheenRoughness and sheenRoughnessMap properties. This node property allows to overwrite the default and define the sheen roughness with a node instead. If you don't want to overwrite the sheen roughness but modify the existing value instead, use materialSheenRoughness."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "specularColorNode": {
          "!doc": "The specular color of physical materials is by default inferred from the specularColor and specularColorMap properties. This node property allows to overwrite the default and define the specular color with a node instead. If you don't want to overwrite the specular color but modify the existing value instead, use materialSpecularColor."
        },
        "specularIntensityNode": {
          "!doc": "The specular intensity of physical materials is by default inferred from the specularIntensity and specularIntensityMap properties. This node property allows to overwrite the default and define the specular intensity with a node instead. If you don't want to overwrite the specular intensity but modify the existing value instead, use materialSpecularIntensity."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "thicknessNode": {
          "!doc": "The thickness of physical materials is by default inferred from the thickness and thicknessMap properties. This node property allows to overwrite the default and define the thickness with a node instead. If you don't want to overwrite the thickness but modify the existing value instead, use materialThickness."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transmissionNode": {
          "!doc": "The transmission of physical materials is by default inferred from the transmission and transmissionMap properties. This node property allows to overwrite the default and define the transmission with a node instead. If you don't want to overwrite the transmission but modify the existing value instead, use materialTransmission."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "useAnisotropy": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use anisotropy or not."
        },
        "useClearcoat": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use clearcoat or not."
        },
        "useDispersion": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use dispersion or not."
        },
        "useIridescence": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use iridescence or not."
        },
        "useSheen": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use sheen or not."
        },
        "useTransmission": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use transmission or not."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClearcoatNormal": {
          "!type": "fn()",
          "!doc": "Setups the clearcoat normal node."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Overwritten since this type of material uses EnvironmentNode to implement the PBR (PMREM based) environment mapping. Besides, the method honors Scene.environment."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn() -> +THREE.PhysicalLightingModel",
          "!doc": "Setups the lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupSpecular": {
          "!type": "fn()",
          "!doc": "Setups the specular related node variables."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the physical specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new mesh physical node material.",
      "!type": "fn(parameters: object)"
    },
    "MeshSSSNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshSSSNodeMaterial",
      "prototype": {
        "!proto": "THREE.MeshPhysicalNodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "anisotropyNode": {
          "!doc": "The anisotropy of physical materials is by default inferred from the anisotropy property. This node property allows to overwrite the default and define the anisotropy with a node instead. If you don't want to overwrite the anisotropy but modify the existing value instead, use materialAnisotropy."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "attenuationColorNode": {
          "!doc": "The attenuation color of physical materials is by default inferred from the attenuationColor property. This node property allows to overwrite the default and define the attenuation color with a node instead. If you don't want to overwrite the attenuation color but modify the existing value instead, use materialAttenuationColor."
        },
        "attenuationDistanceNode": {
          "!doc": "The attenuation distance of physical materials is by default inferred from the attenuationDistance property. This node property allows to overwrite the default and define the attenuation distance with a node instead. If you don't want to overwrite the attenuation distance but modify the existing value instead, use materialAttenuationDistance."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clearcoatNode": {
          "!doc": "The clearcoat of physical materials is by default inferred from the clearcoat and clearcoatMap properties. This node property allows to overwrite the default and define the clearcoat with a node instead. If you don't want to overwrite the clearcoat but modify the existing value instead, use materialClearcoat."
        },
        "clearcoatNormalNode": {
          "!doc": "The clearcoat normal of physical materials is by default inferred from the clearcoatNormalMap property. This node property allows to overwrite the default and define the clearcoat normal with a node instead. If you don't want to overwrite the clearcoat normal but modify the existing value instead, use materialClearcoatNormal."
        },
        "clearcoatRoughnessNode": {
          "!doc": "The clearcoat roughness of physical materials is by default inferred from the clearcoatRoughness and clearcoatRoughnessMap properties. This node property allows to overwrite the default and define the clearcoat roughness with a node instead. If you don't want to overwrite the clearcoat roughness but modify the existing value instead, use materialClearcoatRoughness."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dispersionNode": {
          "!doc": "The dispersion of physical materials is by default inferred from the dispersion property. This node property allows to overwrite the default and define the dispersion with a node instead. If you don't want to overwrite the dispersion but modify the existing value instead, use materialDispersion."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "emissiveNode": {
          "!doc": "The emissive color of standard materials is by default inferred from the emissive, emissiveIntensity and emissiveMap properties. This node property allows to overwrite the default and define the emissive color with a node instead. If you don't want to overwrite the emissive color but modify the existing value instead, use materialEmissive."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "iorNode": {
          "!doc": "The ior of physical materials is by default inferred from the ior property. This node property allows to overwrite the default and define the ior with a node instead. If you don't want to overwrite the ior but modify the existing value instead, use materialIOR."
        },
        "iridescenceIORNode": {
          "!doc": "The iridescence IOR of physical materials is by default inferred from the iridescenceIOR property. This node property allows to overwrite the default and define the iridescence IOR with a node instead. If you don't want to overwrite the iridescence IOR but modify the existing value instead, use materialIridescenceIOR."
        },
        "iridescenceNode": {
          "!doc": "The iridescence of physical materials is by default inferred from the iridescence property. This node property allows to overwrite the default and define the iridescence with a node instead. If you don't want to overwrite the iridescence but modify the existing value instead, use materialIridescence."
        },
        "iridescenceThicknessNode": {
          "!doc": "The iridescence thickness of physical materials is by default inferred from the iridescenceThicknessRange and iridescenceThicknessMap properties. This node property allows to overwrite the default and define the iridescence thickness with a node instead. If you don't want to overwrite the iridescence thickness but modify the existing value instead, use materialIridescenceThickness."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Set to true because standard materials react on lights."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "metalnessNode": {
          "!doc": "The metalness of standard materials is by default inferred from the metalness, and metalnessMap properties. This node property allows to overwrite the default and define the metalness with a node instead. If you don't want to overwrite the metalness but modify the existing value instead, use materialMetalness."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "roughnessNode": {
          "!doc": "The roughness of standard materials is by default inferred from the roughness, and roughnessMap properties. This node property allows to overwrite the default and define the roughness with a node instead. If you don't want to overwrite the roughness but modify the existing value instead, use materialRoughness."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "sheenNode": {
          "!doc": "The sheen of physical materials is by default inferred from the sheen, sheenColor and sheenColorMap properties. This node property allows to overwrite the default and define the sheen with a node instead. If you don't want to overwrite the sheen but modify the existing value instead, use materialSheen."
        },
        "sheenRoughnessNode": {
          "!doc": "The sheen roughness of physical materials is by default inferred from the sheenRoughness and sheenRoughnessMap properties. This node property allows to overwrite the default and define the sheen roughness with a node instead. If you don't want to overwrite the sheen roughness but modify the existing value instead, use materialSheenRoughness."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "specularColorNode": {
          "!doc": "The specular color of physical materials is by default inferred from the specularColor and specularColorMap properties. This node property allows to overwrite the default and define the specular color with a node instead. If you don't want to overwrite the specular color but modify the existing value instead, use materialSpecularColor."
        },
        "specularIntensityNode": {
          "!doc": "The specular intensity of physical materials is by default inferred from the specularIntensity and specularIntensityMap properties. This node property allows to overwrite the default and define the specular intensity with a node instead. If you don't want to overwrite the specular intensity but modify the existing value instead, use materialSpecularIntensity."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "thicknessAmbientNode": {
          "!doc": "Represents the thickness ambient factor."
        },
        "thicknessAttenuationNode": {
          "!doc": "Represents the thickness attenuation."
        },
        "thicknessColorNode": {
          "!doc": "Represents the thickness color."
        },
        "thicknessDistortionNode": {
          "!doc": "Represents the distortion factor."
        },
        "thicknessNode": {
          "!doc": "The thickness of physical materials is by default inferred from the thickness and thicknessMap properties. This node property allows to overwrite the default and define the thickness with a node instead. If you don't want to overwrite the thickness but modify the existing value instead, use materialThickness."
        },
        "thicknessPowerNode": {
          "!doc": "Represents the thickness power."
        },
        "thicknessScaleNode": {
          "!doc": "Represents the thickness scale."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transmissionNode": {
          "!doc": "The transmission of physical materials is by default inferred from the transmission and transmissionMap properties. This node property allows to overwrite the default and define the transmission with a node instead. If you don't want to overwrite the transmission but modify the existing value instead, use materialTransmission."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "useAnisotropy": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use anisotropy or not."
        },
        "useClearcoat": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use clearcoat or not."
        },
        "useDispersion": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use dispersion or not."
        },
        "useIridescence": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use iridescence or not."
        },
        "useSSS": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use SSS or not."
        },
        "useSheen": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use sheen or not."
        },
        "useTransmission": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use transmission or not."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClearcoatNormal": {
          "!type": "fn()",
          "!doc": "Setups the clearcoat normal node."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Overwritten since this type of material uses EnvironmentNode to implement the PBR (PMREM based) environment mapping. Besides, the method honors Scene.environment."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn() -> +THREE.SSSLightingModel",
          "!doc": "Setups the lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupSpecular": {
          "!type": "fn()",
          "!doc": "Setups the specular related node variables."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the physical specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new mesh SSS node material.",
      "!type": "fn(parameters: object)"
    },
    "MeshStandardMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshStandardMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoMap": {
          "!type": "+THREE.Texture",
          "!doc": "The red channel of this texture is used as the ambient occlusion map. Requires a second set of UVs."
        },
        "aoMapIntensity": {
          "!type": "number",
          "!doc": "Intensity of the ambient occlusion effect. Range is [0,1], where 0 disables ambient occlusion. Where intensity is 1 and the AO map's red channel is also 1, ambient light is fully occluded on a surface."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "bumpMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a bump map. The black and white values map to the perceived depth in relation to the lights. Bump doesn't actually affect the geometry of the object, only the lighting. If a normal map is defined this will be ignored."
        },
        "bumpScale": {
          "!type": "number",
          "!doc": "How much the bump map affects the material. Typical range is [0,1]."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the material."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "displacementBias": {
          "!type": "number",
          "!doc": "The offset of the displacement map's values on the mesh's vertices. The bias is added to the scaled sample of the displacement map. Without a displacement map set, this value is not applied."
        },
        "displacementMap": {
          "!type": "+THREE.Texture",
          "!doc": "The displacement map affects the position of the mesh's vertices. Unlike other maps which only affect the light and shade of the material the displaced vertices can cast shadows, block other objects, and otherwise act as real geometry. The displacement texture is an image where the value of each pixel (white being the highest) is mapped against, and repositions, the vertices of the mesh."
        },
        "displacementScale": {
          "!type": "number",
          "!doc": "How much the displacement map affects the mesh (where black is no displacement, and white is maximum displacement). Without a displacement map set, this value is not applied."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "emissive": {
          "!type": "+THREE.Color",
          "!doc": "Emissive (light) color of the material, essentially a solid color unaffected by other lighting."
        },
        "emissiveIntensity": {
          "!type": "number",
          "!doc": "Intensity of the emissive light. Modulates the emissive color."
        },
        "emissiveMap": {
          "!type": "+THREE.Texture",
          "!doc": "Set emissive (glow) map. The emissive map color is modulated by the emissive color and the emissive intensity. If you have an emissive map, be sure to set the emissive color to something other than black."
        },
        "envMap": {
          "!type": "+THREE.Texture",
          "!doc": "The environment map. To ensure a physically correct rendering, environment maps are internally pre-processed with PMREMGenerator."
        },
        "envMapIntensity": {
          "!type": "number",
          "!doc": "Scales the effect of the environment map by multiplying its color."
        },
        "envMapRotation": {
          "!type": "+THREE.Euler",
          "!doc": "The rotation of the environment map in radians."
        },
        "flatShading": {
          "!type": "bool",
          "!doc": "Whether the material is rendered with flat shading or not."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether the material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lightMap": {
          "!type": "+THREE.Texture",
          "!doc": "The light map. Requires a second set of UVs."
        },
        "lightMapIntensity": {
          "!type": "number",
          "!doc": "Intensity of the baked light."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "The color map. May optionally include an alpha channel, typically combined with Material or Material. The texture map color is modulated by the diffuse color."
        },
        "metalness": {
          "!type": "number",
          "!doc": "How much the material is like a metal. Non-metallic materials such as wood or stone use 0.0, metallic use 1.0, with nothing (usually) in between. A value between 0.0 and 1.0 could be used for a rusty metal look. If metalnessMap is also provided, both values are multiplied."
        },
        "metalnessMap": {
          "!type": "+THREE.Texture",
          "!doc": "The blue channel of this texture is used to alter the metalness of the material."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a normal map. The RGB values affect the surface normal for each pixel fragment and change the way the color is lit. Normal maps do not change the actual shape of the surface, only the lighting. In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness."
        },
        "normalMapType": {
          "!type": "+THREE.TangentSpaceNormalMap",
          "!doc": "The type of normal map."
        },
        "normalScale": {
          "!type": "+THREE.Vector2",
          "!doc": "How much the normal map affects the material. Typical value range is [0,1]."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "roughness": {
          "!type": "number",
          "!doc": "How rough the material appears. 0.0 means a smooth mirror reflection, 1.0 means fully diffuse. If roughnessMap is also provided, both values are multiplied."
        },
        "roughnessMap": {
          "!type": "+THREE.Texture",
          "!doc": "The green channel of this texture is used to alter the roughness of the material."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Renders the geometry as a wireframe."
        },
        "wireframeLinecap": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of wireframe ends. Can only be used with SVGRenderer."
        },
        "wireframeLinejoin": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of wireframe joints. Can only be used with SVGRenderer."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls the thickness of the wireframe. Can only be used with SVGRenderer."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new mesh standard material.",
      "!type": "fn(parameters: object)"
    },
    "MeshStandardNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshStandardNodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "emissiveNode": {
          "!doc": "The emissive color of standard materials is by default inferred from the emissive, emissiveIntensity and emissiveMap properties. This node property allows to overwrite the default and define the emissive color with a node instead. If you don't want to overwrite the emissive color but modify the existing value instead, use materialEmissive."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Set to true because standard materials react on lights."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "metalnessNode": {
          "!doc": "The metalness of standard materials is by default inferred from the metalness, and metalnessMap properties. This node property allows to overwrite the default and define the metalness with a node instead. If you don't want to overwrite the metalness but modify the existing value instead, use materialMetalness."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "roughnessNode": {
          "!doc": "The roughness of standard materials is by default inferred from the roughness, and roughnessMap properties. This node property allows to overwrite the default and define the roughness with a node instead. If you don't want to overwrite the roughness but modify the existing value instead, use materialRoughness."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Overwritten since this type of material uses EnvironmentNode to implement the PBR (PMREM based) environment mapping. Besides, the method honors Scene.environment."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn() -> +THREE.PhysicalLightingModel",
          "!doc": "Setups the lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupSpecular": {
          "!type": "fn()",
          "!doc": "Setups the specular related node variables."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the standard specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new mesh standard node material.",
      "!type": "fn(parameters: object)"
    },
    "MeshToonMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshToonMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoMap": {
          "!type": "+THREE.Texture",
          "!doc": "The red channel of this texture is used as the ambient occlusion map. Requires a second set of UVs."
        },
        "aoMapIntensity": {
          "!type": "number",
          "!doc": "Intensity of the ambient occlusion effect. Range is [0,1], where 0 disables ambient occlusion. Where intensity is 1 and the AO map's red channel is also 1, ambient light is fully occluded on a surface."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "bumpMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a bump map. The black and white values map to the perceived depth in relation to the lights. Bump doesn't actually affect the geometry of the object, only the lighting. If a normal map is defined this will be ignored."
        },
        "bumpScale": {
          "!type": "number",
          "!doc": "How much the bump map affects the material. Typical range is [0,1]."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the material."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "displacementBias": {
          "!type": "number",
          "!doc": "The offset of the displacement map's values on the mesh's vertices. The bias is added to the scaled sample of the displacement map. Without a displacement map set, this value is not applied."
        },
        "displacementMap": {
          "!type": "+THREE.Texture",
          "!doc": "The displacement map affects the position of the mesh's vertices. Unlike other maps which only affect the light and shade of the material the displaced vertices can cast shadows, block other objects, and otherwise act as real geometry. The displacement texture is an image where the value of each pixel (white being the highest) is mapped against, and repositions, the vertices of the mesh."
        },
        "displacementScale": {
          "!type": "number",
          "!doc": "How much the displacement map affects the mesh (where black is no displacement, and white is maximum displacement). Without a displacement map set, this value is not applied."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "emissive": {
          "!type": "+THREE.Color",
          "!doc": "Emissive (light) color of the material, essentially a solid color unaffected by other lighting."
        },
        "emissiveIntensity": {
          "!type": "number",
          "!doc": "Intensity of the emissive light. Modulates the emissive color."
        },
        "emissiveMap": {
          "!type": "+THREE.Texture",
          "!doc": "Set emissive (glow) map. The emissive map color is modulated by the emissive color and the emissive intensity. If you have an emissive map, be sure to set the emissive color to something other than black."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether the material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "gradientMap": {
          "!type": "+THREE.Texture",
          "!doc": "Gradient map for toon shading. It's required to set Texture and Texture to {@linkNearestFilter} when using this type of texture."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lightMap": {
          "!type": "+THREE.Texture",
          "!doc": "The light map. Requires a second set of UVs."
        },
        "lightMapIntensity": {
          "!type": "number",
          "!doc": "Intensity of the baked light."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "The color map. May optionally include an alpha channel, typically combined with Material or Material. The texture map color is modulated by the diffuse color."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalMap": {
          "!type": "+THREE.Texture",
          "!doc": "The texture to create a normal map. The RGB values affect the surface normal for each pixel fragment and change the way the color is lit. Normal maps do not change the actual shape of the surface, only the lighting. In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness."
        },
        "normalMapType": {
          "!type": "+THREE.TangentSpaceNormalMap",
          "!doc": "The type of normal map."
        },
        "normalScale": {
          "!type": "+THREE.Vector2",
          "!doc": "How much the normal map affects the material. Typical value range is [0,1]."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Renders the geometry as a wireframe."
        },
        "wireframeLinecap": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of wireframe ends. Can only be used with SVGRenderer."
        },
        "wireframeLinejoin": {
          "!type": "+THREE.round",
          "!doc": "Defines appearance of wireframe joints. Can only be used with SVGRenderer."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls the thickness of the wireframe. Can only be used with SVGRenderer."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new mesh toon material.",
      "!type": "fn(parameters: object)"
    },
    "MeshToonNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/MeshToonNodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Set to true because toon materials react on lights."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the environment node from the material."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn() -> +THREE.ToonLightingModel",
          "!doc": "Setups the lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Abstract interface method that can be implemented by derived materials to setup material-specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new mesh toon node material.",
      "!type": "fn(parameters: object)"
    },
    "NodeLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/NodeLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "nodes": {
          "!doc": "Represents a dictionary of node types."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "textures": {
          "!doc": "Represents a dictionary of textures."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "createNodeFromType": {
          "!type": "fn(type: string) -> +THREE.Node",
          "!doc": "Creates a node object from the given type."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: fn(), onError: fn())",
          "!doc": "Loads the node definitions from the given URL."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(json: object) -> +THREE.Node",
          "!doc": "Parses the node from the given JSON."
        },
        "parseNodes": {
          "!type": "fn(json)",
          "!doc": "Parse the node dependencies for the loaded node."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setNodes": {
          "!type": "fn(value) -> +THREE.NodeLoader",
          "!doc": "Defines the dictionary of node types."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setTextures": {
          "!type": "fn(value) -> +THREE.NodeLoader",
          "!doc": "Defines the dictionary of textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new node loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "NodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/NodeMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Whether this material is affected by lights or not."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the environment node from the material."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightingModel",
          "!doc": "This method should be implemented by most derived materials since it defines the material's lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Abstract interface method that can be implemented by derived materials to setup material-specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new node material.",
      "!type": "fn()"
    },
    "NodeMaterialLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/NodeMaterialLoader",
      "prototype": {
        "!proto": "THREE.MaterialLoader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "nodeMaterials": {
          "!doc": "Represents a dictionary of node material types."
        },
        "nodes": {
          "!doc": "Represents a dictionary of node types."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "textures": {
          "!doc": "A dictionary holding textures used by the material."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "createMaterialFromType": {
          "!type": "fn(type: string) -> +THREE.Node",
          "!doc": "Creates a node material from the given type."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback)",
          "!doc": "Starts loading from the given URL and pass the loaded material to the onLoad() callback."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(json: object) -> +THREE.NodeMaterial",
          "!doc": "Parses the node material from the given JSON."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setNodeMaterials": {
          "!type": "fn(value) -> +THREE.NodeLoader",
          "!doc": "Defines the dictionary of node material types."
        },
        "setNodes": {
          "!type": "fn(value) -> +THREE.NodeLoader",
          "!doc": "Defines the dictionary of node types."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setTextures": {
          "!type": "fn(value: object) -> +THREE.MaterialLoader",
          "!doc": "Textures are not embedded in the material JSON so they have to be injected before the loading process starts."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new node material loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "NodeMaterialObserver": {
      "!url": "https://threejs.org/docs/#api/en/materials/NodeMaterialObserver",
      "prototype": {
        "hasAnimation": {
          "!type": "bool",
          "!doc": "Whether the node builder's 3D object is animated or not."
        },
        "hasNode": {
          "!type": "bool",
          "!doc": "Whether the material uses node objects or not."
        },
        "refreshUniforms": {
          "!doc": "A list of all possible material uniforms"
        },
        "renderId": {
          "!type": "number",
          "!doc": "Holds the current render ID from the node frame."
        },
        "renderObjects": {
          "!doc": "A node material can be used by more than one render object so the monitor must maintain a list of render objects."
        },
        "containsNode": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> bool",
          "!doc": "Returns true if the node builder's material uses node properties."
        },
        "equals": {
          "!type": "fn(renderObject: +THREE.RenderObject, lightsData) -> bool",
          "!doc": "Returns true if the given render object has not changed its state."
        },
        "firstInitialization": {
          "!type": "fn(renderObject: +THREE.RenderObject) -> bool",
          "!doc": "Returns true if the given render object is verified for the first time of this observer."
        },
        "getAttributesData": {
          "!type": "fn(attributes: object) -> object",
          "!doc": "Returns an attribute data structure holding the attributes versions for monitoring."
        },
        "getLights": {
          "!type": "fn(lightsNode: +THREE.LightsNode, renderId: number)",
          "!doc": "Returns the lights for the given lights node and render ID."
        },
        "getLightsData": {
          "!type": "fn(materialLights)",
          "!doc": "Returns the lights data for the given material lights."
        },
        "getMaterialData": {
          "!type": "fn(material: +THREE.Material) -> object",
          "!doc": "Returns a material data structure holding the material property values for monitoring."
        },
        "getRenderObjectData": {
          "!type": "fn(renderObject: +THREE.RenderObject) -> object",
          "!doc": "Returns monitoring data for the given render object."
        },
        "needsRefresh": {
          "!type": "fn(renderObject: +THREE.RenderObject, nodeFrame: +THREE.NodeFrame) -> bool",
          "!doc": "Checks if the given render object requires a refresh."
        },
        "needsVelocity": {
          "!type": "fn(renderer: +THREE.Renderer) -> bool",
          "!doc": "Returns true if the current rendering produces motion vectors."
        }
      },
      "!doc": "Constructs a new node material observer.",
      "!type": "fn(builder: +THREE.NodeBuilder)"
    },
    "NodeObjectLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/NodeObjectLoader",
      "prototype": {
        "!proto": "THREE.ObjectLoader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "nodeMaterials": {
          "!doc": "Represents a dictionary of node material types."
        },
        "nodes": {
          "!doc": "Represents a dictionary of node types."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback)",
          "!doc": "Starts loading from the given URL and pass the loaded 3D object to the onLoad() callback."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback)",
          "!doc": "Async version of ObjectLoader."
        },
        "parse": {
          "!type": "fn(json: object, onLoad: fn()) -> +THREE.Object3D",
          "!doc": "Parses the node objects from the given JSON."
        },
        "parseAsync": {
          "!type": "fn(json: object)",
          "!doc": "Async version of ObjectLoader."
        },
        "parseMaterials": {
          "!type": "fn(json: object, textures)",
          "!doc": "Parses the node objects from the given JSON and textures."
        },
        "parseNodes": {
          "!type": "fn(json, textures)",
          "!doc": "Parses the node objects from the given JSON and textures."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setNodeMaterials": {
          "!type": "fn(value) -> +THREE.NodeObjectLoader",
          "!doc": "Defines the dictionary of node material types."
        },
        "setNodes": {
          "!type": "fn(value) -> +THREE.NodeObjectLoader",
          "!doc": "Defines the dictionary of node types."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new node object loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "NumberKeyframeTrack": {
      "!url": "https://threejs.org/docs/#api/en/animation/NumberKeyframeTrack",
      "prototype": {
        "!proto": "THREE.KeyframeTrack.prototype",
        "DefaultInterpolation": {
          "!type": "+THREE.InterpolateLinear",
          "!doc": "The default interpolation type of this keyframe track."
        },
        "TimeBufferType": {
          "!type": "+TypedArray",
          "!doc": "The time buffer type of this keyframe track."
        },
        "ValueBufferType": {
          "!type": "+TypedArray",
          "!doc": "The value buffer type of this keyframe track."
        },
        "ValueTypeName": {
          "!type": "string",
          "!doc": "The value type name."
        },
        "name": {
          "!type": "string",
          "!doc": "The track's name can refer to morph targets or bones or possibly other values within an animated object. See PropertyBinding for the forms of strings that can be parsed for property binding."
        },
        "times": {
          "!type": "+Float32Array",
          "!doc": "The keyframe times."
        },
        "values": {
          "!type": "+Float32Array",
          "!doc": "The keyframe values."
        },
        "InterpolantFactoryMethodBezier": {
          "!type": "fn(result: +TypedArray) -> +THREE.BezierInterpolant",
          "!doc": "Factory method for creating a new Bezier interpolant. The Bezier interpolant requires tangent data to be set via the settings property on the track before creating the interpolant. The settings should contain: - inTangents: Float32Array with [time, value] pairs per keyframe per component - outTangents: Float32Array with [time, value] pairs per keyframe per component"
        },
        "InterpolantFactoryMethodDiscrete": {
          "!type": "fn(result: +TypedArray) -> +THREE.DiscreteInterpolant",
          "!doc": "Factory method for creating a new discrete interpolant."
        },
        "InterpolantFactoryMethodLinear": {
          "!type": "fn(result: +TypedArray) -> +THREE.LinearInterpolant",
          "!doc": "Factory method for creating a new linear interpolant."
        },
        "InterpolantFactoryMethodSmooth": {
          "!type": "fn(result: +TypedArray) -> +THREE.CubicInterpolant",
          "!doc": "Factory method for creating a new smooth interpolant."
        },
        "clone": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Returns a new keyframe track with copied values from this instance."
        },
        "getInterpolation": {
          "!type": "fn() -> +THREE.InterpolateLinear",
          "!doc": "Returns the current interpolation type."
        },
        "getValueSize": {
          "!type": "fn() -> number",
          "!doc": "Returns the value size."
        },
        "optimize": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Optimizes this keyframe track by removing equivalent sequential keys (which are common in morph target sequences)."
        },
        "scale": {
          "!type": "fn(timeScale: number) -> +THREE.KeyframeTrack",
          "!doc": "Scale all keyframe times by a factor (useful for frame - seconds conversions)."
        },
        "setInterpolation": {
          "!type": "fn(interpolation: +THREE.InterpolateLinear) -> +THREE.KeyframeTrack",
          "!doc": "Defines the interpolation factor method for this keyframe track."
        },
        "shift": {
          "!type": "fn(timeOffset: number) -> +THREE.KeyframeTrack",
          "!doc": "Moves all keyframes either forward or backward in time."
        },
        "trim": {
          "!type": "fn(startTime: number, endTime: number) -> +THREE.KeyframeTrack",
          "!doc": "Removes keyframes before and after animation without changing any values within the defined time range. Note: The method does not shift around keys to the start of the track time, because for interpolated keys this will change their values"
        },
        "validate": {
          "!type": "fn() -> bool",
          "!doc": "Performs minimal validation on the keyframe track. Returns true if the values are valid."
        }
      },
      "!doc": "Constructs a new number keyframe track.",
      "!type": "fn(name: string, times, values, interpolation: +THREE.InterpolateLinear)"
    },
    "Object3D": {
      "!url": "https://threejs.org/docs/#api/en/core/Object3D",
      "prototype": {
        "!proto": "THREE.EventDispatcher.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "DEFAULT_MATRIX_AUTO_UPDATE": {
          "!type": "bool",
          "!doc": "The default setting for Object3D for newly created 3D objects."
        },
        "DEFAULT_MATRIX_WORLD_AUTO_UPDATE": {
          "!type": "bool",
          "!doc": "The default setting for Object3D for newly created 3D objects."
        },
        "DEFAULT_UP": {
          "!type": "+THREE.Vector3",
          "!doc": "The default up direction for objects, also used as the default position for DirectionalLight and HemisphereLight."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new 3D object.",
      "!type": "fn()"
    },
    "ObjectLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/ObjectLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback)",
          "!doc": "Starts loading from the given URL and pass the loaded 3D object to the onLoad() callback."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback)",
          "!doc": "Async version of ObjectLoader."
        },
        "parse": {
          "!type": "fn(json: object, onLoad: +THREE.onLoad) -> +THREE.Object3D",
          "!doc": "Parses the given JSON. This is used internally by ObjectLoader but can also be used directly to parse a previously loaded JSON structure."
        },
        "parseAsync": {
          "!type": "fn(json: object)",
          "!doc": "Async version of ObjectLoader."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new object loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "OctahedronGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/OctahedronGeometry",
      "prototype": {
        "!proto": "THREE.PolyhedronGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.OctahedronGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new octahedron geometry.",
      "!type": "fn(radius: number, detail: number)"
    },
    "OrthographicCamera": {
      "!url": "https://threejs.org/docs/#api/en/cameras/OrthographicCamera",
      "prototype": {
        "!proto": "THREE.Camera.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "bottom": {
          "!type": "number",
          "!doc": "The bottom plane of the camera's frustum."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "coordinateSystem": {
          "!type": "+THREE.WebGLCoordinateSystem",
          "!doc": "The coordinate system in which the camera is used."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "far": {
          "!type": "number",
          "!doc": "The camera's far plane. Must be greater than the current value of OrthographicCamera."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "left": {
          "!type": "number",
          "!doc": "The left plane of the camera's frustum."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldInverse": {
          "!type": "+THREE.Matrix4",
          "!doc": "The inverse of the camera's world matrix."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "near": {
          "!type": "number",
          "!doc": "The camera's near plane. The valid range is greater than 0 and less than the current value of OrthographicCamera. Note that, unlike for the PerspectiveCamera, 0 is a valid value for an orthographic camera's near plane."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "projectionMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "The camera's projection matrix."
        },
        "projectionMatrixInverse": {
          "!type": "+THREE.Matrix4",
          "!doc": "The inverse of the camera's projection matrix."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "reversedDepth": {
          "!type": "bool",
          "!doc": "The flag that indicates whether the camera uses a reversed depth buffer."
        },
        "right": {
          "!type": "number",
          "!doc": "The right plane of the camera's frustum."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "top": {
          "!type": "number",
          "!doc": "The top plane of the camera's frustum."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "view": {
          "!type": "object",
          "!doc": "Represents the frustum window specification. This property should not be edited directly but via PerspectiveCamera and PerspectiveCamera."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "zoom": {
          "!type": "number",
          "!doc": "The zoom factor of the camera."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clearViewOffset": {
          "!type": "fn()",
          "!doc": "Removes the view offset from the projection matrix."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space. This method is overwritten since cameras have a different forward vector compared to other 3D objects. A camera looks down its local, negative z-axis by default."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "setViewOffset": {
          "!type": "fn(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number)",
          "!doc": "Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateProjectionMatrix": {
          "!type": "fn()",
          "!doc": "Updates the camera's projection matrix. Must be called after any change of camera properties."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new orthographic camera.",
      "!type": "fn(left: number, right: number, top: number, bottom: number, near: number, far: number)"
    },
    "PMREMGenerator": {
      "!url": "https://threejs.org/docs/#api/en/extras/PMREMGenerator",
      "prototype": {
        "compileCubemapShader": {
          "!type": "fn()",
          "!doc": "Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during your texture's network fetch for increased concurrency."
        },
        "compileEquirectangularShader": {
          "!type": "fn()",
          "!doc": "Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during your texture's network fetch for increased concurrency."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class, so you should not need more than one PMREMGenerator object. If you do, calling dispose() on one of them will cause any others to also become unusable."
        },
        "fromCubemap": {
          "!type": "fn(cubemap: +THREE.Texture, renderTarget: +THREE.WebGLRenderTarget) -> +THREE.WebGLRenderTarget",
          "!doc": "Generates a PMREM from an cubemap texture, which can be either LDR or HDR. The ideal input cube size is 256 x 256, as this matches best with the 256 x 256 cubemap output."
        },
        "fromEquirectangular": {
          "!type": "fn(equirectangular: +THREE.Texture, renderTarget: +THREE.WebGLRenderTarget) -> +THREE.WebGLRenderTarget",
          "!doc": "Generates a PMREM from an equirectangular texture, which can be either LDR or HDR. The ideal input image size is 1k (1024 x 512), as this matches best with the 256 x 256 cubemap output."
        },
        "fromScene": {
          "!type": "fn(scene: +THREE.Scene, sigma: number, near: number, far: number, options: object) -> +THREE.WebGLRenderTarget",
          "!doc": "Generates a PMREM from a supplied Scene, which can be faster than using an image if networking bandwidth is low. Optional sigma specifies a blur radius in radians to be applied to the scene before PMREM generation. Optional near and far planes ensure the scene is rendered in its entirety."
        }
      },
      "!doc": "Constructs a new PMREM generator.",
      "!type": "fn(renderer: +THREE.WebGLRenderer)"
    },
    "Path": {
      "!url": "https://threejs.org/docs/#api/en/extras/Path",
      "prototype": {
        "!proto": "THREE.CurvePath.prototype",
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "autoClose": {
          "!type": "bool",
          "!doc": "Whether the path should automatically be closed by a line curve."
        },
        "currentPoint": {
          "!type": "+THREE.Vector2",
          "!doc": "The current offset of the path. Any new curve added will start here."
        },
        "curves": {
          "!doc": "An array of curves defining the path."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "absarc": {
          "!type": "fn(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool) -> +THREE.Path",
          "!doc": "Adds an absolutely positioned arc as an instance of EllipseCurve to the path."
        },
        "absellipse": {
          "!type": "fn(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool, aRotation: number) -> +THREE.Path",
          "!doc": "Adds an absolutely positioned ellipse as an instance of EllipseCurve to the path."
        },
        "add": {
          "!type": "fn(curve: +THREE.Curve)",
          "!doc": "Adds a curve to this curve path."
        },
        "arc": {
          "!type": "fn(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool) -> +THREE.Path",
          "!doc": "Adds an arc as an instance of EllipseCurve to the path, positioned relative to the current point."
        },
        "bezierCurveTo": {
          "!type": "fn(aCP1x: number, aCP1y: number, aCP2x: number, aCP2y: number, aX: number, aY: number) -> +THREE.Path",
          "!doc": "Adds an instance of CubicBezierCurve to the path by connecting the current point with the given one."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "closePath": {
          "!type": "fn() -> +THREE.CurvePath",
          "!doc": "Adds a line curve to close the path."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "ellipse": {
          "!type": "fn(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool, aRotation: number) -> +THREE.Path",
          "!doc": "Adds an ellipse as an instance of EllipseCurve to the path, positioned relative to the current point"
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getCurveLengths": {
          "!type": "fn()",
          "!doc": "Returns list of cumulative curve lengths of the defined curves."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definitions) for the given interpolation factor."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "lineTo": {
          "!type": "fn(x: number, y: number) -> +THREE.Path",
          "!doc": "Adds an instance of LineCurve to the path by connecting the current point with the given one."
        },
        "moveTo": {
          "!type": "fn(x: number, y: number) -> +THREE.Path",
          "!doc": "Moves Path to the given point."
        },
        "quadraticCurveTo": {
          "!type": "fn(aCPx: number, aCPy: number, aX: number, aY: number) -> +THREE.Path",
          "!doc": "Adds an instance of QuadraticBezierCurve to the path by connecting the current point with the given one."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.Path",
          "!doc": "Creates a path from the given list of points. The points are added to the path as instances of LineCurve."
        },
        "splineThru": {
          "!type": "fn(pts) -> +THREE.Path",
          "!doc": "Adds an instance of SplineCurve to the path by connecting the current point with the given list of points."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new path.",
      "!type": "fn(points)"
    },
    "PerspectiveCamera": {
      "!url": "https://threejs.org/docs/#api/en/cameras/PerspectiveCamera",
      "prototype": {
        "!proto": "THREE.Camera.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "aspect": {
          "!type": "number",
          "!doc": "The aspect ratio, usually the canvas width / canvas height."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "coordinateSystem": {
          "!type": "+THREE.WebGLCoordinateSystem",
          "!doc": "The coordinate system in which the camera is used."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "far": {
          "!type": "number",
          "!doc": "The camera's far plane. Must be greater than the current value of PerspectiveCamera."
        },
        "filmGauge": {
          "!type": "number",
          "!doc": "Film size used for the larger axis. Default is 35 (millimeters). This parameter does not influence the projection matrix unless PerspectiveCamera is set to a nonzero value."
        },
        "filmOffset": {
          "!type": "number",
          "!doc": "Horizontal off-center offset in the same unit as PerspectiveCamera."
        },
        "focus": {
          "!type": "number",
          "!doc": "Object distance used for stereoscopy and depth-of-field effects. This parameter does not influence the projection matrix unless a StereoCamera is being used."
        },
        "fov": {
          "!type": "number",
          "!doc": "The vertical field of view, from bottom to top of view, in degrees."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldInverse": {
          "!type": "+THREE.Matrix4",
          "!doc": "The inverse of the camera's world matrix."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "near": {
          "!type": "number",
          "!doc": "The camera's near plane. The valid range is greater than 0 and less than the current value of PerspectiveCamera. Note that, unlike for the OrthographicCamera, 0 is not a valid value for a perspective camera's near plane."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "projectionMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "The camera's projection matrix."
        },
        "projectionMatrixInverse": {
          "!type": "+THREE.Matrix4",
          "!doc": "The inverse of the camera's projection matrix."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "reversedDepth": {
          "!type": "bool",
          "!doc": "The flag that indicates whether the camera uses a reversed depth buffer."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "view": {
          "!type": "object",
          "!doc": "Represents the frustum window specification. This property should not be edited directly but via PerspectiveCamera and PerspectiveCamera."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "zoom": {
          "!type": "number",
          "!doc": "The zoom factor of the camera."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clearViewOffset": {
          "!type": "fn()",
          "!doc": "Removes the view offset from the projection matrix."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getEffectiveFOV": {
          "!type": "fn() -> number",
          "!doc": "Returns the current vertical field of view angle in degrees considering PerspectiveCamera."
        },
        "getFilmHeight": {
          "!type": "fn() -> number",
          "!doc": "Returns the height of the image on the film. If PerspectiveCamera is greater than or equal to one (landscape format), the result equals PerspectiveCamera."
        },
        "getFilmWidth": {
          "!type": "fn() -> number",
          "!doc": "Returns the width of the image on the film. If PerspectiveCamera is greater than or equal to one (landscape format), the result equals PerspectiveCamera."
        },
        "getFocalLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the focal length from the current PerspectiveCamera and PerspectiveCamera."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getViewBounds": {
          "!type": "fn(distance: number, minTarget: +THREE.Vector2, maxTarget: +THREE.Vector2)",
          "!doc": "Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction. Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle."
        },
        "getViewSize": {
          "!type": "fn(distance: number, target: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space. This method is overwritten since cameras have a different forward vector compared to other 3D objects. A camera looks down its local, negative z-axis by default."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setFocalLength": {
          "!type": "fn(focalLength: number)",
          "!doc": "Sets the FOV by focal length in respect to the current PerspectiveCamera. The default film gauge is 35, so that the focal length can be specified for a 35mm (full frame) camera."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "setViewOffset": {
          "!type": "fn(fullWidth: number, fullHeight: number, x: number, y: number, width: number, height: number)",
          "!doc": "Sets an offset in a larger frustum. This is useful for multi-window or multi-monitor/multi-machine setups. For example, if you have 3x2 monitors and each monitor is 1920x1080 and the monitors are in grid like this `` +---+---+---+ | A | B | C | +---+---+---+ | D | E | F | +---+---+---+ ` then for each monitor you would call it like this: `js const w = 1920; const h = 1080; const fullWidth = w * 3; const fullHeight = h * 2; // --A-- camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h ); // --B-- camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h ); // --C-- camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h ); // --D-- camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h ); // --E-- camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h ); // --F-- camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h ); `` Note there is no reason monitors have to be the same size or in a grid."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateProjectionMatrix": {
          "!type": "fn()",
          "!doc": "Updates the camera's projection matrix. Must be called after any change of camera properties."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new perspective camera.",
      "!type": "fn(fov: number, aspect: number, near: number, far: number)"
    },
    "Plane": {
      "!url": "https://threejs.org/docs/#api/en/math/Plane",
      "prototype": {
        "constant": {
          "!type": "number",
          "!doc": "The signed distance from the origin to the plane."
        },
        "normal": {
          "!type": "+THREE.Vector3",
          "!doc": "A unit length vector defining the normal of the plane."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4, optionalNormalMatrix: +THREE.Matrix4) -> +THREE.Plane",
          "!doc": "Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform. The optional normal matrix can be pre-computed like so: ``js const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix ); ``"
        },
        "clone": {
          "!type": "fn() -> +THREE.Plane",
          "!doc": "Returns a new plane with copied values from this instance."
        },
        "coplanarPoint": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a coplanar vector to the plane, by calculating the projection of the normal at the origin onto the plane."
        },
        "copy": {
          "!type": "fn(plane: +THREE.Plane) -> +THREE.Plane",
          "!doc": "Copies the values of the given plane to this instance."
        },
        "distanceToPoint": {
          "!type": "fn(point: +THREE.Vector3) -> number",
          "!doc": "Returns the signed distance from the given point to this plane."
        },
        "distanceToSphere": {
          "!type": "fn(sphere: +THREE.Sphere) -> number",
          "!doc": "Returns the signed distance from the given sphere to this plane."
        },
        "equals": {
          "!type": "fn(plane: +THREE.Plane) -> bool",
          "!doc": "Returns true if this plane is equal with the given one."
        },
        "intersectLine": {
          "!type": "fn(line: +THREE.Line3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the intersection point of the passed line and the plane. Returns null if the line does not intersect. Returns the line's starting point if the line is coplanar with the plane."
        },
        "intersectsBox": {
          "!type": "fn(box: +THREE.Box3) -> bool",
          "!doc": "Returns true if the given bounding box intersects with the plane."
        },
        "intersectsLine": {
          "!type": "fn(line: +THREE.Line3) -> bool",
          "!doc": "Returns true if the given line segment intersects with (passes through) the plane."
        },
        "intersectsSphere": {
          "!type": "fn(sphere: +THREE.Sphere) -> bool",
          "!doc": "Returns true if the given bounding sphere intersects with the plane."
        },
        "negate": {
          "!type": "fn() -> +THREE.Plane",
          "!doc": "Negates both the plane normal and the constant."
        },
        "normalize": {
          "!type": "fn() -> +THREE.Plane",
          "!doc": "Normalizes the plane normal and adjusts the constant accordingly."
        },
        "projectPoint": {
          "!type": "fn(point: +THREE.Vector3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Projects a the given point onto the plane."
        },
        "set": {
          "!type": "fn(normal: +THREE.Vector3, constant: number) -> +THREE.Plane",
          "!doc": "Sets the plane components by copying the given values."
        },
        "setComponents": {
          "!type": "fn(x: number, y: number, z: number, w: number) -> +THREE.Plane",
          "!doc": "Sets the plane components by defining x, y, z as the plane normal and w as the constant."
        },
        "setFromCoplanarPoints": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3) -> +THREE.Plane",
          "!doc": "Sets the plane from three coplanar points. The winding order is assumed to be counter-clockwise, and determines the direction of the plane normal."
        },
        "setFromNormalAndCoplanarPoint": {
          "!type": "fn(normal: +THREE.Vector3, point: +THREE.Vector3) -> +THREE.Plane",
          "!doc": "Sets the plane from the given normal and coplanar point (that is a point that lies onto the plane)."
        },
        "translate": {
          "!type": "fn(offset: +THREE.Vector3) -> +THREE.Plane",
          "!doc": "Translates the plane by the distance defined by the given offset vector. Note that this only affects the plane constant and will not affect the normal vector."
        }
      },
      "!doc": "Constructs a new plane.",
      "!type": "fn(normal: +THREE.Vector3, constant: number)"
    },
    "PlaneGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/PlaneGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.PlaneGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new plane geometry.",
      "!type": "fn(width: number, height: number, widthSegments: number, heightSegments: number)"
    },
    "PlaneHelper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/PlaneHelper",
      "prototype": {
        "!proto": "THREE.Line.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The line geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The line material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "plane": {
          "!type": "+THREE.Plane",
          "!doc": "The plane being visualized."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "size": {
          "!type": "number",
          "!doc": "The side length of plane helper."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeLineDistances": {
          "!type": "fn() -> +THREE.Line",
          "!doc": "Computes an array of distance values which are necessary for rendering dashed lines. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Updates the helper to match the position and direction of the light being visualized."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Line and Line to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new plane helper.",
      "!type": "fn(plane: +THREE.Plane, size: number, hex: number)"
    },
    "PointLight": {
      "!url": "https://threejs.org/docs/#api/en/lights/PointLight",
      "prototype": {
        "!proto": "THREE.Light.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The light's color."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "decay": {
          "!type": "number",
          "!doc": "The amount the light dims along the distance of the light. In context of physically-correct rendering the default value should not be changed."
        },
        "distance": {
          "!type": "number",
          "!doc": "When distance is zero, light will attenuate according to inverse-square law to infinite distance. When distance is non-zero, light will attenuate according to inverse-square law until near the distance cutoff, where it will then attenuate quickly and smoothly to 0. Inherently, cutoffs are not physically correct."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The light's intensity."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "power": {
          "!type": "number",
          "!doc": "The light's power. Power is the luminous power of the light measured in lumens (lm). Changing the power will also change the light's intensity."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "shadow": {
          "!type": "+THREE.PointLightShadow",
          "!doc": "This property holds the light's shadow configuration."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new point light.",
      "!type": "fn(color: number, intensity: number, distance: number, decay: number)"
    },
    "PointLightHelper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/PointLightHelper",
      "prototype": {
        "!proto": "THREE.Mesh.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "number",
          "!doc": "The color parameter passed in the constructor. If not set, the helper will take the color of the light."
        },
        "count": {
          "!type": "number",
          "!doc": "The number of instances of this mesh. Can only be used with WebGPURenderer."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The mesh geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "light": {
          "!type": "+THREE.PointLight",
          "!doc": "The light being visualized."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The mesh material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getVertexPosition": {
          "!type": "fn(index: number, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the local-space position of the vertex at the given index, taking into account the current animation state of both morph targets and skinning."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "update": {
          "!type": "fn()",
          "!doc": "Updates the helper to match the position of the light being visualized."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Mesh and Mesh to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new point light helper.",
      "!type": "fn(light: +THREE.PointLight, sphereSize: number, color: number)"
    },
    "PointLightShadow": {
      "!url": "https://threejs.org/docs/#api/en/lights/PointLightShadow",
      "prototype": {
        "!proto": "THREE.LightShadow.prototype",
        "autoUpdate": {
          "!type": "bool",
          "!doc": "Enables automatic updates of the light's shadow. If you do not require dynamic lighting / shadows, you may set this to false."
        },
        "bias": {
          "!type": "number",
          "!doc": "Shadow map bias, how much to add or subtract from the normalized depth when deciding whether a surface is in shadow. The default is 0. Very tiny adjustments here (in the order of 0.0001) may help reduce artifacts in shadows."
        },
        "biasNode": {
          "!doc": "A node version of bias. Only supported with WebGPURenderer. If a bias node is defined, bias has no effect."
        },
        "blurSamples": {
          "!type": "number",
          "!doc": "The amount of samples to use when blurring a VSM shadow map."
        },
        "camera": {
          "!type": "+THREE.Camera",
          "!doc": "The light's view of the world."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The intensity of the shadow. The default is 1. Valid values are in the range [0, 1]."
        },
        "map": {
          "!type": "+THREE.RenderTarget",
          "!doc": "The depth map generated using the internal camera; a location beyond a pixel's depth is in shadow. Computed internally during rendering."
        },
        "mapPass": {
          "!type": "+THREE.RenderTarget",
          "!doc": "The distribution map generated using the internal camera; an occlusion is calculated based on the distribution of depths. Computed internally during rendering."
        },
        "mapSize": {
          "!type": "+THREE.Vector2",
          "!doc": "Defines the width and height of the shadow map. Higher values give better quality shadows at the cost of computation time. Values must be powers of two."
        },
        "mapType": {
          "!type": "number",
          "!doc": "The type of shadow texture. The default is UnsignedByteType."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Model to shadow camera space, to compute location and depth in shadow map. This is computed internally during rendering."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, shadow maps will be updated in the next render call. If you have set LightShadow to false, you will need to set this property to true and then make a render call to update the light's shadow."
        },
        "normalBias": {
          "!type": "number",
          "!doc": "Defines how much the position used to query the shadow map is offset along the object normal. The default is 0. Increasing this value can be used to reduce shadow acne especially in large scenes where light shines onto geometry at a shallow angle. The cost is that shadows may appear distorted."
        },
        "radius": {
          "!type": "number",
          "!doc": "Setting this to values greater than 1 will blur the edges of the shadow. High values will cause unwanted banding effects in the shadows - a greater map size will allow for a higher value to be used here before these effects become visible. The property has no effect when the shadow map type is BasicShadowMap."
        },
        "clone": {
          "!type": "fn() -> +THREE.LightShadow",
          "!doc": "Returns a new light shadow instance with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.LightShadow) -> +THREE.LightShadow",
          "!doc": "Copies the values of the given light shadow instance to this instance."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getFrameExtents": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "Returns the frame extends."
        },
        "getFrustum": {
          "!type": "fn() -> +THREE.Frustum",
          "!doc": "Gets the shadow cameras frustum. Used internally by the renderer to cull objects."
        },
        "getViewport": {
          "!type": "fn(viewportIndex: number) -> +THREE.Vector4",
          "!doc": "Returns a viewport definition for the given viewport index."
        },
        "getViewportCount": {
          "!type": "fn() -> number",
          "!doc": "Used internally by the renderer to get the number of viewports that need to be rendered for this shadow."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the light shadow into JSON."
        },
        "updateMatrices": {
          "!type": "fn(light: +THREE.Light)",
          "!doc": "Update the matrices for the camera and shadow, used internally by the renderer."
        }
      },
      "!doc": "Constructs a new point light shadow.",
      "!type": "fn()"
    },
    "Points": {
      "!url": "https://threejs.org/docs/#api/en/objects/Points",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The points geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The line material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this point cloud."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Points and Points to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new point cloud.",
      "!type": "fn(geometry: +THREE.BufferGeometry, material: +THREE.Material)"
    },
    "PointsMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/PointsMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the material."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether the material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "The color map. May optionally include an alpha channel, typically combined with Material or Material. The texture map color is modulated by the diffuse color."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "size": {
          "!type": "number",
          "!doc": "Defines the size of the points in pixels. Might be capped if the value exceeds hardware dependent parameters like [gl.ALIASED_POINT_SIZE_RANGE](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getParamete)."
        },
        "sizeAttenuation": {
          "!type": "bool",
          "!doc": "Specifies whether size of individual points is attenuated by the camera depth (perspective camera only)."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new points material.",
      "!type": "fn(parameters: object)"
    },
    "PointsNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/PointsNodeMaterial",
      "prototype": {
        "!proto": "THREE.SpriteNodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be used or not."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Whether this material is affected by lights or not."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "This property makes it possible to define the position of the sprite with a node. That can be useful when the material is used with instanced rendering and node data are defined with an instanced attribute node: ``js const positionAttribute = new InstancedBufferAttribute( new Float32Array( positions ), 3 ); material.positionNode = instancedBufferAttribute( positionAttribute ); ` Another possibility is to compute the instanced data with a compute shader: `js const positionBuffer = instancedArray( particleCount, 'vec3' ); particleMaterial.positionNode = positionBuffer.toAttribute(); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "rotationNode": {
          "!doc": "The rotation of sprite materials is by default inferred from the rotation, property. This node property allows to overwrite the default and define the rotation with a node instead. If you don't want to overwrite the rotation but modify the existing value instead, use materialRotation."
        },
        "scaleNode": {
          "!doc": "This node property provides an additional way to scale sprites next to Object3D.scale. The scale transformation based in Object3D.scale is multiplied with the scale value of this node in the vertex shader."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "sizeAttenuation": {
          "!type": "bool",
          "!doc": "Whether to use size attenuation or not."
        },
        "sizeNode": {
          "!doc": "This node property provides an additional way to set the point size. Note that WebGPU only supports point primitives with 1 pixel size. Consequently, this node has no effect when the material is used with Points and a WebGPU backend. If an application wants to render points with a size larger than 1 pixel, the material should be used with Sprite and instancing."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "In Sprites, the transparent property is enabled by default."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the environment node from the material."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightingModel",
          "!doc": "This method should be implemented by most derived materials since it defines the material's lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method implements the sprite specific vertex shader."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Abstract interface method that can be implemented by derived materials to setup material-specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new points node material.",
      "!type": "fn(parameters: object)"
    },
    "PolarGridHelper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/PolarGridHelper",
      "prototype": {
        "!proto": "THREE.LineSegments.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The line geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The line material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeLineDistances": {
          "!type": "fn() -> +THREE.Line",
          "!doc": "Computes an array of distance values which are necessary for rendering dashed lines. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Line and Line to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new polar grid helper.",
      "!type": "fn(radius: number, sectors: number, rings: number, divisions: number, color1: number, color2: number)"
    },
    "PolyhedronGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/PolyhedronGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.PolyhedronGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new polyhedron geometry.",
      "!type": "fn(vertices, indices, radius: number, detail: number)"
    },
    "PositionalAudio": {
      "!url": "https://threejs.org/docs/#api/en/audio/PositionalAudio",
      "prototype": {
        "!proto": "THREE.Audio.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "autoplay": {
          "!type": "bool",
          "!doc": "Whether to start playback automatically or not."
        },
        "buffer": {
          "!type": "+THREE.AudioBuffer",
          "!doc": "A reference to an audio buffer. Defined via Audio."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "context": {
          "!type": "+THREE.AudioContext",
          "!doc": "The audio context."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "detune": {
          "!type": "number",
          "!doc": "Modify pitch, measured in cents. +/- 100 is a semitone. +/- 1200 is an octave. Defined via Audio."
        },
        "duration": {
          "!type": "undefined",
          "!doc": "Overrides the default duration of the audio."
        },
        "filters": {
          "!doc": "Can be used to apply a variety of low-order filters to create more complex sound effects e.g. via BiquadFilterNode. The property is automatically set by Audio."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "gain": {
          "!type": "+THREE.GainNode",
          "!doc": "The gain node used for volume control."
        },
        "hasPlaybackControl": {
          "!type": "bool",
          "!doc": "Indicates whether the audio playback can be controlled with method like Audio or Audio. This flag will be automatically set when audio sources are defined."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "listener": {
          "!type": "+THREE.AudioListener",
          "!doc": "The global audio listener."
        },
        "loop": {
          "!type": "bool",
          "!doc": "Whether the audio should loop or not. Defined via Audio."
        },
        "loopEnd": {
          "!type": "number",
          "!doc": "Defines where in the audio buffer the replay should stop, in seconds."
        },
        "loopStart": {
          "!type": "number",
          "!doc": "Defines where in the audio buffer the replay should start, in seconds."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "offset": {
          "!type": "number",
          "!doc": "An offset to the time within the audio buffer the playback should begin, in seconds."
        },
        "panner": {
          "!type": "+THREE.PannerNode",
          "!doc": "The panner node represents the location, direction, and behavior of an audio source in 3D space."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "playbackRate": {
          "!type": "number",
          "!doc": "The playback speed. Defined via Audio."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "source": {
          "!type": "+THREE.AudioNode",
          "!doc": "Holds a reference to the current audio source. The property is automatically by one of the set*() methods."
        },
        "sourceType": {
          "!type": "+THREE.empty",
          "!doc": "Defines the source type. The property is automatically set by one of the set*() methods."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "connect": {
          "!type": "fn() -> +THREE.Audio",
          "!doc": "Connects to the audio source. This is used internally on initialisation and when setting / removing filters."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "disconnect": {
          "!type": "fn() -> +THREE.Audio",
          "!doc": "Disconnects to the audio source. This is used internally on initialisation and when setting / removing filters."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getDetune": {
          "!type": "fn() -> number",
          "!doc": "Returns the detuning of oscillation in cents."
        },
        "getDistanceModel": {
          "!type": "fn() -> +THREE.linear",
          "!doc": "Returns the current distance model."
        },
        "getFilter": {
          "!type": "fn() -> +THREE.AudioNode",
          "!doc": "Returns the first filter in the list of filters."
        },
        "getFilters": {
          "!type": "fn()",
          "!doc": "Returns the current set filters."
        },
        "getLoop": {
          "!type": "fn() -> bool",
          "!doc": "Returns the loop flag. Can only be used with compatible audio sources that allow playback control."
        },
        "getMaxDistance": {
          "!type": "fn() -> number",
          "!doc": "Returns the current max distance."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getOutput": {
          "!type": "fn() -> +THREE.GainNode",
          "!doc": "Returns the output audio node."
        },
        "getPlaybackRate": {
          "!type": "fn() -> number",
          "!doc": "Returns the current playback rate."
        },
        "getRefDistance": {
          "!type": "fn() -> number",
          "!doc": "Returns the current reference distance."
        },
        "getRolloffFactor": {
          "!type": "fn() -> number",
          "!doc": "Returns the current rolloff factor."
        },
        "getVolume": {
          "!type": "fn() -> number",
          "!doc": "Returns the volume."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "onEnded": {
          "!type": "fn()",
          "!doc": "Automatically called when playback finished."
        },
        "pause": {
          "!type": "fn() -> +THREE.Audio",
          "!doc": "Pauses the playback of the audio. Can only be used with compatible audio sources that allow playback control."
        },
        "play": {
          "!type": "fn(delay: number) -> +THREE.Audio",
          "!doc": "Starts the playback of the audio. Can only be used with compatible audio sources that allow playback control."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setBuffer": {
          "!type": "fn(audioBuffer: +THREE.AudioBuffer) -> +THREE.Audio",
          "!doc": "Sets the given audio buffer as the source of this instance. Audio is set to buffer and Audio to true."
        },
        "setDetune": {
          "!type": "fn(value: number) -> +THREE.Audio",
          "!doc": "Defines the detuning of oscillation in cents."
        },
        "setDirectionalCone": {
          "!type": "fn(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number) -> +THREE.PositionalAudio",
          "!doc": "Sets the directional cone in which the audio can be listened."
        },
        "setDistanceModel": {
          "!type": "fn(value: +THREE.linear) -> +THREE.PositionalAudio",
          "!doc": "Defines which algorithm to use to reduce the volume of the audio source as it moves away from the listener. Read [the spec](https://www.w3.org/TR/webaudio-1.1/#enumdef-distancemodeltype) for more details."
        },
        "setFilter": {
          "!type": "fn(filter: +THREE.AudioNode) -> +THREE.Audio",
          "!doc": "Applies a single filter node to the audio."
        },
        "setFilters": {
          "!type": "fn(value) -> +THREE.Audio",
          "!doc": "Sets an array of filters and connects them with the audio source."
        },
        "setLoop": {
          "!type": "fn(value: bool) -> +THREE.Audio",
          "!doc": "Sets the loop flag. Can only be used with compatible audio sources that allow playback control."
        },
        "setLoopEnd": {
          "!type": "fn(value: number) -> +THREE.Audio",
          "!doc": "Sets the loop end value which defines where in the audio buffer the replay should stop, in seconds."
        },
        "setLoopStart": {
          "!type": "fn(value: number) -> +THREE.Audio",
          "!doc": "Sets the loop start value which defines where in the audio buffer the replay should start, in seconds."
        },
        "setMaxDistance": {
          "!type": "fn(value: number) -> +THREE.PositionalAudio",
          "!doc": "Defines the maximum distance between the audio source and the listener, after which the volume is not reduced any further. This value is used only by the linear distance model."
        },
        "setMediaElementSource": {
          "!type": "fn(mediaElement: +THREE.HTMLMediaElement) -> +THREE.Audio",
          "!doc": "Sets the given media element as the source of this instance. Audio is set to mediaNode and Audio to false."
        },
        "setMediaStreamSource": {
          "!type": "fn(mediaStream: +THREE.MediaStream) -> +THREE.Audio",
          "!doc": "Sets the given media stream as the source of this instance. Audio is set to mediaStreamNode and Audio to false."
        },
        "setNodeSource": {
          "!type": "fn(audioNode: +THREE.AudioNode) -> +THREE.Audio",
          "!doc": "Sets the given audio node as the source of this instance. Audio is set to audioNode and Audio to false."
        },
        "setPlaybackRate": {
          "!type": "fn(value: number) -> +THREE.Audio",
          "!doc": "Sets the playback rate. Can only be used with compatible audio sources that allow playback control."
        },
        "setRefDistance": {
          "!type": "fn(value: number) -> +THREE.PositionalAudio",
          "!doc": "Defines the reference distance for reducing volume as the audio source moves further from the listener  i.e. the distance at which the volume reduction starts taking effect."
        },
        "setRolloffFactor": {
          "!type": "fn(value: number) -> +THREE.PositionalAudio",
          "!doc": "Defines how quickly the volume is reduced as the source moves away from the listener."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "setVolume": {
          "!type": "fn(value: number) -> +THREE.Audio",
          "!doc": "Sets the volume."
        },
        "stop": {
          "!type": "fn(delay: number) -> +THREE.Audio",
          "!doc": "Stops the playback of the audio. Can only be used with compatible audio sources that allow playback control."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a positional audio.",
      "!type": "fn(listener: +THREE.AudioListener)"
    },
    "ProjectorLight": {
      "!url": "https://threejs.org/docs/#api/en/lights/ProjectorLight",
      "prototype": {
        "!proto": "THREE.SpotLight.prototype",
        "angle": {
          "!type": "number",
          "!doc": "Maximum angle of light dispersion from its direction whose upper bound is Math.PI/2."
        },
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "aspect": {
          "!type": "number",
          "!doc": "Aspect ratio of the light. Set to null to use the texture aspect ratio."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The light's color."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "decay": {
          "!type": "number",
          "!doc": "The amount the light dims along the distance of the light. In context of physically-correct rendering the default value should not be changed."
        },
        "distance": {
          "!type": "number",
          "!doc": "Maximum range of the light. 0 means no limit."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The light's intensity."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "A texture used to modulate the color of the light. The spot light color is mixed with the RGB value of this texture, with a ratio corresponding to its alpha value. The cookie-like masking effect is reproduced using pixel values (0, 0, 0, 1-cookie_value). *Warning*: This property is disabled if Object3D is set to false."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "penumbra": {
          "!type": "number",
          "!doc": "Percent of the spotlight cone that is attenuated due to penumbra. Value range is [0,1]."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "power": {
          "!type": "number",
          "!doc": "The light's power. Power is the luminous power of the light measured in lumens (lm). Changing the power will also change the light's intensity."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "shadow": {
          "!type": "+THREE.SpotLightShadow",
          "!doc": "This property holds the light's shadow configuration."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "target": {
          "!type": "+THREE.Object3D",
          "!doc": "The spot light points from its position to the target's position. For the target's position to be changed to anything other than the default, it must be added to the scene. It is also possible to set the target to be another 3D object in the scene. The light will now track the target object."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new projector light.",
      "!type": "fn(color: number, intensity: number, distance: number, angle: number, penumbra: number, decay: number)"
    },
    "PropertyBinding": {
      "!url": "https://threejs.org/docs/#api/en/animation/PropertyBinding",
      "prototype": {
        "node": {
          "!type": "object",
          "!doc": "The object owns the animated property."
        },
        "parsedPath": {
          "!type": "object",
          "!doc": "An object holding information about the path."
        },
        "path": {
          "!type": "string",
          "!doc": "The object path to the animated property."
        },
        "rootNode": {
          "!type": "+THREE.Object3D",
          "!doc": "The root node."
        },
        "bind": {
          "!type": "fn()",
          "!doc": "Creates a getter / setter pair for the property tracked by this binding."
        },
        "unbind": {
          "!type": "fn()",
          "!doc": "Unbinds the property."
        },
        "create": {
          "!type": "fn(root: object, path: string, parsedPath: object) -> +THREE.PropertyBinding",
          "!doc": "Factory method for creating a property binding from the given parameters."
        },
        "findNode": {
          "!type": "fn(root: object, nodeName: string) -> object",
          "!doc": "Searches for a node in the hierarchy of the given root object by the given node name."
        },
        "parseTrackName": {
          "!type": "fn(trackName: string) -> object",
          "!doc": "Parses the given track name (an object path to an animated property) and returns an object with information about the path. Matches strings in the following forms: - nodeName.property - nodeName.property[accessor] - nodeName.material.property[accessor] - uuid.property[accessor] - uuid.objectName[objectIndex].propertyName[propertyIndex] - parentName/nodeName.property - parentName/parentName/nodeName.property[index] - .bone[Armature.DEF_cog].position - scene:helium_balloon_model:helium_balloon_model.position"
        },
        "sanitizeNodeName": {
          "!type": "fn(name: string) -> string",
          "!doc": "Replaces spaces with underscores and removes unsupported characters from node names, to ensure compatibility with parseTrackName()."
        }
      },
      "!doc": "Constructs a new property binding.",
      "!type": "fn(rootNode: object, path: string, parsedPath: object)"
    },
    "PropertyMixer": {
      "!url": "https://threejs.org/docs/#api/en/animation/PropertyMixer",
      "prototype": {
        "binding": {
          "!type": "+THREE.PropertyBinding",
          "!doc": "The property binding."
        },
        "cumulativeWeight": {
          "!type": "number",
          "!doc": "Accumulated weight of the property binding."
        },
        "cumulativeWeightAdditive": {
          "!type": "number",
          "!doc": "Accumulated additive weight of the property binding."
        },
        "referenceCount": {
          "!type": "number",
          "!doc": "Number of keyframe tracks referencing this property binding."
        },
        "useCount": {
          "!type": "number",
          "!doc": "Number of active keyframe tracks currently using this property binding."
        },
        "valueSize": {
          "!type": "number",
          "!doc": "The keyframe track value size."
        },
        "accumulate": {
          "!type": "fn(accuIndex: number, weight: number)",
          "!doc": "Accumulates data in the incoming region into accu."
        },
        "accumulateAdditive": {
          "!type": "fn(weight: number)",
          "!doc": "Accumulates data in the incoming region into add."
        },
        "apply": {
          "!type": "fn(accuIndex: number)",
          "!doc": "Applies the state of accu to the binding when accus differ."
        },
        "restoreOriginalState": {
          "!type": "fn()",
          "!doc": "Applies the state previously taken via PropertyMixer to the binding."
        },
        "saveOriginalState": {
          "!type": "fn()",
          "!doc": "Remembers the state of the bound property and copy it to both accus."
        }
      },
      "!doc": "Constructs a new property mixer.",
      "!type": "fn(binding: +THREE.PropertyBinding, typeName: string, valueSize: number)"
    },
    "QuadraticBezierCurve": {
      "!url": "https://threejs.org/docs/#api/en/extras/QuadraticBezierCurve",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "v0": {
          "!type": "+THREE.Vector2",
          "!doc": "The start point."
        },
        "v1": {
          "!type": "+THREE.Vector2",
          "!doc": "The control point."
        },
        "v2": {
          "!type": "+THREE.Vector2",
          "!doc": "The end point."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a point on the curve."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new Quadratic Bezier curve.",
      "!type": "fn(v0: +THREE.Vector2, v1: +THREE.Vector2, v2: +THREE.Vector2)"
    },
    "QuadraticBezierCurve3": {
      "!url": "https://threejs.org/docs/#api/en/extras/QuadraticBezierCurve3",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "v0": {
          "!type": "+THREE.Vector3",
          "!doc": "The start point."
        },
        "v1": {
          "!type": "+THREE.Vector3",
          "!doc": "The control point."
        },
        "v2": {
          "!type": "+THREE.Vector3",
          "!doc": "The end point."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a point on the curve."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new Quadratic Bezier curve.",
      "!type": "fn(v0: +THREE.Vector3, v1: +THREE.Vector3, v2: +THREE.Vector3)"
    },
    "Quaternion": {
      "!url": "https://threejs.org/docs/#api/en/math/Quaternion",
      "prototype": {
        "w": {
          "!type": "number",
          "!doc": "The w value of this quaternion."
        },
        "x": {
          "!type": "number",
          "!doc": "The x value of this quaternion."
        },
        "y": {
          "!type": "number",
          "!doc": "The y value of this quaternion."
        },
        "z": {
          "!type": "number",
          "!doc": "The z value of this quaternion."
        },
        "angleTo": {
          "!type": "fn(q: +THREE.Quaternion) -> number",
          "!doc": "Returns the angle between this quaternion and the given one in radians."
        },
        "clone": {
          "!type": "fn() -> +THREE.Quaternion",
          "!doc": "Returns a new quaternion with copied values from this instance."
        },
        "conjugate": {
          "!type": "fn() -> +THREE.Quaternion",
          "!doc": "Returns the rotational conjugate of this quaternion. The conjugate of a quaternion represents the same rotation in the opposite direction about the rotational axis."
        },
        "copy": {
          "!type": "fn(quaternion: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Copies the values of the given quaternion to this instance."
        },
        "dot": {
          "!type": "fn(v: +THREE.Quaternion) -> number",
          "!doc": "Calculates the dot product of this quaternion and the given one."
        },
        "equals": {
          "!type": "fn(quaternion: +THREE.Quaternion) -> bool",
          "!doc": "Returns true if this quaternion is equal with the given one."
        },
        "fromArray": {
          "!type": "fn(array, offset: number) -> +THREE.Quaternion",
          "!doc": "Sets this quaternion's components from the given array."
        },
        "fromBufferAttribute": {
          "!type": "fn(attribute: +THREE.BufferAttribute, index: number) -> +THREE.Quaternion",
          "!doc": "Sets the components of this quaternion from the given buffer attribute."
        },
        "identity": {
          "!type": "fn() -> +THREE.Quaternion",
          "!doc": "Sets this quaternion to the identity quaternion; that is, to the quaternion that represents \"no rotation\"."
        },
        "invert": {
          "!type": "fn() -> +THREE.Quaternion",
          "!doc": "Inverts this quaternion via Quaternion. The quaternion is assumed to have unit length."
        },
        "length": {
          "!type": "fn() -> number",
          "!doc": "Computes the Euclidean length (straight-line length) of this quaternion, considered as a 4 dimensional vector."
        },
        "lengthSq": {
          "!type": "fn() -> number",
          "!doc": "Computes the squared Euclidean length (straight-line length) of this quaternion, considered as a 4 dimensional vector. This can be useful if you are comparing the lengths of two quaternions, as this is a slightly more efficient calculation than Quaternion."
        },
        "multiply": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Multiplies this quaternion by the given one."
        },
        "multiplyQuaternions": {
          "!type": "fn(a: +THREE.Quaternion, b: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Multiplies the given quaternions and stores the result in this instance."
        },
        "normalize": {
          "!type": "fn() -> +THREE.Quaternion",
          "!doc": "Normalizes this quaternion - that is, calculated the quaternion that performs the same rotation as this one, but has a length equal to 1."
        },
        "premultiply": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Pre-multiplies this quaternion by the given one."
        },
        "random": {
          "!type": "fn() -> +THREE.Quaternion",
          "!doc": "Sets this quaternion to a uniformly random, normalized quaternion."
        },
        "rotateTowards": {
          "!type": "fn(q: +THREE.Quaternion, step: number) -> +THREE.Quaternion",
          "!doc": "Rotates this quaternion by a given angular step to the given quaternion. The method ensures that the final quaternion will not overshoot q."
        },
        "set": {
          "!type": "fn(x: number, y: number, z: number, w: number) -> +THREE.Quaternion",
          "!doc": "Sets the quaternion components."
        },
        "setFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Quaternion",
          "!doc": "Sets this quaternion from the given axis and angle."
        },
        "setFromEuler": {
          "!type": "fn(euler: +THREE.Euler, update: bool) -> +THREE.Quaternion",
          "!doc": "Sets this quaternion from the rotation specified by the given Euler angles."
        },
        "setFromRotationMatrix": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Quaternion",
          "!doc": "Sets this quaternion from the given rotation matrix."
        },
        "setFromUnitVectors": {
          "!type": "fn(vFrom: +THREE.Vector3, vTo: +THREE.Vector3) -> +THREE.Quaternion",
          "!doc": "Sets this quaternion to the rotation required to rotate the direction vector vFrom to the direction vector vTo."
        },
        "slerp": {
          "!type": "fn(qb: +THREE.Quaternion, t: number) -> +THREE.Quaternion",
          "!doc": "Performs a spherical linear interpolation between this quaternion and the target quaternion."
        },
        "slerpQuaternions": {
          "!type": "fn(qa: +THREE.Quaternion, qb: +THREE.Quaternion, t: number) -> +THREE.Quaternion",
          "!doc": "Performs a spherical linear interpolation between the given quaternions and stores the result in this quaternion."
        },
        "toArray": {
          "!type": "fn(array, offset: number)",
          "!doc": "Writes the components of this quaternion to the given array. If no array is provided, the method returns a new instance."
        },
        "toJSON": {
          "!type": "fn()",
          "!doc": "This methods defines the serialization result of this class. Returns the numerical elements of this quaternion in an array of format [x, y, z, w]."
        },
        "multiplyQuaternionsFlat": {
          "!type": "fn(dst, dstOffset: number, src0, srcOffset0: number, src1, srcOffset1: number)",
          "!doc": "Multiplies two quaternions. This implementation assumes the quaternion data are managed in flat arrays."
        },
        "slerpFlat": {
          "!type": "fn(dst, dstOffset: number, src0, srcOffset0: number, src1, srcOffset1: number, t: number)",
          "!doc": "Interpolates between two quaternions via SLERP. This implementation assumes the quaternion data are managed in flat arrays."
        }
      },
      "!doc": "Constructs a new quaternion.",
      "!type": "fn(x: number, y: number, z: number, w: number)"
    },
    "QuaternionKeyframeTrack": {
      "!url": "https://threejs.org/docs/#api/en/animation/QuaternionKeyframeTrack",
      "prototype": {
        "!proto": "THREE.KeyframeTrack.prototype",
        "DefaultInterpolation": {
          "!type": "+THREE.InterpolateLinear",
          "!doc": "The default interpolation type of this keyframe track."
        },
        "TimeBufferType": {
          "!type": "+TypedArray",
          "!doc": "The time buffer type of this keyframe track."
        },
        "ValueBufferType": {
          "!type": "+TypedArray",
          "!doc": "The value buffer type of this keyframe track."
        },
        "ValueTypeName": {
          "!type": "string",
          "!doc": "The value type name."
        },
        "name": {
          "!type": "string",
          "!doc": "The track's name can refer to morph targets or bones or possibly other values within an animated object. See PropertyBinding for the forms of strings that can be parsed for property binding."
        },
        "times": {
          "!type": "+Float32Array",
          "!doc": "The keyframe times."
        },
        "values": {
          "!type": "+Float32Array",
          "!doc": "The keyframe values."
        },
        "InterpolantFactoryMethodBezier": {
          "!type": "fn(result: +TypedArray) -> +THREE.BezierInterpolant",
          "!doc": "Factory method for creating a new Bezier interpolant. The Bezier interpolant requires tangent data to be set via the settings property on the track before creating the interpolant. The settings should contain: - inTangents: Float32Array with [time, value] pairs per keyframe per component - outTangents: Float32Array with [time, value] pairs per keyframe per component"
        },
        "InterpolantFactoryMethodDiscrete": {
          "!type": "fn(result: +TypedArray) -> +THREE.DiscreteInterpolant",
          "!doc": "Factory method for creating a new discrete interpolant."
        },
        "InterpolantFactoryMethodLinear": {
          "!type": "fn(result: +TypedArray) -> +THREE.QuaternionLinearInterpolant",
          "!doc": "Overwritten so the method returns Quaternion based interpolant."
        },
        "InterpolantFactoryMethodSmooth": {
          "!type": "fn(result: +TypedArray) -> +THREE.CubicInterpolant",
          "!doc": "Factory method for creating a new smooth interpolant."
        },
        "clone": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Returns a new keyframe track with copied values from this instance."
        },
        "getInterpolation": {
          "!type": "fn() -> +THREE.InterpolateLinear",
          "!doc": "Returns the current interpolation type."
        },
        "getValueSize": {
          "!type": "fn() -> number",
          "!doc": "Returns the value size."
        },
        "optimize": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Optimizes this keyframe track by removing equivalent sequential keys (which are common in morph target sequences)."
        },
        "scale": {
          "!type": "fn(timeScale: number) -> +THREE.KeyframeTrack",
          "!doc": "Scale all keyframe times by a factor (useful for frame - seconds conversions)."
        },
        "setInterpolation": {
          "!type": "fn(interpolation: +THREE.InterpolateLinear) -> +THREE.KeyframeTrack",
          "!doc": "Defines the interpolation factor method for this keyframe track."
        },
        "shift": {
          "!type": "fn(timeOffset: number) -> +THREE.KeyframeTrack",
          "!doc": "Moves all keyframes either forward or backward in time."
        },
        "trim": {
          "!type": "fn(startTime: number, endTime: number) -> +THREE.KeyframeTrack",
          "!doc": "Removes keyframes before and after animation without changing any values within the defined time range. Note: The method does not shift around keys to the start of the track time, because for interpolated keys this will change their values"
        },
        "validate": {
          "!type": "fn() -> bool",
          "!doc": "Performs minimal validation on the keyframe track. Returns true if the values are valid."
        }
      },
      "!doc": "Constructs a new Quaternion keyframe track.",
      "!type": "fn(name: string, times, values, interpolation: +THREE.InterpolateLinear)"
    },
    "QuaternionLinearInterpolant": {
      "!url": "https://threejs.org/docs/#api/en/math/QuaternionLinearInterpolant",
      "prototype": {
        "!proto": "THREE.Interpolant.prototype",
        "DefaultSettings_": {
          "!type": "object",
          "!doc": "The default settings object."
        },
        "parameterPositions": {
          "!type": "+TypedArray",
          "!doc": "The parameter positions."
        },
        "resultBuffer": {
          "!type": "+TypedArray",
          "!doc": "The result buffer."
        },
        "sampleValues": {
          "!type": "+TypedArray",
          "!doc": "The sample values."
        },
        "settings": {
          "!type": "object",
          "!doc": "The interpolation settings."
        },
        "valueSize": {
          "!type": "+TypedArray",
          "!doc": "The value size."
        },
        "copySampleValue_": {
          "!type": "fn(index: number) -> +TypedArray",
          "!doc": "Copies a sample value to the result buffer."
        },
        "evaluate": {
          "!type": "fn(t: number) -> +TypedArray",
          "!doc": "Evaluate the interpolant at position t."
        },
        "getSettings_": {
          "!type": "fn() -> object",
          "!doc": "Returns the interpolation settings."
        },
        "interpolate_": {
          "!type": "fn(i1: number, t0: number, t: number, t1: number) -> +TypedArray",
          "!doc": "Copies a sample value to the result buffer."
        },
        "intervalChanged_": {
          "!type": "fn(i1: number, t0: number, t: number)",
          "!doc": "Optional method that is executed when the interval has changed."
        }
      },
      "!doc": "Constructs a new SLERP interpolant.",
      "!type": "fn(parameterPositions: +TypedArray, sampleValues: +TypedArray, sampleSize: number, resultBuffer: +TypedArray)"
    },
    "RawShaderMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/RawShaderMaterial",
      "prototype": {
        "!proto": "THREE.ShaderMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clipping": {
          "!type": "bool",
          "!doc": "Defines whether this material supports clipping; true to let the renderer pass the clippingPlanes uniform."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "defaultAttributeValues": {
          "!type": "object",
          "!doc": "When the rendered geometry doesn't include these attributes but the material does, these default values will be passed to the shaders. This avoids errors when buffer data is missing. - color: [ 1, 1, 1 ] - uv: [ 0, 0 ] - uv1: [ 0, 0 ]"
        },
        "defines": {
          "!type": "object",
          "!doc": "Defines custom constants using #define directives within the GLSL code for both the vertex shader and the fragment shader; each key/value pair yields another directive. ``js defines: { FOO: 15, BAR: true } ` Yields the lines: ` #define FOO 15 #define BAR true ``"
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "extensions": {
          "!type": "object",
          "!doc": "This object allows to enable certain WebGL 2 extensions. - clipCullDistance: set to true to use vertex shader clipping - multiDraw: set to true to use vertex shader multi_draw / enable gl_DrawID"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Defines whether the material color is affected by global fog settings; true to pass fog uniforms to the shader. Setting this property to true requires the definition of fog uniforms. It is recommended to use UniformsUtils.merge() to combine the custom shader uniforms with predefined fog uniforms. ``js const material = new ShaderMaterial( { uniforms: UniformsUtils.merge( [ UniformsLib[ 'fog' ], shaderUniforms ] ); vertexShader: vertexShader, fragmentShader: fragmentShader, fog: true } ); ``"
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Overwritten and set to true by default."
        },
        "fragmentShader": {
          "!type": "string",
          "!doc": "Fragment shader GLSL code. This is the actual code for the shader."
        },
        "glslVersion": {
          "!type": "+THREE.GLSL1",
          "!doc": "Defines the GLSL version of custom shader code."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "index0AttributeName": {
          "!type": "string",
          "!doc": "If set, this calls [gl.bindAttribLocation](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation) to bind a generic vertex index to an attribute variable."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Defines whether this material uses lighting; true to pass uniform data related to lighting to this shader."
        },
        "linewidth": {
          "!type": "number",
          "!doc": "Controls line thickness or lines. WebGL and WebGPU ignore this setting and always render line primitives with a width of one pixel."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "uniforms": {
          "!type": "object",
          "!doc": "An object of the form: ``js { \"uniform1\": { value: 1.0 }, \"uniform2\": { value: 2 } } ` specifying the uniforms to be passed to the shader code; keys are uniform names, values are definitions of the form ` { value: 1.0 } ` where value` is the value of the uniform. Names must match the name of the uniform, as defined in the GLSL code. Note that uniforms are refreshed on every frame, so updating the value of the uniform will immediately update the value available to the GLSL code."
        },
        "uniformsGroups": {
          "!doc": "An array holding uniforms groups for configuring UBOs."
        },
        "uniformsNeedUpdate": {
          "!type": "bool",
          "!doc": "Can be used to force a uniform update while changing uniforms in Object3D."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexShader": {
          "!type": "string",
          "!doc": "Vertex shader GLSL code. This is the actual code for the shader."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Renders the geometry as a wireframe."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls the thickness of the wireframe. WebGL and WebGPU ignore this property and always render 1 pixel wide lines."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new raw shader material.",
      "!type": "fn(parameters: object)"
    },
    "Ray": {
      "!url": "https://threejs.org/docs/#api/en/math/Ray",
      "prototype": {
        "direction": {
          "!type": "+THREE.Vector3",
          "!doc": "The (normalized) direction of the ray."
        },
        "origin": {
          "!type": "+THREE.Vector3",
          "!doc": "The origin of the ray."
        },
        "applyMatrix4": {
          "!type": "fn(matrix4: +THREE.Matrix4) -> +THREE.Ray",
          "!doc": "Transforms this ray with the given 4x4 transformation matrix."
        },
        "at": {
          "!type": "fn(t: number, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector that is located at a given distance along this ray."
        },
        "clone": {
          "!type": "fn() -> +THREE.Ray",
          "!doc": "Returns a new ray with copied values from this instance."
        },
        "closestPointToPoint": {
          "!type": "fn(point: +THREE.Vector3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the point along this ray that is closest to the given point."
        },
        "copy": {
          "!type": "fn(ray: +THREE.Ray) -> +THREE.Ray",
          "!doc": "Copies the values of the given ray to this instance."
        },
        "distanceSqToPoint": {
          "!type": "fn(point: +THREE.Vector3) -> number",
          "!doc": "Returns the squared distance of the closest approach between this ray and the given point."
        },
        "distanceSqToSegment": {
          "!type": "fn(v0: +THREE.Vector3, v1: +THREE.Vector3, optionalPointOnRay: +THREE.Vector3, optionalPointOnSegment: +THREE.Vector3) -> number",
          "!doc": "Returns the squared distance between this ray and the given line segment."
        },
        "distanceToPlane": {
          "!type": "fn(plane: +THREE.Plane) -> number",
          "!doc": "Computes the distance from the ray's origin to the given plane. Returns null if the ray does not intersect with the plane."
        },
        "distanceToPoint": {
          "!type": "fn(point: +THREE.Vector3) -> number",
          "!doc": "Returns the distance of the closest approach between this ray and the given point."
        },
        "equals": {
          "!type": "fn(ray: +THREE.Ray) -> bool",
          "!doc": "Returns true if this ray is equal with the given one."
        },
        "intersectBox": {
          "!type": "fn(box: +THREE.Box3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Intersects this ray with the given bounding box, returning the intersection point or null if there is no intersection."
        },
        "intersectPlane": {
          "!type": "fn(plane: +THREE.Plane, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Intersects this ray with the given plane, returning the intersection point or null if there is no intersection."
        },
        "intersectSphere": {
          "!type": "fn(sphere: +THREE.Sphere, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Intersects this ray with the given sphere, returning the intersection point or null if there is no intersection."
        },
        "intersectTriangle": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3, backfaceCulling: bool, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Intersects this ray with the given triangle, returning the intersection point or null if there is no intersection."
        },
        "intersectsBox": {
          "!type": "fn(box: +THREE.Box3) -> bool",
          "!doc": "Returns true if this ray intersects with the given box."
        },
        "intersectsPlane": {
          "!type": "fn(plane: +THREE.Plane) -> bool",
          "!doc": "Returns true if this ray intersects with the given plane."
        },
        "intersectsSphere": {
          "!type": "fn(sphere: +THREE.Sphere) -> bool",
          "!doc": "Returns true if this ray intersects with the given sphere."
        },
        "lookAt": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Ray",
          "!doc": "Adjusts the direction of the ray to point at the given vector in world space."
        },
        "recast": {
          "!type": "fn(t: number) -> +THREE.Ray",
          "!doc": "Shift the origin of this ray along its direction by the given distance."
        },
        "set": {
          "!type": "fn(origin: +THREE.Vector3, direction: +THREE.Vector3) -> +THREE.Ray",
          "!doc": "Sets the ray's components by copying the given values."
        }
      },
      "!doc": "Constructs a new ray.",
      "!type": "fn(origin: +THREE.Vector3, direction: +THREE.Vector3)"
    },
    "Raycaster": {
      "!url": "https://threejs.org/docs/#api/en/core/Raycaster",
      "prototype": {
        "camera": {
          "!type": "+THREE.Camera",
          "!doc": "The camera to use when raycasting against view-dependent objects such as billboarded objects like sprites. This field can be set manually or is set when calling setFromCamera()."
        },
        "far": {
          "!type": "number",
          "!doc": "All results returned are closer than far. Far can't be lower than near."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "Allows to selectively ignore 3D objects when performing intersection tests. The following code example ensures that only 3D objects on layer 1 will be honored by raycaster. ``js raycaster.layers.set( 1 ); object.layers.enable( 1 ); ``"
        },
        "near": {
          "!type": "number",
          "!doc": "All results returned are further away than near. Near can't be negative."
        },
        "params": {
          "!type": "object",
          "!doc": "A parameter object that configures the raycasting. It has the structure: `` { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } ` Where threshold` is the precision of the raycaster when intersecting objects, in world units."
        },
        "ray": {
          "!type": "+THREE.Ray",
          "!doc": "The ray used for raycasting."
        },
        "intersectObject": {
          "!type": "fn(object: +THREE.Object3D, recursive: bool, intersects)",
          "!doc": "Checks all intersection between the ray and the object with or without the descendants. Intersections are returned sorted by distance, closest first. Raycaster delegates to the raycast() method of the passed 3D object, when evaluating whether the ray intersects the object or not. This allows meshes to respond differently to ray casting than lines or points. Note that for meshes, faces must be pointed towards the origin of the ray in order to be detected; intersections of the ray passing through the back of a face will not be detected. To raycast against both faces of an object, you'll want to set Material to THREE.DoubleSide."
        },
        "intersectObjects": {
          "!type": "fn(objects, recursive: bool, intersects)",
          "!doc": "Checks all intersection between the ray and the objects with or without the descendants. Intersections are returned sorted by distance, closest first."
        },
        "set": {
          "!type": "fn(origin: +THREE.Vector3, direction: +THREE.Vector3)",
          "!doc": "Updates the ray with a new origin and direction by copying the values from the arguments."
        },
        "setFromCamera": {
          "!type": "fn(coords: +THREE.Vector2, camera: +THREE.Camera)",
          "!doc": "Uses the given coordinates and camera to compute a new origin and direction for the internal ray."
        },
        "setFromXRController": {
          "!type": "fn(controller: +THREE.WebXRController) -> +THREE.Raycaster",
          "!doc": "Uses the given WebXR controller to compute a new origin and direction for the internal ray."
        }
      },
      "!doc": "Constructs a new raycaster.",
      "!type": "fn(origin: +THREE.Vector3, direction: +THREE.Vector3, near: number, far: number)"
    },
    "RectAreaLight": {
      "!url": "https://threejs.org/docs/#api/en/lights/RectAreaLight",
      "prototype": {
        "!proto": "THREE.Light.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The light's color."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "height": {
          "!type": "number",
          "!doc": "The height of the light."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The light's intensity."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "power": {
          "!type": "number",
          "!doc": "The light's power. Power is the luminous power of the light measured in lumens (lm). Changing the power will also change the light's intensity."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "width": {
          "!type": "number",
          "!doc": "The width of the light."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new area light.",
      "!type": "fn(color: number, intensity: number, width: number, height: number)"
    },
    "RenderTarget": {
      "!url": "https://threejs.org/docs/#api/en/core/RenderTarget",
      "prototype": {
        "!proto": "THREE.EventDispatcher.prototype",
        "depth": {
          "!type": "number",
          "!doc": "The depth of the render target."
        },
        "depthBuffer": {
          "!type": "bool",
          "!doc": "Whether to allocate a depth buffer or not."
        },
        "depthTexture": {
          "!type": "+THREE.DepthTexture",
          "!doc": "Instead of saving the depth in a renderbuffer, a texture can be used instead which is useful for further processing e.g. in context of post-processing."
        },
        "height": {
          "!type": "number",
          "!doc": "The height of the render target."
        },
        "multiview": {
          "!type": "bool",
          "!doc": "Whether to this target is used in multiview rendering."
        },
        "resolveDepthBuffer": {
          "!type": "bool",
          "!doc": "Whether to resolve the depth buffer or not."
        },
        "resolveStencilBuffer": {
          "!type": "bool",
          "!doc": "Whether to resolve the stencil buffer or not."
        },
        "samples": {
          "!type": "number",
          "!doc": "The number of MSAA samples. A value of 0 disables MSAA."
        },
        "scissor": {
          "!type": "+THREE.Vector4",
          "!doc": "A rectangular area inside the render target's viewport. Fragments that are outside the area will be discarded."
        },
        "scissorTest": {
          "!type": "bool",
          "!doc": "Indicates whether the scissor test should be enabled when rendering into this render target or not."
        },
        "stencilBuffer": {
          "!type": "bool",
          "!doc": "Whether to allocate a stencil buffer or not."
        },
        "texture": {
          "!type": "+THREE.Texture",
          "!doc": "The texture representing the default color attachment."
        },
        "textures": {
          "!doc": "An array of textures. Each color attachment is represented as a separate texture. Has at least a single entry for the default color attachment."
        },
        "viewport": {
          "!type": "+THREE.Vector4",
          "!doc": "A rectangular area representing the render target's viewport."
        },
        "width": {
          "!type": "number",
          "!doc": "The width of the render target."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.RenderTarget",
          "!doc": "Returns a new render target with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.RenderTarget) -> +THREE.RenderTarget",
          "!doc": "Copies the settings of the given render target. This is a structural copy so no resources are shared between render targets after the copy. That includes all MRT textures and the depth texture."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setSize": {
          "!type": "fn(width: number, height: number, depth: number)",
          "!doc": "Sets the size of this render target."
        }
      },
      "!doc": "Constructs a new render target.",
      "!type": "fn(width: number, height: number, options)"
    },
    "RenderTarget3D": {
      "!url": "https://threejs.org/docs/#api/en/core/RenderTarget3D",
      "prototype": {
        "!proto": "THREE.RenderTarget.prototype",
        "depth": {
          "!type": "number",
          "!doc": "The depth of the render target."
        },
        "depthBuffer": {
          "!type": "bool",
          "!doc": "Whether to allocate a depth buffer or not."
        },
        "depthTexture": {
          "!type": "+THREE.DepthTexture",
          "!doc": "Instead of saving the depth in a renderbuffer, a texture can be used instead which is useful for further processing e.g. in context of post-processing."
        },
        "height": {
          "!type": "number",
          "!doc": "The height of the render target."
        },
        "multiview": {
          "!type": "bool",
          "!doc": "Whether to this target is used in multiview rendering."
        },
        "resolveDepthBuffer": {
          "!type": "bool",
          "!doc": "Whether to resolve the depth buffer or not."
        },
        "resolveStencilBuffer": {
          "!type": "bool",
          "!doc": "Whether to resolve the stencil buffer or not."
        },
        "samples": {
          "!type": "number",
          "!doc": "The number of MSAA samples. A value of 0 disables MSAA."
        },
        "scissor": {
          "!type": "+THREE.Vector4",
          "!doc": "A rectangular area inside the render target's viewport. Fragments that are outside the area will be discarded."
        },
        "scissorTest": {
          "!type": "bool",
          "!doc": "Indicates whether the scissor test should be enabled when rendering into this render target or not."
        },
        "stencilBuffer": {
          "!type": "bool",
          "!doc": "Whether to allocate a stencil buffer or not."
        },
        "texture": {
          "!type": "+THREE.Data3DTexture",
          "!doc": "Overwritten with a different texture type."
        },
        "textures": {
          "!doc": "An array of textures. Each color attachment is represented as a separate texture. Has at least a single entry for the default color attachment."
        },
        "viewport": {
          "!type": "+THREE.Vector4",
          "!doc": "A rectangular area representing the render target's viewport."
        },
        "width": {
          "!type": "number",
          "!doc": "The width of the render target."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.RenderTarget",
          "!doc": "Returns a new render target with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.RenderTarget) -> +THREE.RenderTarget",
          "!doc": "Copies the settings of the given render target. This is a structural copy so no resources are shared between render targets after the copy. That includes all MRT textures and the depth texture."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setSize": {
          "!type": "fn(width: number, height: number, depth: number)",
          "!doc": "Sets the size of this render target."
        }
      },
      "!doc": "Constructs a new 3D render target.",
      "!type": "fn(width: number, height: number, depth: number, options)"
    },
    "RingGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/RingGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.RingGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new ring geometry.",
      "!type": "fn(innerRadius: number, outerRadius: number, thetaSegments: number, phiSegments: number, thetaStart: number, thetaLength: number)"
    },
    "SSSLightingModel": {
      "!url": "https://threejs.org/docs/#api/en/materials/SSSLightingModel",
      "prototype": {
        "!proto": "THREE.PhysicalLightingModel.prototype",
        "useSSS": {
          "!type": "bool",
          "!doc": "Whether the lighting model should use SSS or not."
        },
        "direct": {
          "!type": "fn(input: object, builder: +THREE.NodeBuilder)",
          "!doc": "Extends the default implementation with a SSS term. Reference: [Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look](https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/)"
        }
      },
      "!doc": "Constructs a new physical lighting model.",
      "!type": "fn(clearcoat: bool, sheen: bool, iridescence: bool, anisotropy: bool, transmission: bool, dispersion: bool, sss: bool)"
    },
    "Scene": {
      "!url": "https://threejs.org/docs/#api/en/scenes/Scene",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "background": {
          "!type": "+THREE.Color",
          "!doc": "Defines the background of the scene. Valid inputs are: - A color for defining a uniform colored background. - A texture for defining a (flat) textured background. - Cube textures or equirectangular textures for defining a skybox."
        },
        "backgroundBlurriness": {
          "!type": "number",
          "!doc": "Sets the blurriness of the background. Only influences environment maps assigned to Scene. Valid input is a float between 0 and 1."
        },
        "backgroundIntensity": {
          "!type": "number",
          "!doc": "Attenuates the color of the background. Only applies to background textures."
        },
        "backgroundRotation": {
          "!type": "+THREE.Euler",
          "!doc": "The rotation of the background in radians. Only influences environment maps assigned to Scene."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "environment": {
          "!type": "+THREE.Texture",
          "!doc": "Sets the environment map for all physical materials in the scene. However, it's not possible to overwrite an existing texture assigned to the envMap material property."
        },
        "environmentIntensity": {
          "!type": "number",
          "!doc": "Attenuates the color of the environment. Only influences environment maps assigned to Scene."
        },
        "environmentRotation": {
          "!type": "+THREE.Euler",
          "!doc": "The rotation of the environment map in radians. Only influences physical materials in the scene when Scene is used."
        },
        "fog": {
          "!type": "+THREE.Fog",
          "!doc": "A fog instance defining the type of fog that affects everything rendered in the scene."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "overrideMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Forces everything in the scene to be rendered with the defined material. It is possible to exclude materials from override by setting Material to false."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new scene.",
      "!type": "fn()"
    },
    "ShaderMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/ShaderMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clipping": {
          "!type": "bool",
          "!doc": "Defines whether this material supports clipping; true to let the renderer pass the clippingPlanes uniform."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "defaultAttributeValues": {
          "!type": "object",
          "!doc": "When the rendered geometry doesn't include these attributes but the material does, these default values will be passed to the shaders. This avoids errors when buffer data is missing. - color: [ 1, 1, 1 ] - uv: [ 0, 0 ] - uv1: [ 0, 0 ]"
        },
        "defines": {
          "!type": "object",
          "!doc": "Defines custom constants using #define directives within the GLSL code for both the vertex shader and the fragment shader; each key/value pair yields another directive. ``js defines: { FOO: 15, BAR: true } ` Yields the lines: ` #define FOO 15 #define BAR true ``"
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "extensions": {
          "!type": "object",
          "!doc": "This object allows to enable certain WebGL 2 extensions. - clipCullDistance: set to true to use vertex shader clipping - multiDraw: set to true to use vertex shader multi_draw / enable gl_DrawID"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Defines whether the material color is affected by global fog settings; true to pass fog uniforms to the shader. Setting this property to true requires the definition of fog uniforms. It is recommended to use UniformsUtils.merge() to combine the custom shader uniforms with predefined fog uniforms. ``js const material = new ShaderMaterial( { uniforms: UniformsUtils.merge( [ UniformsLib[ 'fog' ], shaderUniforms ] ); vertexShader: vertexShader, fragmentShader: fragmentShader, fog: true } ); ``"
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Overwritten and set to true by default."
        },
        "fragmentShader": {
          "!type": "string",
          "!doc": "Fragment shader GLSL code. This is the actual code for the shader."
        },
        "glslVersion": {
          "!type": "+THREE.GLSL1",
          "!doc": "Defines the GLSL version of custom shader code."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "index0AttributeName": {
          "!type": "string",
          "!doc": "If set, this calls [gl.bindAttribLocation](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation) to bind a generic vertex index to an attribute variable."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Defines whether this material uses lighting; true to pass uniform data related to lighting to this shader."
        },
        "linewidth": {
          "!type": "number",
          "!doc": "Controls line thickness or lines. WebGL and WebGPU ignore this setting and always render line primitives with a width of one pixel."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "uniforms": {
          "!type": "object",
          "!doc": "An object of the form: ``js { \"uniform1\": { value: 1.0 }, \"uniform2\": { value: 2 } } ` specifying the uniforms to be passed to the shader code; keys are uniform names, values are definitions of the form ` { value: 1.0 } ` where value` is the value of the uniform. Names must match the name of the uniform, as defined in the GLSL code. Note that uniforms are refreshed on every frame, so updating the value of the uniform will immediately update the value available to the GLSL code."
        },
        "uniformsGroups": {
          "!doc": "An array holding uniforms groups for configuring UBOs."
        },
        "uniformsNeedUpdate": {
          "!type": "bool",
          "!doc": "Can be used to force a uniform update while changing uniforms in Object3D."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexShader": {
          "!type": "string",
          "!doc": "Vertex shader GLSL code. This is the actual code for the shader."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "wireframe": {
          "!type": "bool",
          "!doc": "Renders the geometry as a wireframe."
        },
        "wireframeLinewidth": {
          "!type": "number",
          "!doc": "Controls the thickness of the wireframe. WebGL and WebGPU ignore this property and always render 1 pixel wide lines."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new shader material.",
      "!type": "fn(parameters: object)"
    },
    "ShadowMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/ShadowMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the material."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether the material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Overwritten since shadow materials are transparent by default."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new shadow material.",
      "!type": "fn(parameters: object)"
    },
    "ShadowNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/ShadowNodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Set to true because so it's possible to implement the shadow mask effect."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Overwritten since shadow materials are transparent by default."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the environment node from the material."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn() -> +THREE.ShadowMaskModel",
          "!doc": "Setups the lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Abstract interface method that can be implemented by derived materials to setup material-specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new shadow node material.",
      "!type": "fn(parameters: object)"
    },
    "Shape": {
      "!url": "https://threejs.org/docs/#api/en/extras/Shape",
      "prototype": {
        "!proto": "THREE.Path.prototype",
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "autoClose": {
          "!type": "bool",
          "!doc": "Whether the path should automatically be closed by a line curve."
        },
        "currentPoint": {
          "!type": "+THREE.Vector2",
          "!doc": "The current offset of the path. Any new curve added will start here."
        },
        "curves": {
          "!doc": "An array of curves defining the path."
        },
        "holes": {
          "!doc": "Defines the holes in the shape. Hole definitions must use the opposite winding order (CW/CCW) than the outer shape."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the shape."
        },
        "absarc": {
          "!type": "fn(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool) -> +THREE.Path",
          "!doc": "Adds an absolutely positioned arc as an instance of EllipseCurve to the path."
        },
        "absellipse": {
          "!type": "fn(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool, aRotation: number) -> +THREE.Path",
          "!doc": "Adds an absolutely positioned ellipse as an instance of EllipseCurve to the path."
        },
        "add": {
          "!type": "fn(curve: +THREE.Curve)",
          "!doc": "Adds a curve to this curve path."
        },
        "arc": {
          "!type": "fn(aX: number, aY: number, aRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool) -> +THREE.Path",
          "!doc": "Adds an arc as an instance of EllipseCurve to the path, positioned relative to the current point."
        },
        "bezierCurveTo": {
          "!type": "fn(aCP1x: number, aCP1y: number, aCP2x: number, aCP2y: number, aX: number, aY: number) -> +THREE.Path",
          "!doc": "Adds an instance of CubicBezierCurve to the path by connecting the current point with the given one."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "closePath": {
          "!type": "fn() -> +THREE.CurvePath",
          "!doc": "Adds a line curve to close the path."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "ellipse": {
          "!type": "fn(aX: number, aY: number, xRadius: number, yRadius: number, aStartAngle: number, aEndAngle: number, aClockwise: bool, aRotation: number) -> +THREE.Path",
          "!doc": "Adds an ellipse as an instance of EllipseCurve to the path, positioned relative to the current point"
        },
        "extractPoints": {
          "!type": "fn(divisions: number) -> object",
          "!doc": "Returns an object that holds contour data for the shape and its holes as arrays of 2D points."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getCurveLengths": {
          "!type": "fn()",
          "!doc": "Returns list of cumulative curve lengths of the defined curves."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definitions) for the given interpolation factor."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getPointsHoles": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array representing each contour of the holes as a list of 2D points."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "lineTo": {
          "!type": "fn(x: number, y: number) -> +THREE.Path",
          "!doc": "Adds an instance of LineCurve to the path by connecting the current point with the given one."
        },
        "moveTo": {
          "!type": "fn(x: number, y: number) -> +THREE.Path",
          "!doc": "Moves Path to the given point."
        },
        "quadraticCurveTo": {
          "!type": "fn(aCPx: number, aCPy: number, aX: number, aY: number) -> +THREE.Path",
          "!doc": "Adds an instance of QuadraticBezierCurve to the path by connecting the current point with the given one."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.Path",
          "!doc": "Creates a path from the given list of points. The points are added to the path as instances of LineCurve."
        },
        "splineThru": {
          "!type": "fn(pts) -> +THREE.Path",
          "!doc": "Adds an instance of SplineCurve to the path by connecting the current point with the given list of points."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new shape.",
      "!type": "fn(points)"
    },
    "ShapeGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/ShapeGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object, shapes) -> +THREE.ShapeGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new shape geometry.",
      "!type": "fn(shapes: +THREE.Shape, curveSegments: number)"
    },
    "ShapePath": {
      "!url": "https://threejs.org/docs/#api/en/extras/ShapePath",
      "prototype": {
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The color of the shape."
        },
        "currentPath": {
          "!type": "+THREE.Path",
          "!doc": "The current path that is being generated."
        },
        "subPaths": {
          "!doc": "The paths that have been generated for this shape."
        },
        "bezierCurveTo": {
          "!type": "fn(aCP1x: number, aCP1y: number, aCP2x: number, aCP2y: number, aX: number, aY: number) -> +THREE.ShapePath",
          "!doc": "Adds an instance of CubicBezierCurve to the path by connecting the current point with the given one."
        },
        "lineTo": {
          "!type": "fn(x: number, y: number) -> +THREE.ShapePath",
          "!doc": "Adds an instance of LineCurve to the path by connecting the current point with the given one."
        },
        "moveTo": {
          "!type": "fn(x: number, y: number) -> +THREE.ShapePath",
          "!doc": "Creates a new path and moves it current point to the given one."
        },
        "quadraticCurveTo": {
          "!type": "fn(aCPx: number, aCPy: number, aX: number, aY: number) -> +THREE.ShapePath",
          "!doc": "Adds an instance of QuadraticBezierCurve to the path by connecting the current point with the given one."
        },
        "splineThru": {
          "!type": "fn(pts) -> +THREE.ShapePath",
          "!doc": "Adds an instance of SplineCurve to the path by connecting the current point with the given list of points."
        },
        "toShapes": {
          "!type": "fn(isCCW: bool)",
          "!doc": "Converts the paths into an array of shapes."
        }
      },
      "!doc": "Constructs a new shape path.",
      "!type": "fn()"
    },
    "ShapeUtils": {
      "!url": "https://threejs.org/docs/#api/en/extras/ShapeUtils",
      "prototype": {
        "area": {
          "!type": "fn(contour) -> number",
          "!doc": "Calculate area of a ( 2D ) contour polygon."
        },
        "isClockWise": {
          "!type": "fn(pts) -> bool",
          "!doc": "Returns true if the given contour uses a clockwise winding order."
        },
        "triangulateShape": {
          "!type": "fn(contour, holes)",
          "!doc": "Triangulates the given shape definition."
        }
      },
      "!type": "fn()"
    },
    "Skeleton": {
      "!url": "https://threejs.org/docs/#api/en/objects/Skeleton",
      "prototype": {
        "boneInverses": {
          "!doc": "An array of bone inverse matrices."
        },
        "boneMatrices": {
          "!type": "+Float32Array",
          "!doc": "An array buffer holding the bone data. Input data for Skeleton."
        },
        "boneTexture": {
          "!type": "+THREE.DataTexture",
          "!doc": "A texture holding the bone data for use in the vertex shader."
        },
        "bones": {
          "!doc": "An array of bones defining the skeleton."
        },
        "previousBoneMatrices": {
          "!type": "+Float32Array",
          "!doc": "An array buffer holding the bone data of the previous frame. Required for computing velocity. Maintained in SkinningNode."
        },
        "calculateInverses": {
          "!type": "fn()",
          "!doc": "Computes the bone inverse matrices. This method resets Skeleton and fills it with new matrices."
        },
        "clone": {
          "!type": "fn() -> +THREE.Skeleton",
          "!doc": "Returns a new skeleton with copied values from this instance."
        },
        "computeBoneTexture": {
          "!type": "fn() -> +THREE.Skeleton",
          "!doc": "Computes a data texture for passing bone data to the vertex shader."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "fromJSON": {
          "!type": "fn(json: object, bones) -> +THREE.Skeleton",
          "!doc": "Setups the skeleton by the given JSON and bones."
        },
        "getBoneByName": {
          "!type": "fn(name: string) -> +THREE.Bone",
          "!doc": "Searches through the skeleton's bone array and returns the first with a matching name."
        },
        "init": {
          "!type": "fn()",
          "!doc": "Initializes the skeleton. This method gets automatically called by the constructor but depending on how the skeleton is created it might be necessary to call this method manually."
        },
        "pose": {
          "!type": "fn()",
          "!doc": "Resets the skeleton to the base pose."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the skeleton into JSON."
        },
        "update": {
          "!type": "fn()",
          "!doc": "Resets the skeleton to the base pose."
        }
      },
      "!doc": "Constructs a new skeleton.",
      "!type": "fn(bones, boneInverses)"
    },
    "SkeletonHelper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/SkeletonHelper",
      "prototype": {
        "!proto": "THREE.LineSegments.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "bones": {
          "!doc": "The list of bones that the helper visualizes."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The line geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The line material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "root": {
          "!type": "+THREE.Object3D",
          "!doc": "The object being visualized."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeLineDistances": {
          "!type": "fn() -> +THREE.Line",
          "!doc": "Computes an array of distance values which are necessary for rendering dashed lines. For each vertex in the geometry, the method calculates the cumulative length from the current point to the very beginning of the line."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setColors": {
          "!type": "fn(color1: +THREE.Color, color2: +THREE.Color) -> +THREE.SkeletonHelper",
          "!doc": "Defines the colors of the helper."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Line and Line to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new skeleton helper.",
      "!type": "fn(object: +THREE.Object3D)"
    },
    "SkinnedMesh": {
      "!url": "https://threejs.org/docs/#api/en/objects/SkinnedMesh",
      "prototype": {
        "!proto": "THREE.Mesh.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "bindMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "The base matrix that is used for the bound bone transforms."
        },
        "bindMatrixInverse": {
          "!type": "+THREE.Matrix4",
          "!doc": "The base matrix that is used for resetting the bound bone transforms."
        },
        "bindMode": {
          "!type": "+THREE.AttachedBindMode",
          "!doc": "AttachedBindMode means the skinned mesh shares the same world space as the skeleton. This is not true when using DetachedBindMode which is useful when sharing a skeleton across multiple skinned meshes."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "The bounding box of the skinned mesh. Can be computed via SkinnedMesh."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "The bounding sphere of the skinned mesh. Can be computed via SkinnedMesh."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "count": {
          "!type": "number",
          "!doc": "The number of instances of this mesh. Can only be used with WebGPURenderer."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The mesh geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.Material",
          "!doc": "The mesh material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "morphTargetDictionary": {
          "!doc": "A dictionary representing the morph targets in the geometry. The key is the morph targets name, the value its attribute index. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "morphTargetInfluences": {
          "!doc": "An array of weights typically in the range [0,1] that specify how much of the morph is applied. This member is undefined by default and only set when morph targets are detected in the geometry."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyBoneTransform": {
          "!type": "fn(index: number, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Applies the bone transform associated with the given index to the given vertex position. Returns the updated vector."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "bind": {
          "!type": "fn(skeleton: +THREE.Skeleton, bindMatrix: +THREE.Matrix4)",
          "!doc": "Binds the given skeleton to the skinned mesh."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the skinned mesh, and updates SkinnedMesh. The bounding box is not automatically computed by the engine; this method must be called by your app. If the skinned mesh is animated, the bounding box should be recomputed per frame in order to reflect the current animation state."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the skinned mesh, and updates SkinnedMesh. The bounding sphere is automatically computed by the engine once when it is needed, e.g., for ray casting and view frustum culling. If the skinned mesh is animated, the bounding sphere should be recomputed per frame in order to reflect the current animation state."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getVertexPosition": {
          "!type": "fn(index: number, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the local-space position of the vertex at the given index, taking into account the current animation state of both morph targets and skinning."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "normalizeSkinWeights": {
          "!type": "fn()",
          "!doc": "Normalizes the skin weights which are defined as a buffer attribute in the skinned mesh's geometry."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "pose": {
          "!type": "fn()",
          "!doc": "This method sets the skinned mesh in the rest pose)."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this line."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateMorphTargets": {
          "!type": "fn()",
          "!doc": "Sets the values of Mesh and Mesh to make sure existing morph targets can influence this 3D object."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new skinned mesh.",
      "!type": "fn(geometry: +THREE.BufferGeometry, material: +THREE.Material)"
    },
    "Source": {
      "!url": "https://threejs.org/docs/#api/en/textures/Source",
      "prototype": {
        "data": {
          "!type": "?",
          "!doc": "The data definition of a texture."
        },
        "dataReady": {
          "!type": "bool",
          "!doc": "This property is only relevant when Source is set to true and provides more control on how texture data should be processed. When dataReady is set to false, the engine performs the memory allocation (if necessary) but does not transfer the data into the GPU memory."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the source."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "When the property is set to true, the engine allocates the memory for the texture (if necessary) and triggers the actual texture upload to the GPU next time the source is used."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the source."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Source is set to true."
        },
        "getSize": {
          "!type": "fn(target: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns the dimensions of the source into the given target vector."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the source into JSON."
        }
      },
      "!doc": "Constructs a new video texture.",
      "!type": "fn(data: ?)"
    },
    "Sphere": {
      "!url": "https://threejs.org/docs/#api/en/math/Sphere",
      "prototype": {
        "center": {
          "!type": "+THREE.Vector3",
          "!doc": "The center of the sphere"
        },
        "radius": {
          "!type": "number",
          "!doc": "The radius of the sphere."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.Sphere",
          "!doc": "Transforms this sphere with the given 4x4 transformation matrix."
        },
        "clampPoint": {
          "!type": "fn(point: +THREE.Vector3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Clamps a point within the sphere. If the point is outside the sphere, it will clamp it to the closest point on the edge of the sphere. Points already inside the sphere will not be affected."
        },
        "clone": {
          "!type": "fn() -> +THREE.Sphere",
          "!doc": "Returns a new sphere with copied values from this instance."
        },
        "containsPoint": {
          "!type": "fn(point: +THREE.Vector3) -> bool",
          "!doc": "Returns true if this sphere contains the given point inclusive of the surface of the sphere."
        },
        "copy": {
          "!type": "fn(sphere: +THREE.Sphere) -> +THREE.Sphere",
          "!doc": "Copies the values of the given sphere to this instance."
        },
        "distanceToPoint": {
          "!type": "fn(point: +THREE.Vector3) -> number",
          "!doc": "Returns the closest distance from the boundary of the sphere to the given point. If the sphere contains the point, the distance will be negative."
        },
        "equals": {
          "!type": "fn(sphere: +THREE.Sphere) -> bool",
          "!doc": "Returns true if this sphere is equal with the given one."
        },
        "expandByPoint": {
          "!type": "fn(point: +THREE.Vector3) -> +THREE.Sphere",
          "!doc": "Expands the boundaries of this sphere to include the given point."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Sphere",
          "!doc": "Returns a serialized structure of the bounding sphere."
        },
        "getBoundingBox": {
          "!type": "fn(target: +THREE.Box3) -> +THREE.Box3",
          "!doc": "Returns a bounding box that encloses this sphere."
        },
        "intersectsBox": {
          "!type": "fn(box: +THREE.Box3) -> bool",
          "!doc": "Returns true if this sphere intersects with the given box."
        },
        "intersectsPlane": {
          "!type": "fn(plane: +THREE.Plane) -> bool",
          "!doc": "Returns true if this sphere intersects with the given plane."
        },
        "intersectsSphere": {
          "!type": "fn(sphere: +THREE.Sphere) -> bool",
          "!doc": "Returns true if this sphere intersects with the given one."
        },
        "isEmpty": {
          "!type": "fn() -> bool",
          "!doc": "Returns true if the sphere is empty (the radius set to a negative number). Spheres with a radius of 0 contain only their center point and are not considered to be empty."
        },
        "makeEmpty": {
          "!type": "fn() -> +THREE.Sphere",
          "!doc": "Makes this sphere empty which means in encloses a zero space in 3D."
        },
        "set": {
          "!type": "fn(center: +THREE.Vector3, radius: number) -> +THREE.Sphere",
          "!doc": "Sets the sphere's components by copying the given values."
        },
        "setFromPoints": {
          "!type": "fn(points, optionalCenter: +THREE.Vector3) -> +THREE.Sphere",
          "!doc": "Computes the minimum bounding sphere for list of points. If the optional center point is given, it is used as the sphere's center. Otherwise, the center of the axis-aligned bounding box encompassing the points is calculated."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Returns a serialized structure of the bounding sphere."
        },
        "translate": {
          "!type": "fn(offset: +THREE.Vector3) -> +THREE.Sphere",
          "!doc": "Translates the sphere's center by the given offset."
        },
        "union": {
          "!type": "fn(sphere: +THREE.Sphere) -> +THREE.Sphere",
          "!doc": "Expands this sphere to enclose both the original sphere and the given sphere."
        }
      },
      "!doc": "Constructs a new sphere.",
      "!type": "fn(center: +THREE.Vector3, radius: number)"
    },
    "SphereGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/SphereGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.SphereGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new sphere geometry.",
      "!type": "fn(radius: number, widthSegments: number, heightSegments: number, phiStart: number, phiLength: number, thetaStart: number, thetaLength: number)"
    },
    "Spherical": {
      "!url": "https://threejs.org/docs/#api/en/math/Spherical",
      "prototype": {
        "phi": {
          "!type": "number",
          "!doc": "The polar angle in radians from the y (up) axis."
        },
        "radius": {
          "!type": "number",
          "!doc": "The radius, or the Euclidean distance (straight-line distance) from the point to the origin."
        },
        "theta": {
          "!type": "number",
          "!doc": "The equator/azimuthal angle in radians around the y (up) axis."
        },
        "clone": {
          "!type": "fn() -> +THREE.Spherical",
          "!doc": "Returns a new spherical with copied values from this instance."
        },
        "copy": {
          "!type": "fn(other: +THREE.Spherical) -> +THREE.Spherical",
          "!doc": "Copies the values of the given spherical to this instance."
        },
        "makeSafe": {
          "!type": "fn() -> +THREE.Spherical",
          "!doc": "Restricts the polar angle [page:.phi phi] to be between 0.000001 and pi - 0.000001."
        },
        "set": {
          "!type": "fn(radius: number, phi: number, theta: number) -> +THREE.Spherical",
          "!doc": "Sets the spherical components by copying the given values."
        },
        "setFromCartesianCoords": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.Spherical",
          "!doc": "Sets the spherical components from the given Cartesian coordinates."
        },
        "setFromVector3": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Spherical",
          "!doc": "Sets the spherical components from the given vector which is assumed to hold Cartesian coordinates."
        }
      },
      "!doc": "Constructs a new spherical.",
      "!type": "fn(radius: number, phi: number, theta: number)"
    },
    "SphericalHarmonics3": {
      "!url": "https://threejs.org/docs/#api/en/math/SphericalHarmonics3",
      "prototype": {
        "coefficients": {
          "!doc": "An array holding the (9) SH coefficients."
        },
        "add": {
          "!type": "fn(sh: +THREE.SphericalHarmonics3) -> +THREE.SphericalHarmonics3",
          "!doc": "Adds the given SH to this instance."
        },
        "addScaledSH": {
          "!type": "fn(sh: +THREE.SphericalHarmonics3, s: number) -> +THREE.SphericalHarmonics3",
          "!doc": "A convenience method for performing SphericalHarmonics3 and SphericalHarmonics3 at once."
        },
        "clone": {
          "!type": "fn() -> +THREE.SphericalHarmonics3",
          "!doc": "Returns a new spherical harmonics with copied values from this instance."
        },
        "copy": {
          "!type": "fn(sh: +THREE.SphericalHarmonics3) -> +THREE.SphericalHarmonics3",
          "!doc": "Copies the values of the given spherical harmonics to this instance."
        },
        "equals": {
          "!type": "fn(sh: +THREE.SphericalHarmonics3) -> bool",
          "!doc": "Returns true if this spherical harmonics is equal with the given one."
        },
        "fromArray": {
          "!type": "fn(array, offset: number) -> +THREE.SphericalHarmonics3",
          "!doc": "Sets the SH coefficients of this instance from the given array."
        },
        "getAt": {
          "!type": "fn(normal: +THREE.Vector3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the radiance in the direction of the given normal."
        },
        "getIrradianceAt": {
          "!type": "fn(normal: +THREE.Vector3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the irradiance (radiance convolved with cosine lobe) in the direction of the given normal."
        },
        "lerp": {
          "!type": "fn(sh: +THREE.SphericalHarmonics3, alpha: number) -> +THREE.SphericalHarmonics3",
          "!doc": "Linear interpolates between the given SH and this instance by the given alpha factor."
        },
        "scale": {
          "!type": "fn(s: number) -> +THREE.SphericalHarmonics3",
          "!doc": "Scales this SH by the given scale factor."
        },
        "set": {
          "!type": "fn(coefficients) -> +THREE.SphericalHarmonics3",
          "!doc": "Sets the given SH coefficients to this instance by copying the values."
        },
        "toArray": {
          "!type": "fn(array, offset: number)",
          "!doc": "Returns an array with the SH coefficients, or copies them into the provided array. The coefficients are represented as numbers."
        },
        "zero": {
          "!type": "fn() -> +THREE.SphericalHarmonics3",
          "!doc": "Sets all SH coefficients to 0."
        },
        "getBasisAt": {
          "!type": "fn(normal: +THREE.Vector3, shBasis)",
          "!doc": "Computes the SH basis for the given normal vector."
        }
      },
      "!doc": "Constructs a new spherical harmonics.",
      "!type": "fn()"
    },
    "SplineCurve": {
      "!url": "https://threejs.org/docs/#api/en/extras/SplineCurve",
      "prototype": {
        "!proto": "THREE.Curve.prototype",
        "arcLengthDivisions": {
          "!type": "number",
          "!doc": "This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via Curve. To ensure precision when using methods like Curve, it is recommended to increase the value of this property if the curve is very large."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Must be set to true if the curve parameters have changed."
        },
        "points": {
          "!doc": "An array of 2D points defining the curve."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "clone": {
          "!type": "fn() -> +THREE.Curve",
          "!doc": "Returns a new curve with copied values from this instance."
        },
        "computeFrenetFrames": {
          "!type": "fn(segments: number, closed: bool) -> object",
          "!doc": "Generates the Frenet Frames. Requires a curve definition in 3D space. Used in geometries like TubeGeometry or ExtrudeGeometry."
        },
        "copy": {
          "!type": "fn(source: +THREE.Curve) -> +THREE.Curve",
          "!doc": "Copies the values of the given curve to this instance."
        },
        "fromJSON": {
          "!type": "fn(json: object) -> +THREE.Curve",
          "!doc": "Deserializes the curve from the given JSON."
        },
        "getLength": {
          "!type": "fn() -> number",
          "!doc": "Returns the total arc length of the curve."
        },
        "getLengths": {
          "!type": "fn(divisions: number)",
          "!doc": "Returns an array of cumulative segment lengths of the curve."
        },
        "getPoint": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a point on the curve."
        },
        "getPointAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "This method returns a vector in 2D or 3D space (depending on the curve definition) for the given interpolation factor. Unlike Curve, this method honors the length of the curve which equidistant samples."
        },
        "getPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape."
        },
        "getSpacedPoints": {
          "!type": "fn(divisions: number)",
          "!doc": "This method samples the curve via Curve and returns an array of points representing the curve shape. Unlike Curve, this method returns equi-spaced points across the entire curve."
        },
        "getTangent": {
          "!type": "fn(t: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Returns a unit vector tangent for the given interpolation factor. If the derived curve does not implement its tangent derivation, two points a small delta apart will be used to find its gradient which seems to give a reasonable approximation."
        },
        "getTangentAt": {
          "!type": "fn(u: number, optionalTarget: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Same as Curve but with equidistant samples."
        },
        "getUtoTmapping": {
          "!type": "fn(u: number, distance: number) -> number",
          "!doc": "Given an interpolation factor in the range [0,1], this method returns an updated interpolation factor in the same range that can be ued to sample equidistant points from a curve."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the curve into JSON."
        },
        "updateArcLengths": {
          "!type": "fn()",
          "!doc": "Update the cumulative segment distance cache. The method must be called every time curve parameters are changed. If an updated curve is part of a composed curve like CurvePath, this method must be called on the composed curve, too."
        }
      },
      "!doc": "Constructs a new 2D spline curve.",
      "!type": "fn(points)"
    },
    "SpotLight": {
      "!url": "https://threejs.org/docs/#api/en/lights/SpotLight",
      "prototype": {
        "!proto": "THREE.Light.prototype",
        "angle": {
          "!type": "number",
          "!doc": "Maximum angle of light dispersion from its direction whose upper bound is Math.PI/2."
        },
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "The light's color."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "decay": {
          "!type": "number",
          "!doc": "The amount the light dims along the distance of the light. In context of physically-correct rendering the default value should not be changed."
        },
        "distance": {
          "!type": "number",
          "!doc": "Maximum range of the light. 0 means no limit."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The light's intensity."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "A texture used to modulate the color of the light. The spot light color is mixed with the RGB value of this texture, with a ratio corresponding to its alpha value. The cookie-like masking effect is reproduced using pixel values (0, 0, 0, 1-cookie_value). *Warning*: This property is disabled if Object3D is set to false."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "penumbra": {
          "!type": "number",
          "!doc": "Percent of the spotlight cone that is attenuated due to penumbra. Value range is [0,1]."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "power": {
          "!type": "number",
          "!doc": "The light's power. Power is the luminous power of the light measured in lumens (lm). Changing the power will also change the light's intensity."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "shadow": {
          "!type": "+THREE.SpotLightShadow",
          "!doc": "This property holds the light's shadow configuration."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "target": {
          "!type": "+THREE.Object3D",
          "!doc": "The spot light points from its position to the target's position. For the target's position to be changed to anything other than the default, it must be added to the scene. It is also possible to set the target to be another 3D object in the scene. The light will now track the target object."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new spot light.",
      "!type": "fn(color: number, intensity: number, distance: number, angle: number, penumbra: number, decay: number)"
    },
    "SpotLightHelper": {
      "!url": "https://threejs.org/docs/#api/en/helpers/SpotLightHelper",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "color": {
          "!type": "number",
          "!doc": "The color parameter passed in the constructor. If not set, the helper will take the color of the light."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "light": {
          "!type": "+THREE.SpotLight",
          "!doc": "The light being visualized."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Abstract method to get intersections between a casted ray and this 3D object. Renderable 3D objects such as Mesh, Line or Points implement this method in order to use raycasting."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "update": {
          "!type": "fn()",
          "!doc": "Updates the helper to match the position and direction of the light being visualized."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new spot light helper.",
      "!type": "fn(light: +THREE.HemisphereLight, color: number)"
    },
    "SpotLightShadow": {
      "!url": "https://threejs.org/docs/#api/en/lights/SpotLightShadow",
      "prototype": {
        "!proto": "THREE.LightShadow.prototype",
        "aspect": {
          "!type": "number",
          "!doc": "Texture aspect ratio."
        },
        "autoUpdate": {
          "!type": "bool",
          "!doc": "Enables automatic updates of the light's shadow. If you do not require dynamic lighting / shadows, you may set this to false."
        },
        "bias": {
          "!type": "number",
          "!doc": "Shadow map bias, how much to add or subtract from the normalized depth when deciding whether a surface is in shadow. The default is 0. Very tiny adjustments here (in the order of 0.0001) may help reduce artifacts in shadows."
        },
        "biasNode": {
          "!doc": "A node version of bias. Only supported with WebGPURenderer. If a bias node is defined, bias has no effect."
        },
        "blurSamples": {
          "!type": "number",
          "!doc": "The amount of samples to use when blurring a VSM shadow map."
        },
        "camera": {
          "!type": "+THREE.Camera",
          "!doc": "The light's view of the world."
        },
        "focus": {
          "!type": "number",
          "!doc": "Used to focus the shadow camera. The camera's field of view is set as a percentage of the spotlight's field-of-view. Range is [0, 1]."
        },
        "intensity": {
          "!type": "number",
          "!doc": "The intensity of the shadow. The default is 1. Valid values are in the range [0, 1]."
        },
        "map": {
          "!type": "+THREE.RenderTarget",
          "!doc": "The depth map generated using the internal camera; a location beyond a pixel's depth is in shadow. Computed internally during rendering."
        },
        "mapPass": {
          "!type": "+THREE.RenderTarget",
          "!doc": "The distribution map generated using the internal camera; an occlusion is calculated based on the distribution of depths. Computed internally during rendering."
        },
        "mapSize": {
          "!type": "+THREE.Vector2",
          "!doc": "Defines the width and height of the shadow map. Higher values give better quality shadows at the cost of computation time. Values must be powers of two."
        },
        "mapType": {
          "!type": "number",
          "!doc": "The type of shadow texture. The default is UnsignedByteType."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Model to shadow camera space, to compute location and depth in shadow map. This is computed internally during rendering."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, shadow maps will be updated in the next render call. If you have set LightShadow to false, you will need to set this property to true and then make a render call to update the light's shadow."
        },
        "normalBias": {
          "!type": "number",
          "!doc": "Defines how much the position used to query the shadow map is offset along the object normal. The default is 0. Increasing this value can be used to reduce shadow acne especially in large scenes where light shines onto geometry at a shallow angle. The cost is that shadows may appear distorted."
        },
        "radius": {
          "!type": "number",
          "!doc": "Setting this to values greater than 1 will blur the edges of the shadow. High values will cause unwanted banding effects in the shadows - a greater map size will allow for a higher value to be used here before these effects become visible. The property has no effect when the shadow map type is BasicShadowMap."
        },
        "clone": {
          "!type": "fn() -> +THREE.LightShadow",
          "!doc": "Returns a new light shadow instance with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.LightShadow) -> +THREE.LightShadow",
          "!doc": "Copies the values of the given light shadow instance to this instance."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getFrameExtents": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "Returns the frame extends."
        },
        "getFrustum": {
          "!type": "fn() -> +THREE.Frustum",
          "!doc": "Gets the shadow cameras frustum. Used internally by the renderer to cull objects."
        },
        "getViewport": {
          "!type": "fn(viewportIndex: number) -> +THREE.Vector4",
          "!doc": "Returns a viewport definition for the given viewport index."
        },
        "getViewportCount": {
          "!type": "fn() -> number",
          "!doc": "Used internally by the renderer to get the number of viewports that need to be rendered for this shadow."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the light shadow into JSON."
        },
        "updateMatrices": {
          "!type": "fn(light: +THREE.Light)",
          "!doc": "Update the matrices for the camera and shadow, used internally by the renderer."
        }
      },
      "!doc": "Constructs a new spot light shadow.",
      "!type": "fn()"
    },
    "Sprite": {
      "!url": "https://threejs.org/docs/#api/en/objects/Sprite",
      "prototype": {
        "!proto": "THREE.Object3D.prototype",
        "animations": {
          "!doc": "An array holding the animation clips of the 3D object."
        },
        "castShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered into shadow maps."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The sprite's anchor point, and the point around which the sprite rotates. A value of (0.5, 0.5) corresponds to the midpoint of the sprite. A value of (0, 0) corresponds to the lower left corner of the sprite."
        },
        "children": {
          "!doc": "An array holding the child 3D objects of this instance."
        },
        "count": {
          "!type": "number",
          "!doc": "The number of instances of this sprite. Can only be used with WebGPURenderer."
        },
        "customDepthMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes. When shadow-casting with a DirectionalLight or SpotLight, if you are modifying vertex positions in the vertex shader you must specify a custom depth material for proper shadows. Only relevant in context of WebGLRenderer."
        },
        "customDistanceMaterial": {
          "!type": "+THREE.Material",
          "!doc": "Same as Object3D, but used with PointLight. Only relevant in context of WebGLRenderer."
        },
        "frustumCulled": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is honored by view frustum culling."
        },
        "geometry": {
          "!type": "+THREE.BufferGeometry",
          "!doc": "The sprite geometry."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "layers": {
          "!type": "+THREE.Layers",
          "!doc": "The layer membership of the 3D object. The 3D object is only visible if it has at least one layer in common with the camera in use. This property can also be used to filter out unwanted objects in ray-intersection tests when using Raycaster."
        },
        "material": {
          "!type": "+THREE.SpriteMaterial",
          "!doc": "The sprite material."
        },
        "matrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in local space."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the local matrix from position, rotation and scale every frame. If set to false, the app is responsible for recomputing the local matrix by calling updateMatrix(). The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_AUTO_UPDATE."
        },
        "matrixWorld": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's transformation matrix in world space. If the 3D object has no parent, then it's identical to the local transformation matrix"
        },
        "matrixWorldAutoUpdate": {
          "!type": "bool",
          "!doc": "When set to true, the engine automatically computes the world matrix from the current local matrix and the object's transformation hierarchy. If set to false, the app is responsible for recomputing the world matrix by directly updating the matrixWorld property. The default values for all 3D objects is defined by Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE."
        },
        "matrixWorldNeedsUpdate": {
          "!type": "bool",
          "!doc": "When set to true, it calculates the world matrix in that frame and resets this property to false."
        },
        "modelViewMatrix": {
          "!type": "+THREE.Matrix4",
          "!doc": "Represents the object's model-view matrix."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the 3D object."
        },
        "normalMatrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "Represents the object's normal matrix."
        },
        "parent": {
          "!type": "+THREE.Object3D",
          "!doc": "A reference to the parent object."
        },
        "pivot": {
          "!type": "+THREE.Vector3",
          "!doc": "The pivot point for rotation and scale transformations. When set, rotation and scale are applied around this point instead of the object's origin."
        },
        "position": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local position."
        },
        "quaternion": {
          "!type": "+THREE.Quaternion",
          "!doc": "Represents the object's local rotation as Quaternions."
        },
        "receiveShadow": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object is affected by shadows in the scene."
        },
        "renderOrder": {
          "!type": "number",
          "!doc": "This value allows the default rendering order of scene graph objects to be overridden although opaque and transparent objects remain sorted independently. When this property is set for an instance of Group,all descendants objects will be sorted and rendered together. Sorting is from lowest to highest render order."
        },
        "rotation": {
          "!type": "+THREE.Euler",
          "!doc": "Represents the object's local rotation as Euler angles, in radians."
        },
        "scale": {
          "!type": "+THREE.Vector3",
          "!doc": "Represents the object's local scale."
        },
        "static": {
          "!type": "bool",
          "!doc": "Whether the 3D object is supposed to be static or not. If set to true, it means the 3D object is not going to be changed after the initial renderer. This includes geometry and material settings. A static 3D object can be processed by the renderer slightly faster since certain state checks can be bypassed. Only relevant in context of WebGPURenderer."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "up": {
          "!type": "+THREE.Vector3",
          "!doc": "Defines the up direction of the 3D object which influences the orientation via methods like Object3D. The default values for all 3D objects is defined by Object3D.DEFAULT_UP."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the 3D object. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the 3D object."
        },
        "visible": {
          "!type": "bool",
          "!doc": "When set to true, the 3D object gets rendered."
        },
        "add": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child to this 3D object. An arbitrary number of objects may be added. Any current parent on an object passed in here will be removed, since an object can have at most one parent."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4)",
          "!doc": "Applies the given transformation matrix to the object and updates the object's position, rotation and scale."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Object3D",
          "!doc": "Applies a rotation represented by given the quaternion to the 3D object."
        },
        "attach": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Adds the given 3D object as a child of this 3D object, while maintaining the object's world transform. This method does not support scene graphs having non-uniformly-scaled nodes(s)."
        },
        "clear": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes all child objects."
        },
        "clone": {
          "!type": "fn(recursive: bool) -> +THREE.Object3D",
          "!doc": "Returns a new 3D object with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Object3D, recursive: bool) -> +THREE.Object3D",
          "!doc": "Copies the values of the given 3D object to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "getObjectById": {
          "!type": "fn(id: number) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching ID."
        },
        "getObjectByName": {
          "!type": "fn(name: string) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching name."
        },
        "getObjectByProperty": {
          "!type": "fn(name: string, value: ?) -> +THREE.Object3D",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns the first with a matching property value."
        },
        "getObjectsByProperty": {
          "!type": "fn(name: string, value: ?, result)",
          "!doc": "Searches through the 3D object and its children, starting with the 3D object itself, and returns all 3D objects with a matching property value."
        },
        "getWorldDirection": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the (\"look\") direction of the 3D object in world space."
        },
        "getWorldPosition": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the position of the 3D object in world space."
        },
        "getWorldQuaternion": {
          "!type": "fn(target: +THREE.Quaternion) -> +THREE.Quaternion",
          "!doc": "Returns a Quaternion representing the position of the 3D object in world space."
        },
        "getWorldScale": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns a vector representing the scale of the 3D object in world space."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "localToWorld": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's local space to world space."
        },
        "lookAt": {
          "!type": "fn(x: number, y: number, z: number)",
          "!doc": "Rotates the object to face a point in world space. This method does not support objects having non-uniformly-scaled parent(s)."
        },
        "onAfterRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered."
        },
        "onAfterShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately after a 3D object is rendered to a shadow map."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, material: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered."
        },
        "onBeforeShadow": {
          "!type": "fn(renderer: +THREE.Renderer, object: +THREE.Object3D, camera: +THREE.Camera, shadowCamera: +THREE.Camera, geometry: +THREE.BufferGeometry, depthMaterial: +THREE.Material, group: object)",
          "!doc": "A callback that is executed immediately before a 3D object is rendered to a shadow map."
        },
        "raycast": {
          "!type": "fn(raycaster: +THREE.Raycaster, intersects)",
          "!doc": "Computes intersection points between a casted ray and this sprite."
        },
        "remove": {
          "!type": "fn(object: +THREE.Object3D) -> +THREE.Object3D",
          "!doc": "Removes the given 3D object as child from this 3D object. An arbitrary number of objects may be removed."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "removeFromParent": {
          "!type": "fn() -> +THREE.Object3D",
          "!doc": "Removes this 3D object from its current parent."
        },
        "rotateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in local space."
        },
        "rotateOnWorldAxis": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object along an axis in world space."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its X axis in local space."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Y axis in local space."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.Object3D",
          "!doc": "Rotates the 3D object around its Z axis in local space."
        },
        "setRotationFromAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number)",
          "!doc": "Sets the given rotation represented as an axis/angle couple to the 3D object."
        },
        "setRotationFromEuler": {
          "!type": "fn(euler: +THREE.Euler)",
          "!doc": "Sets the given rotation represented as Euler angles to the 3D object."
        },
        "setRotationFromMatrix": {
          "!type": "fn(m: +THREE.Matrix4)",
          "!doc": "Sets the given rotation represented as rotation matrix to the 3D object."
        },
        "setRotationFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion)",
          "!doc": "Sets the given rotation represented as a Quaternion to the 3D object."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the 3D object into JSON."
        },
        "translateOnAxis": {
          "!type": "fn(axis: +THREE.Vector3, distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along the given axis in local space."
        },
        "translateX": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its X-axis in local space."
        },
        "translateY": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Y-axis in local space."
        },
        "translateZ": {
          "!type": "fn(distance: number) -> +THREE.Object3D",
          "!doc": "Translate the 3D object by a distance along its Z-axis in local space."
        },
        "traverse": {
          "!type": "fn(callback: fn())",
          "!doc": "Executes the callback on this 3D object and all descendants. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseAncestors": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for all ancestors. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "traverseVisible": {
          "!type": "fn(callback: fn())",
          "!doc": "Like Object3D, but the callback will only be executed for visible 3D objects. Descendants of invisible 3D objects are not traversed. Note: Modifying the scene graph inside the callback is discouraged."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the transformation matrix in local space by computing it from the current position, rotation and scale values."
        },
        "updateMatrixWorld": {
          "!type": "fn(force: bool)",
          "!doc": "Updates the transformation matrix in world space of this 3D objects and its descendants. To ensure correct results, this method also recomputes the 3D object's transformation matrix in local space. The computation of the local and world matrix can be controlled with the Object3D and Object3D flags which are both true by default. Set these flags to false if you need more control over the update matrix process."
        },
        "updateWorldMatrix": {
          "!type": "fn(updateParents: bool, updateChildren: bool)",
          "!doc": "An alternative version of Object3D with more control over the update of ancestor and descendant nodes."
        },
        "worldToLocal": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Converts the given vector from this 3D object's world space to local space."
        }
      },
      "!doc": "Constructs a new sprite.",
      "!type": "fn(material: +THREE.SpriteMaterial)"
    },
    "SpriteMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/SpriteMaterial",
      "prototype": {
        "!proto": "THREE.Material.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaMap": {
          "!type": "+THREE.Texture",
          "!doc": "The alpha map is a grayscale texture that controls the opacity across the surface (black: fully transparent; white: fully opaque). Only the color of the texture is used, ignoring the alpha channel if one exists. For RGB and RGBA textures, the renderer will use the green channel when sampling this texture due to the extra bit of precision provided for green in DXT-compressed and uncompressed RGB 565 formats. Luminance-only and luminance/alpha textures will also still work as expected."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "color": {
          "!type": "+THREE.Color",
          "!doc": "Color of the material."
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether the material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "map": {
          "!type": "+THREE.Texture",
          "!doc": "The color map. May optionally include an alpha channel, typically combined with Material or Material. The texture map color is modulated by the diffuse color."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "rotation": {
          "!type": "number",
          "!doc": "The rotation of the sprite in radians."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "sizeAttenuation": {
          "!type": "bool",
          "!doc": "Specifies whether size of the sprite is attenuated by the camera depth (perspective camera only)."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Overwritten since sprite materials are transparent by default."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Material) -> +THREE.Material",
          "!doc": "Copies the values of the given material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "In case Material is used, this callback can be used to identify values of settings used in onBeforeCompile(), so three.js can reuse a cached shader or recompile the shader for this material as needed. This method can only be used when rendering with WebGLRenderer."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the material into JSON."
        }
      },
      "!doc": "Constructs a new sprite material.",
      "!type": "fn(parameters: object)"
    },
    "SpriteNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/SpriteNodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Whether this material is affected by lights or not."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "This property makes it possible to define the position of the sprite with a node. That can be useful when the material is used with instanced rendering and node data are defined with an instanced attribute node: ``js const positionAttribute = new InstancedBufferAttribute( new Float32Array( positions ), 3 ); material.positionNode = instancedBufferAttribute( positionAttribute ); ` Another possibility is to compute the instanced data with a compute shader: `js const positionBuffer = instancedArray( particleCount, 'vec3' ); particleMaterial.positionNode = positionBuffer.toAttribute(); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "rotationNode": {
          "!doc": "The rotation of sprite materials is by default inferred from the rotation, property. This node property allows to overwrite the default and define the rotation with a node instead. If you don't want to overwrite the rotation but modify the existing value instead, use materialRotation."
        },
        "scaleNode": {
          "!doc": "This node property provides an additional way to scale sprites next to Object3D.scale. The scale transformation based in Object3D.scale is multiplied with the scale value of this node in the vertex shader."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "sizeAttenuation": {
          "!type": "bool",
          "!doc": "Whether to use size attenuation or not."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "In Sprites, the transparent property is enabled by default."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the environment node from the material."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightingModel",
          "!doc": "This method should be implemented by most derived materials since it defines the material's lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method implements the sprite specific vertex shader."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Abstract interface method that can be implemented by derived materials to setup material-specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new sprite node material.",
      "!type": "fn(parameters: object)"
    },
    "StereoCamera": {
      "!url": "https://threejs.org/docs/#api/en/cameras/StereoCamera",
      "prototype": {
        "aspect": {
          "!type": "number",
          "!doc": "The aspect."
        },
        "cameraL": {
          "!type": "+THREE.PerspectiveCamera",
          "!doc": "The camera representing the left eye. This is added to layer 1 so objects to be rendered by the left camera must also be added to this layer."
        },
        "cameraR": {
          "!type": "+THREE.PerspectiveCamera",
          "!doc": "The camera representing the right eye. This is added to layer 2 so objects to be rendered by the right camera must also be added to this layer."
        },
        "eyeSep": {
          "!type": "number",
          "!doc": "The eye separation which represents the distance between the left and right camera."
        },
        "type": {
          "!type": "string",
          "!doc": "The type property is used for detecting the object type in context of serialization/deserialization."
        },
        "update": {
          "!type": "fn(camera: +THREE.PerspectiveCamera)",
          "!doc": "Updates the stereo camera based on the given perspective camera."
        }
      },
      "!doc": "Constructs a new stereo camera.",
      "!type": "fn()"
    },
    "StringKeyframeTrack": {
      "!url": "https://threejs.org/docs/#api/en/animation/StringKeyframeTrack",
      "prototype": {
        "!proto": "THREE.KeyframeTrack.prototype",
        "DefaultInterpolation": {
          "!type": "+THREE.InterpolateLinear",
          "!doc": "The default interpolation type of this keyframe track."
        },
        "TimeBufferType": {
          "!type": "+TypedArray",
          "!doc": "The time buffer type of this keyframe track."
        },
        "ValueBufferType": {
          "!type": "+TypedArray",
          "!doc": "The value buffer type of this keyframe track."
        },
        "ValueTypeName": {
          "!type": "string",
          "!doc": "The value type name."
        },
        "name": {
          "!type": "string",
          "!doc": "The track's name can refer to morph targets or bones or possibly other values within an animated object. See PropertyBinding for the forms of strings that can be parsed for property binding."
        },
        "times": {
          "!type": "+Float32Array",
          "!doc": "The keyframe times."
        },
        "values": {
          "!type": "+Float32Array",
          "!doc": "The keyframe values."
        },
        "InterpolantFactoryMethodBezier": {
          "!type": "fn(result: +TypedArray) -> +THREE.BezierInterpolant",
          "!doc": "Factory method for creating a new Bezier interpolant. The Bezier interpolant requires tangent data to be set via the settings property on the track before creating the interpolant. The settings should contain: - inTangents: Float32Array with [time, value] pairs per keyframe per component - outTangents: Float32Array with [time, value] pairs per keyframe per component"
        },
        "InterpolantFactoryMethodDiscrete": {
          "!type": "fn(result: +TypedArray) -> +THREE.DiscreteInterpolant",
          "!doc": "Factory method for creating a new discrete interpolant."
        },
        "InterpolantFactoryMethodLinear": {
          "!type": "fn(result: +TypedArray) -> +THREE.LinearInterpolant",
          "!doc": "Factory method for creating a new linear interpolant."
        },
        "InterpolantFactoryMethodSmooth": {
          "!type": "fn(result: +TypedArray) -> +THREE.CubicInterpolant",
          "!doc": "Factory method for creating a new smooth interpolant."
        },
        "clone": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Returns a new keyframe track with copied values from this instance."
        },
        "getInterpolation": {
          "!type": "fn() -> +THREE.InterpolateLinear",
          "!doc": "Returns the current interpolation type."
        },
        "getValueSize": {
          "!type": "fn() -> number",
          "!doc": "Returns the value size."
        },
        "optimize": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Optimizes this keyframe track by removing equivalent sequential keys (which are common in morph target sequences)."
        },
        "scale": {
          "!type": "fn(timeScale: number) -> +THREE.KeyframeTrack",
          "!doc": "Scale all keyframe times by a factor (useful for frame - seconds conversions)."
        },
        "setInterpolation": {
          "!type": "fn(interpolation: +THREE.InterpolateLinear) -> +THREE.KeyframeTrack",
          "!doc": "Defines the interpolation factor method for this keyframe track."
        },
        "shift": {
          "!type": "fn(timeOffset: number) -> +THREE.KeyframeTrack",
          "!doc": "Moves all keyframes either forward or backward in time."
        },
        "trim": {
          "!type": "fn(startTime: number, endTime: number) -> +THREE.KeyframeTrack",
          "!doc": "Removes keyframes before and after animation without changing any values within the defined time range. Note: The method does not shift around keys to the start of the track time, because for interpolated keys this will change their values"
        },
        "validate": {
          "!type": "fn() -> bool",
          "!doc": "Performs minimal validation on the keyframe track. Returns true if the values are valid."
        }
      },
      "!doc": "Constructs a new string keyframe track. This keyframe track type has no interpolation parameter because the interpolation is always discrete.",
      "!type": "fn(name: string, times, values)"
    },
    "TetrahedronGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/TetrahedronGeometry",
      "prototype": {
        "!proto": "THREE.PolyhedronGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.TetrahedronGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new tetrahedron geometry.",
      "!type": "fn(radius: number, detail: number)"
    },
    "Texture": {
      "!url": "https://threejs.org/docs/#api/en/textures/Texture",
      "prototype": {
        "!proto": "THREE.EventDispatcher.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure the flip on bitmap creation instead."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Set this to false if you are creating mipmaps manually."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image object holding the texture data."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel."
        },
        "mipmaps": {
          "!doc": "An array holding user-defined mipmaps."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries)."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "DEFAULT_ANISOTROPY": {
          "!type": "number",
          "!doc": "The default anisotropy value for all textures."
        },
        "DEFAULT_IMAGE": {
          "!type": "+THREE.Image",
          "!doc": "The default image for all textures."
        },
        "DEFAULT_MAPPING": {
          "!type": "number",
          "!doc": "The default mapping for all textures."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new texture.",
      "!type": "fn(image: object, mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, format: number, type: number, anisotropy: number, colorSpace: string)"
    },
    "TextureLoader": {
      "!url": "https://threejs.org/docs/#api/en/loaders/TextureLoader",
      "prototype": {
        "!proto": "THREE.Loader.prototype",
        "crossOrigin": {
          "!type": "string",
          "!doc": "The crossOrigin string to implement CORS for loading the url from a different domain that allows CORS."
        },
        "manager": {
          "!type": "+THREE.LoadingManager",
          "!doc": "The loading manager."
        },
        "path": {
          "!type": "string",
          "!doc": "The base path from which the asset will be loaded."
        },
        "requestHeader": {
          "!doc": "The [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header) used in HTTP request."
        },
        "resourcePath": {
          "!type": "string",
          "!doc": "The base path from which additional resources like textures will be loaded."
        },
        "withCredentials": {
          "!type": "bool",
          "!doc": "Whether the XMLHttpRequest uses credentials."
        },
        "abort": {
          "!type": "fn() -> +THREE.Loader",
          "!doc": "This method can be implemented in loaders for aborting ongoing requests."
        },
        "load": {
          "!type": "fn(url: string, onLoad: fn(), onProgress: +THREE.onProgressCallback, onError: +THREE.onErrorCallback) -> +THREE.Texture",
          "!doc": "Starts loading from the given URL and pass the fully loaded texture to the onLoad() callback. The method also returns a new texture object which can directly be used for material creation. If you do it this way, the texture may pop up in your scene once the respective loading process is finished."
        },
        "loadAsync": {
          "!type": "fn(url: string, onProgress: +THREE.onProgressCallback) -> +THREE.Promise",
          "!doc": "A async version of Loader."
        },
        "parse": {
          "!type": "fn(data: ?)",
          "!doc": "This method needs to be implemented by all concrete loaders. It holds the logic for parsing the asset into three.js entities."
        },
        "setCrossOrigin": {
          "!type": "fn(crossOrigin: string) -> +THREE.Loader",
          "!doc": "Sets the crossOrigin String to implement CORS for loading the URL from a different domain that allows CORS."
        },
        "setPath": {
          "!type": "fn(path: string) -> +THREE.Loader",
          "!doc": "Sets the base path for the asset."
        },
        "setRequestHeader": {
          "!type": "fn(requestHeader: object) -> +THREE.Loader",
          "!doc": "Sets the given request header."
        },
        "setResourcePath": {
          "!type": "fn(resourcePath: string) -> +THREE.Loader",
          "!doc": "Sets the base path for dependent resources like textures."
        },
        "setWithCredentials": {
          "!type": "fn(value: bool) -> +THREE.Loader",
          "!doc": "Whether the XMLHttpRequest uses credentials such as cookies, authorization headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials). Note: This setting has no effect if you are loading files locally or from the same domain."
        }
      },
      "!doc": "Constructs a new texture loader.",
      "!type": "fn(manager: +THREE.LoadingManager)"
    },
    "TextureUtils": {
      "!url": "https://threejs.org/docs/#api/en/extras/TextureUtils",
      "prototype": {
        "contain": {
          "!type": "fn(texture: +THREE.Texture, aspect: number) -> +THREE.Texture",
          "!doc": "Scales the texture as large as possible within its surface without cropping or stretching the texture. The method preserves the original aspect ratio of the texture. Akin to CSS object-fit: contain"
        },
        "cover": {
          "!type": "fn(texture: +THREE.Texture, aspect: number) -> +THREE.Texture",
          "!doc": "Scales the texture to the smallest possible size to fill the surface, leaving no empty space. The method preserves the original aspect ratio of the texture. Akin to CSS object-fit: cover."
        },
        "fill": {
          "!type": "fn(texture: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Configures the texture to the default transformation. Akin to CSS object-fit: fill."
        },
        "getByteLength": {
          "!type": "fn(width: number, height: number, format: number, type: number) -> number",
          "!doc": "Determines how many bytes must be used to represent the texture."
        }
      },
      "!type": "fn()"
    },
    "Timer": {
      "!url": "https://threejs.org/docs/#api/en/core/Timer",
      "prototype": {
        "connect": {
          "!type": "fn(document: +THREE.Document)",
          "!doc": "Connect the timer to the given document.Calling this method is not mandatory to use the timer but enables the usage of the Page Visibility API to avoid large time delta values."
        },
        "disconnect": {
          "!type": "fn()",
          "!doc": "Disconnects the timer from the DOM and also disables the usage of the Page Visibility API."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Can be used to free all internal resources. Usually called when the timer instance isn't required anymore."
        },
        "getDelta": {
          "!type": "fn() -> number",
          "!doc": "Returns the time delta in seconds."
        },
        "getElapsed": {
          "!type": "fn() -> number",
          "!doc": "Returns the elapsed time in seconds."
        },
        "getTimescale": {
          "!type": "fn() -> number",
          "!doc": "Returns the timescale."
        },
        "reset": {
          "!type": "fn() -> +THREE.Timer",
          "!doc": "Resets the time computation for the current simulation step."
        },
        "setTimescale": {
          "!type": "fn(timescale: number) -> +THREE.Timer",
          "!doc": "Sets the given timescale which scale the time delta computation in update()."
        },
        "update": {
          "!type": "fn(timestamp: number) -> +THREE.Timer",
          "!doc": "Updates the internal state of the timer. This method should be called once per simulation step and before you perform queries against the timer (e.g. via getDelta())."
        }
      },
      "!doc": "Constructs a new timer.",
      "!type": "fn()"
    },
    "TorusGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/TorusGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.TorusGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new torus geometry.",
      "!type": "fn(radius: number, tube: number, radialSegments: number, tubularSegments: number, arc: number, thetaStart: number, thetaLength: number)"
    },
    "TorusKnotGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/TorusKnotGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.TorusKnotGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new torus knot geometry.",
      "!type": "fn(radius: number, tube: number, tubularSegments: number, radialSegments: number, p: number, q: number)"
    },
    "Triangle": {
      "!url": "https://threejs.org/docs/#api/en/math/Triangle",
      "prototype": {
        "a": {
          "!type": "+THREE.Vector3",
          "!doc": "The first corner of the triangle."
        },
        "b": {
          "!type": "+THREE.Vector3",
          "!doc": "The second corner of the triangle."
        },
        "c": {
          "!type": "+THREE.Vector3",
          "!doc": "The third corner of the triangle."
        },
        "clone": {
          "!type": "fn() -> +THREE.Triangle",
          "!doc": "Returns a new triangle with copied values from this instance."
        },
        "closestPointToPoint": {
          "!type": "fn(p: +THREE.Vector3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Returns the closest point on the triangle to the given point."
        },
        "containsPoint": {
          "!type": "fn(point: +THREE.Vector3, a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3) -> bool",
          "!doc": "Returns true if the given point, when projected onto the plane of the triangle, lies within the triangle."
        },
        "copy": {
          "!type": "fn(triangle: +THREE.Triangle) -> +THREE.Triangle",
          "!doc": "Copies the values of the given triangle to this instance."
        },
        "equals": {
          "!type": "fn(triangle: +THREE.Triangle) -> bool",
          "!doc": "Returns true if this triangle is equal with the given one."
        },
        "getArea": {
          "!type": "fn() -> number",
          "!doc": "Computes the area of the triangle."
        },
        "getBarycoord": {
          "!type": "fn(point: +THREE.Vector3, a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Computes a barycentric coordinates from the given vector. Returns null if the triangle is degenerate."
        },
        "getInterpolation": {
          "!type": "fn(point: +THREE.Vector3, p1: +THREE.Vector3, p2: +THREE.Vector3, p3: +THREE.Vector3, v1: +THREE.Vector3, v2: +THREE.Vector3, v3: +THREE.Vector3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Computes the value barycentrically interpolated for the given point on the triangle. Returns null if the triangle is degenerate."
        },
        "getMidpoint": {
          "!type": "fn(target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Computes the midpoint of the triangle."
        },
        "getNormal": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Computes the normal vector of a triangle."
        },
        "getPlane": {
          "!type": "fn(target: +THREE.Plane) -> +THREE.Plane",
          "!doc": "Computes a plane the triangle lies within."
        },
        "intersectsBox": {
          "!type": "fn(box: +THREE.Box3) -> bool",
          "!doc": "Returns true if this triangle intersects with the given box."
        },
        "isFrontFacing": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3, direction: +THREE.Vector3) -> bool",
          "!doc": "Returns true if the triangle is oriented towards the given direction."
        },
        "set": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3) -> +THREE.Triangle",
          "!doc": "Sets the triangle's vertices by copying the given values."
        },
        "setFromAttributeAndIndices": {
          "!type": "fn(attribute: +THREE.BufferAttribute, i0: number, i1: number, i2: number) -> +THREE.Triangle",
          "!doc": "Sets the triangle's vertices by copying the given attribute values."
        },
        "setFromPointsAndIndices": {
          "!type": "fn(points, i0: number, i1: number, i2: number) -> +THREE.Triangle",
          "!doc": "Sets the triangle's vertices by copying the given array values."
        },
        "getInterpolatedAttribute": {
          "!type": "fn(attr: +THREE.BufferAttribute, i1: number, i2: number, i3: number, barycoord: +THREE.Vector3, target: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Computes the value barycentrically interpolated for the given attribute and indices."
        }
      },
      "!doc": "Constructs a new triangle.",
      "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3, c: +THREE.Vector3)"
    },
    "TubeGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/TubeGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "fromJSON": {
          "!type": "fn(data: object) -> +THREE.TubeGeometry",
          "!doc": "Factory method for creating an instance of this class from the given JSON object."
        }
      },
      "!doc": "Constructs a new tube geometry.",
      "!type": "fn(path: +THREE.Curve, tubularSegments: number, radius: number, radialSegments: number, closed: bool)"
    },
    "Uint16BufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/Uint16BufferAttribute",
      "prototype": {
        "!proto": "THREE.BufferAttribute.prototype",
        "array": {
          "!type": "+TypedArray",
          "!doc": "The array holding the attribute data. It should have itemSize * numVertices elements, where numVertices is the number of vertices in the associated geometry."
        },
        "count": {
          "!type": "number",
          "!doc": "Represents the number of items this buffer attribute stores. It is internally computed by dividing the array length by the itemSize."
        },
        "gpuType": {
          "!type": "+THREE.FloatType",
          "!doc": "Configures the bound GPU type for use in shaders. Note: this only has an effect for integer arrays and is not configurable for float arrays. For lower precision float types, use Float16BufferAttribute."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the buffer attribute."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The number of values of the array that should be associated with a particular vertex. For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then the value should be 3."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "bool",
          "!doc": "Applies to integer data only. Indicates how the underlying data in the buffer maps to the values in the GLSL code. For instance, if array is an instance of UInt16Array, and normalized is true, the values 0 - +65535 in the array data will be mapped to 0.0f - +1.0f in the GLSL attribute. If normalized is false, the values will be converted to floats unmodified, i.e. 65535 becomes 65535.0f."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 matrix to the given attribute. Works with item size 2 and 3."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 normal matrix to the given attribute. Only works with item size 3."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns a new buffer attribute with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferAttribute) -> +THREE.BufferAttribute",
          "!doc": "Copies the values of the given buffer attribute to this instance."
        },
        "copyArray": {
          "!type": "fn(array: +TypedArray) -> +THREE.BufferAttribute",
          "!doc": "Copies the given array data into this buffer attribute."
        },
        "copyAt": {
          "!type": "fn(index1: number, attribute: +THREE.BufferAttribute, index2: number) -> +THREE.BufferAttribute",
          "!doc": "Copies a vector from the given buffer attribute to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "getComponent": {
          "!type": "fn(index: number, component: number) -> number",
          "!doc": "Returns the given component of the vector at the given index."
        },
        "getW": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the w component of the vector at the given index."
        },
        "getX": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the x component of the vector at the given index."
        },
        "getY": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the y component of the vector at the given index."
        },
        "getZ": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the z component of the vector at the given index."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.BufferAttribute",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the attribute array data to the GPU. Can be used to perform clean-up operations after the upload when attribute data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given array data in the buffer attribute."
        },
        "setComponent": {
          "!type": "fn(index: number, component: number, value: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given value to the given component of the vector at the given index."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.BufferAttribute",
          "!doc": "Sets the usage of this buffer attribute."
        },
        "setW": {
          "!type": "fn(index: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the w component of the vector at the given index."
        },
        "setX": {
          "!type": "fn(index: number, x: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x component of the vector at the given index."
        },
        "setXY": {
          "!type": "fn(index: number, x: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x and y component of the vector at the given index."
        },
        "setXYZ": {
          "!type": "fn(index: number, x: number, y: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y and z component of the vector at the given index."
        },
        "setXYZW": {
          "!type": "fn(index: number, x: number, y: number, z: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y, z and w component of the vector at the given index."
        },
        "setY": {
          "!type": "fn(index: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the y component of the vector at the given index."
        },
        "setZ": {
          "!type": "fn(index: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the z component of the vector at the given index."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the buffer attribute into JSON."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3 and with direction vectors."
        }
      },
      "!doc": "Constructs a new buffer attribute.",
      "!type": "fn(array, itemSize: number, normalized: bool)"
    },
    "Uint32BufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/Uint32BufferAttribute",
      "prototype": {
        "!proto": "THREE.BufferAttribute.prototype",
        "array": {
          "!type": "+TypedArray",
          "!doc": "The array holding the attribute data. It should have itemSize * numVertices elements, where numVertices is the number of vertices in the associated geometry."
        },
        "count": {
          "!type": "number",
          "!doc": "Represents the number of items this buffer attribute stores. It is internally computed by dividing the array length by the itemSize."
        },
        "gpuType": {
          "!type": "+THREE.FloatType",
          "!doc": "Configures the bound GPU type for use in shaders. Note: this only has an effect for integer arrays and is not configurable for float arrays. For lower precision float types, use Float16BufferAttribute."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the buffer attribute."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The number of values of the array that should be associated with a particular vertex. For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then the value should be 3."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "bool",
          "!doc": "Applies to integer data only. Indicates how the underlying data in the buffer maps to the values in the GLSL code. For instance, if array is an instance of UInt16Array, and normalized is true, the values 0 - +65535 in the array data will be mapped to 0.0f - +1.0f in the GLSL attribute. If normalized is false, the values will be converted to floats unmodified, i.e. 65535 becomes 65535.0f."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 matrix to the given attribute. Works with item size 2 and 3."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 normal matrix to the given attribute. Only works with item size 3."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns a new buffer attribute with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferAttribute) -> +THREE.BufferAttribute",
          "!doc": "Copies the values of the given buffer attribute to this instance."
        },
        "copyArray": {
          "!type": "fn(array: +TypedArray) -> +THREE.BufferAttribute",
          "!doc": "Copies the given array data into this buffer attribute."
        },
        "copyAt": {
          "!type": "fn(index1: number, attribute: +THREE.BufferAttribute, index2: number) -> +THREE.BufferAttribute",
          "!doc": "Copies a vector from the given buffer attribute to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "getComponent": {
          "!type": "fn(index: number, component: number) -> number",
          "!doc": "Returns the given component of the vector at the given index."
        },
        "getW": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the w component of the vector at the given index."
        },
        "getX": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the x component of the vector at the given index."
        },
        "getY": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the y component of the vector at the given index."
        },
        "getZ": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the z component of the vector at the given index."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.BufferAttribute",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the attribute array data to the GPU. Can be used to perform clean-up operations after the upload when attribute data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given array data in the buffer attribute."
        },
        "setComponent": {
          "!type": "fn(index: number, component: number, value: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given value to the given component of the vector at the given index."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.BufferAttribute",
          "!doc": "Sets the usage of this buffer attribute."
        },
        "setW": {
          "!type": "fn(index: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the w component of the vector at the given index."
        },
        "setX": {
          "!type": "fn(index: number, x: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x component of the vector at the given index."
        },
        "setXY": {
          "!type": "fn(index: number, x: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x and y component of the vector at the given index."
        },
        "setXYZ": {
          "!type": "fn(index: number, x: number, y: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y and z component of the vector at the given index."
        },
        "setXYZW": {
          "!type": "fn(index: number, x: number, y: number, z: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y, z and w component of the vector at the given index."
        },
        "setY": {
          "!type": "fn(index: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the y component of the vector at the given index."
        },
        "setZ": {
          "!type": "fn(index: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the z component of the vector at the given index."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the buffer attribute into JSON."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3 and with direction vectors."
        }
      },
      "!doc": "Constructs a new buffer attribute.",
      "!type": "fn(array, itemSize: number, normalized: bool)"
    },
    "Uint8BufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/Uint8BufferAttribute",
      "prototype": {
        "!proto": "THREE.BufferAttribute.prototype",
        "array": {
          "!type": "+TypedArray",
          "!doc": "The array holding the attribute data. It should have itemSize * numVertices elements, where numVertices is the number of vertices in the associated geometry."
        },
        "count": {
          "!type": "number",
          "!doc": "Represents the number of items this buffer attribute stores. It is internally computed by dividing the array length by the itemSize."
        },
        "gpuType": {
          "!type": "+THREE.FloatType",
          "!doc": "Configures the bound GPU type for use in shaders. Note: this only has an effect for integer arrays and is not configurable for float arrays. For lower precision float types, use Float16BufferAttribute."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the buffer attribute."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The number of values of the array that should be associated with a particular vertex. For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then the value should be 3."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "bool",
          "!doc": "Applies to integer data only. Indicates how the underlying data in the buffer maps to the values in the GLSL code. For instance, if array is an instance of UInt16Array, and normalized is true, the values 0 - +65535 in the array data will be mapped to 0.0f - +1.0f in the GLSL attribute. If normalized is false, the values will be converted to floats unmodified, i.e. 65535 becomes 65535.0f."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 matrix to the given attribute. Works with item size 2 and 3."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 normal matrix to the given attribute. Only works with item size 3."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns a new buffer attribute with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferAttribute) -> +THREE.BufferAttribute",
          "!doc": "Copies the values of the given buffer attribute to this instance."
        },
        "copyArray": {
          "!type": "fn(array: +TypedArray) -> +THREE.BufferAttribute",
          "!doc": "Copies the given array data into this buffer attribute."
        },
        "copyAt": {
          "!type": "fn(index1: number, attribute: +THREE.BufferAttribute, index2: number) -> +THREE.BufferAttribute",
          "!doc": "Copies a vector from the given buffer attribute to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "getComponent": {
          "!type": "fn(index: number, component: number) -> number",
          "!doc": "Returns the given component of the vector at the given index."
        },
        "getW": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the w component of the vector at the given index."
        },
        "getX": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the x component of the vector at the given index."
        },
        "getY": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the y component of the vector at the given index."
        },
        "getZ": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the z component of the vector at the given index."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.BufferAttribute",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the attribute array data to the GPU. Can be used to perform clean-up operations after the upload when attribute data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given array data in the buffer attribute."
        },
        "setComponent": {
          "!type": "fn(index: number, component: number, value: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given value to the given component of the vector at the given index."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.BufferAttribute",
          "!doc": "Sets the usage of this buffer attribute."
        },
        "setW": {
          "!type": "fn(index: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the w component of the vector at the given index."
        },
        "setX": {
          "!type": "fn(index: number, x: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x component of the vector at the given index."
        },
        "setXY": {
          "!type": "fn(index: number, x: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x and y component of the vector at the given index."
        },
        "setXYZ": {
          "!type": "fn(index: number, x: number, y: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y and z component of the vector at the given index."
        },
        "setXYZW": {
          "!type": "fn(index: number, x: number, y: number, z: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y, z and w component of the vector at the given index."
        },
        "setY": {
          "!type": "fn(index: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the y component of the vector at the given index."
        },
        "setZ": {
          "!type": "fn(index: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the z component of the vector at the given index."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the buffer attribute into JSON."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3 and with direction vectors."
        }
      },
      "!doc": "Constructs a new buffer attribute.",
      "!type": "fn(array, itemSize: number, normalized: bool)"
    },
    "Uint8ClampedBufferAttribute": {
      "!url": "https://threejs.org/docs/#api/en/core/Uint8ClampedBufferAttribute",
      "prototype": {
        "!proto": "THREE.BufferAttribute.prototype",
        "array": {
          "!type": "+TypedArray",
          "!doc": "The array holding the attribute data. It should have itemSize * numVertices elements, where numVertices is the number of vertices in the associated geometry."
        },
        "count": {
          "!type": "number",
          "!doc": "Represents the number of items this buffer attribute stores. It is internally computed by dividing the array length by the itemSize."
        },
        "gpuType": {
          "!type": "+THREE.FloatType",
          "!doc": "Configures the bound GPU type for use in shaders. Note: this only has an effect for integer arrays and is not configurable for float arrays. For lower precision float types, use Float16BufferAttribute."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the buffer attribute."
        },
        "itemSize": {
          "!type": "number",
          "!doc": "The number of values of the array that should be associated with a particular vertex. For instance, if this attribute is storing a 3-component vector (such as a position, normal, or color), then the value should be 3."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the buffer attribute."
        },
        "needsUpdate": {
          "!type": "number",
          "!doc": "Flag to indicate that this attribute has changed and should be re-sent to the GPU. Set this to true when you modify the value of the array."
        },
        "normalized": {
          "!type": "bool",
          "!doc": "Applies to integer data only. Indicates how the underlying data in the buffer maps to the values in the GLSL code. For instance, if array is an instance of UInt16Array, and normalized is true, the values 0 - +65535 in the array data will be mapped to 0.0f - +1.0f in the GLSL attribute. If normalized is false, the values will be converted to floats unmodified, i.e. 65535 becomes 65535.0f."
        },
        "updateRanges": {
          "!doc": "This can be used to only update some components of stored vectors (for example, just the component related to color). Use the addUpdateRange() function to add ranges to this array."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "Defines the intended usage pattern of the data store for optimization purposes. Note: After the initial use of a buffer, its usage cannot be changed. Instead, instantiate a new one and set the desired usage before the next render."
        },
        "version": {
          "!type": "number",
          "!doc": "A version number, incremented every time the needsUpdate is set to true."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data array to be updated on the GPU."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 matrix to the given attribute. Works with item size 2 and 3."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 3x3 normal matrix to the given attribute. Only works with item size 3."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns a new buffer attribute with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferAttribute) -> +THREE.BufferAttribute",
          "!doc": "Copies the values of the given buffer attribute to this instance."
        },
        "copyArray": {
          "!type": "fn(array: +TypedArray) -> +THREE.BufferAttribute",
          "!doc": "Copies the given array data into this buffer attribute."
        },
        "copyAt": {
          "!type": "fn(index1: number, attribute: +THREE.BufferAttribute, index2: number) -> +THREE.BufferAttribute",
          "!doc": "Copies a vector from the given buffer attribute to this one. The start and destination position in the attribute buffers are represented by the given indices."
        },
        "getComponent": {
          "!type": "fn(index: number, component: number) -> number",
          "!doc": "Returns the given component of the vector at the given index."
        },
        "getW": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the w component of the vector at the given index."
        },
        "getX": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the x component of the vector at the given index."
        },
        "getY": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the y component of the vector at the given index."
        },
        "getZ": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the z component of the vector at the given index."
        },
        "onUpload": {
          "!type": "fn(callback: fn()) -> +THREE.BufferAttribute",
          "!doc": "Sets the given callback function that is executed after the Renderer has transferred the attribute array data to the GPU. Can be used to perform clean-up operations after the upload when attribute data are not needed anymore on the CPU side."
        },
        "onUploadCallback": {
          "!type": "fn()",
          "!doc": "A callback function that is executed after the renderer has transferred the attribute array data to the GPU."
        },
        "set": {
          "!type": "fn(value: +TypedArray, offset: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given array data in the buffer attribute."
        },
        "setComponent": {
          "!type": "fn(index: number, component: number, value: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the given value to the given component of the vector at the given index."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.BufferAttribute",
          "!doc": "Sets the usage of this buffer attribute."
        },
        "setW": {
          "!type": "fn(index: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the w component of the vector at the given index."
        },
        "setX": {
          "!type": "fn(index: number, x: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x component of the vector at the given index."
        },
        "setXY": {
          "!type": "fn(index: number, x: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x and y component of the vector at the given index."
        },
        "setXYZ": {
          "!type": "fn(index: number, x: number, y: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y and z component of the vector at the given index."
        },
        "setXYZW": {
          "!type": "fn(index: number, x: number, y: number, z: number, w: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the x, y, z and w component of the vector at the given index."
        },
        "setY": {
          "!type": "fn(index: number, y: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the y component of the vector at the given index."
        },
        "setZ": {
          "!type": "fn(index: number, z: number) -> +THREE.BufferAttribute",
          "!doc": "Sets the z component of the vector at the given index."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the buffer attribute into JSON."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.BufferAttribute",
          "!doc": "Applies the given 4x4 matrix to the given attribute. Only works with item size 3 and with direction vectors."
        }
      },
      "!doc": "Constructs a new buffer attribute.",
      "!type": "fn(array, itemSize: number, normalized: bool)"
    },
    "Uniform": {
      "!url": "https://threejs.org/docs/#api/en/core/Uniform",
      "prototype": {
        "value": {
          "!type": "?",
          "!doc": "The uniform value."
        },
        "clone": {
          "!type": "fn() -> +THREE.Uniform",
          "!doc": "Returns a new uniform with copied values from this instance. If the value has a clone() method, the value is cloned as well."
        }
      },
      "!doc": "Constructs a new uniform.",
      "!type": "fn(value: ?)"
    },
    "UniformsGroup": {
      "!url": "https://threejs.org/docs/#api/en/core/UniformsGroup",
      "prototype": {
        "!proto": "THREE.EventDispatcher.prototype",
        "id": {
          "!type": "number",
          "!doc": "The ID of the 3D object."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the uniforms group."
        },
        "uniforms": {
          "!doc": "An array holding the uniforms."
        },
        "usage": {
          "!type": "+THREE.StaticDrawUsage",
          "!doc": "The buffer usage."
        },
        "add": {
          "!type": "fn(uniform: +THREE.Uniform) -> +THREE.UniformsGroup",
          "!doc": "Adds the given uniform to this uniforms group."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "clone": {
          "!type": "fn() -> +THREE.UniformsGroup",
          "!doc": "Returns a new uniforms group with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.UniformsGroup) -> +THREE.UniformsGroup",
          "!doc": "Copies the values of the given uniforms group to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "remove": {
          "!type": "fn(uniform: +THREE.Uniform) -> +THREE.UniformsGroup",
          "!doc": "Removes the given uniform from this uniforms group."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setName": {
          "!type": "fn(name: string) -> +THREE.UniformsGroup",
          "!doc": "Sets the name of this uniforms group."
        },
        "setUsage": {
          "!type": "fn(value: +THREE.StaticDrawUsage) -> +THREE.UniformsGroup",
          "!doc": "Sets the usage of this uniforms group."
        }
      },
      "!doc": "Constructs a new uniforms group.",
      "!type": "fn()"
    },
    "Vector2": {
      "!url": "https://threejs.org/docs/#api/en/math/Vector2",
      "prototype": {
        "height": {
          "!type": "number",
          "!doc": "Alias for Vector2."
        },
        "width": {
          "!type": "number",
          "!doc": "Alias for Vector2."
        },
        "x": {
          "!type": "number",
          "!doc": "The x value of this vector."
        },
        "y": {
          "!type": "number",
          "!doc": "The y value of this vector."
        },
        "add": {
          "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Adds the given vector to this instance."
        },
        "addScalar": {
          "!type": "fn(s: number) -> +THREE.Vector2",
          "!doc": "Adds the given scalar value to all components of this instance."
        },
        "addScaledVector": {
          "!type": "fn(v: +THREE.Vector2, s: number) -> +THREE.Vector2",
          "!doc": "Adds the given vector scaled by the given factor to this instance."
        },
        "addVectors": {
          "!type": "fn(a: +THREE.Vector2, b: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Adds the given vectors and stores the result in this instance."
        },
        "angle": {
          "!type": "fn() -> number",
          "!doc": "Computes the angle in radians of this vector with respect to the positive x-axis."
        },
        "angleTo": {
          "!type": "fn(v: +THREE.Vector2) -> number",
          "!doc": "Returns the angle between the given vector and this instance in radians."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.Vector2",
          "!doc": "Multiplies this vector (with an implicit 1 as the 3rd component) by the given 3x3 matrix."
        },
        "ceil": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "The components of this vector are rounded up to the nearest integer value."
        },
        "clamp": {
          "!type": "fn(min: +THREE.Vector2, max: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "If this vector's x or y value is greater than the max vector's x or y value, it is replaced by the corresponding value. If this vector's x or y value is less than the min vector's x or y value, it is replaced by the corresponding value."
        },
        "clampLength": {
          "!type": "fn(min: number, max: number) -> +THREE.Vector2",
          "!doc": "If this vector's length is greater than the max value, it is replaced by the max value. If this vector's length is less than the min value, it is replaced by the min value."
        },
        "clampScalar": {
          "!type": "fn(minVal: number, maxVal: number) -> +THREE.Vector2",
          "!doc": "If this vector's x or y values are greater than the max value, they are replaced by the max value. If this vector's x or y values are less than the min value, they are replaced by the min value."
        },
        "clone": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "Returns a new vector with copied values from this instance."
        },
        "copy": {
          "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Copies the values of the given vector to this instance."
        },
        "cross": {
          "!type": "fn(v: +THREE.Vector2) -> number",
          "!doc": "Calculates the cross product of the given vector with this instance."
        },
        "distanceTo": {
          "!type": "fn(v: +THREE.Vector2) -> number",
          "!doc": "Computes the distance from the given vector to this instance."
        },
        "distanceToSquared": {
          "!type": "fn(v: +THREE.Vector2) -> number",
          "!doc": "Computes the squared distance from the given vector to this instance. If you are just comparing the distance with another distance, you should compare the distance squared instead as it is slightly more efficient to calculate."
        },
        "divide": {
          "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Divides this instance by the given vector."
        },
        "divideScalar": {
          "!type": "fn(scalar: number) -> +THREE.Vector2",
          "!doc": "Divides this vector by the given scalar."
        },
        "dot": {
          "!type": "fn(v: +THREE.Vector2) -> number",
          "!doc": "Calculates the dot product of the given vector with this instance."
        },
        "equals": {
          "!type": "fn(v: +THREE.Vector2) -> bool",
          "!doc": "Returns true if this vector is equal with the given one."
        },
        "floor": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "The components of this vector are rounded down to the nearest integer value."
        },
        "fromArray": {
          "!type": "fn(array, offset: number) -> +THREE.Vector2",
          "!doc": "Sets this vector's x value to be array[ offset ] and y value to be array[ offset + 1 ]."
        },
        "fromBufferAttribute": {
          "!type": "fn(attribute: +THREE.BufferAttribute, index: number) -> +THREE.Vector2",
          "!doc": "Sets the components of this vector from the given buffer attribute."
        },
        "getComponent": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the value of the vector component which matches the given index."
        },
        "length": {
          "!type": "fn() -> number",
          "!doc": "Computes the Euclidean length (straight-line length) from (0, 0) to (x, y)."
        },
        "lengthSq": {
          "!type": "fn() -> number",
          "!doc": "Computes the square of the Euclidean length (straight-line length) from (0, 0) to (x, y). If you are comparing the lengths of vectors, you should compare the length squared instead as it is slightly more efficient to calculate."
        },
        "lerp": {
          "!type": "fn(v: +THREE.Vector2, alpha: number) -> +THREE.Vector2",
          "!doc": "Linearly interpolates between the given vector and this instance, where alpha is the percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be the given one."
        },
        "lerpVectors": {
          "!type": "fn(v1: +THREE.Vector2, v2: +THREE.Vector2, alpha: number) -> +THREE.Vector2",
          "!doc": "Linearly interpolates between the given vectors, where alpha is the percent distance along the line - alpha = 0 will be first vector, and alpha = 1 will be the second one. The result is stored in this instance."
        },
        "manhattanDistanceTo": {
          "!type": "fn(v: +THREE.Vector2) -> number",
          "!doc": "Computes the Manhattan distance from the given vector to this instance."
        },
        "manhattanLength": {
          "!type": "fn() -> number",
          "!doc": "Computes the Manhattan length of this vector."
        },
        "max": {
          "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "If this vector's x or y value is less than the given vector's x or y value, replace that value with the corresponding max value."
        },
        "min": {
          "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "If this vector's x or y value is greater than the given vector's x or y value, replace that value with the corresponding min value."
        },
        "multiply": {
          "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Multiplies the given vector with this instance."
        },
        "multiplyScalar": {
          "!type": "fn(scalar: number) -> +THREE.Vector2",
          "!doc": "Multiplies the given scalar value with all components of this instance."
        },
        "negate": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "Inverts this vector - i.e. sets x = -x and y = -y."
        },
        "normalize": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "Converts this vector to a unit vector - that is, sets it equal to a vector with the same direction as this one, but with a vector length of 1."
        },
        "random": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "Sets each component of this vector to a pseudo-random value between 0 and 1, excluding 1."
        },
        "rotateAround": {
          "!type": "fn(center: +THREE.Vector2, angle: number) -> +THREE.Vector2",
          "!doc": "Rotates this vector around the given center by the given angle."
        },
        "round": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "The components of this vector are rounded to the nearest integer value"
        },
        "roundToZero": {
          "!type": "fn() -> +THREE.Vector2",
          "!doc": "The components of this vector are rounded towards zero (up if negative, down if positive) to an integer value."
        },
        "set": {
          "!type": "fn(x: number, y: number) -> +THREE.Vector2",
          "!doc": "Sets the vector components."
        },
        "setComponent": {
          "!type": "fn(index: number, value: number) -> +THREE.Vector2",
          "!doc": "Allows to set a vector component with an index."
        },
        "setLength": {
          "!type": "fn(length: number) -> +THREE.Vector2",
          "!doc": "Sets this vector to a vector with the same direction as this one, but with the specified length."
        },
        "setScalar": {
          "!type": "fn(scalar: number) -> +THREE.Vector2",
          "!doc": "Sets the vector components to the same value."
        },
        "setX": {
          "!type": "fn(x: number) -> +THREE.Vector2",
          "!doc": "Sets the vector's x component to the given value"
        },
        "setY": {
          "!type": "fn(y: number) -> +THREE.Vector2",
          "!doc": "Sets the vector's y component to the given value"
        },
        "sub": {
          "!type": "fn(v: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Subtracts the given vector from this instance."
        },
        "subScalar": {
          "!type": "fn(s: number) -> +THREE.Vector2",
          "!doc": "Subtracts the given scalar value from all components of this instance."
        },
        "subVectors": {
          "!type": "fn(a: +THREE.Vector2, b: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Subtracts the given vectors and stores the result in this instance."
        },
        "toArray": {
          "!type": "fn(array, offset: number)",
          "!doc": "Writes the components of this vector to the given array. If no array is provided, the method returns a new instance."
        }
      },
      "!doc": "Constructs a new 2D vector.",
      "!type": "fn(x: number, y: number)"
    },
    "Vector3": {
      "!url": "https://threejs.org/docs/#api/en/math/Vector3",
      "prototype": {
        "x": {
          "!type": "number",
          "!doc": "The x value of this vector."
        },
        "y": {
          "!type": "number",
          "!doc": "The y value of this vector."
        },
        "z": {
          "!type": "number",
          "!doc": "The z value of this vector."
        },
        "add": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Adds the given vector to this instance."
        },
        "addScalar": {
          "!type": "fn(s: number) -> +THREE.Vector3",
          "!doc": "Adds the given scalar value to all components of this instance."
        },
        "addScaledVector": {
          "!type": "fn(v: +THREE.Vector3, s: number) -> +THREE.Vector3",
          "!doc": "Adds the given vector scaled by the given factor to this instance."
        },
        "addVectors": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Adds the given vectors and stores the result in this instance."
        },
        "angleTo": {
          "!type": "fn(v: +THREE.Vector3) -> number",
          "!doc": "Returns the angle between the given vector and this instance in radians."
        },
        "applyAxisAngle": {
          "!type": "fn(axis: +THREE.Vector3, angle: number) -> +THREE.Vector3",
          "!doc": "Applies a rotation specified by an axis and an angle to this vector."
        },
        "applyEuler": {
          "!type": "fn(euler: +THREE.Euler) -> +THREE.Vector3",
          "!doc": "Applies the given Euler rotation to this vector."
        },
        "applyMatrix3": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.Vector3",
          "!doc": "Multiplies this vector with the given 3x3 matrix."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector3",
          "!doc": "Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and divides by perspective."
        },
        "applyNormalMatrix": {
          "!type": "fn(m: +THREE.Matrix3) -> +THREE.Vector3",
          "!doc": "Multiplies this vector by the given normal matrix and normalizes the result."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Vector3",
          "!doc": "Applies the given Quaternion to this vector."
        },
        "ceil": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "The components of this vector are rounded up to the nearest integer value."
        },
        "clamp": {
          "!type": "fn(min: +THREE.Vector3, max: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "If this vector's x, y or z value is greater than the max vector's x, y or z value, it is replaced by the corresponding value. If this vector's x, y or z value is less than the min vector's x, y or z value, it is replaced by the corresponding value."
        },
        "clampLength": {
          "!type": "fn(min: number, max: number) -> +THREE.Vector3",
          "!doc": "If this vector's length is greater than the max value, it is replaced by the max value. If this vector's length is less than the min value, it is replaced by the min value."
        },
        "clampScalar": {
          "!type": "fn(minVal: number, maxVal: number) -> +THREE.Vector3",
          "!doc": "If this vector's x, y or z values are greater than the max value, they are replaced by the max value. If this vector's x, y or z values are less than the min value, they are replaced by the min value."
        },
        "clone": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "Returns a new vector with copied values from this instance."
        },
        "copy": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Copies the values of the given vector to this instance."
        },
        "cross": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Calculates the cross product of the given vector with this instance."
        },
        "crossVectors": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Calculates the cross product of the given vectors and stores the result in this instance."
        },
        "distanceTo": {
          "!type": "fn(v: +THREE.Vector3) -> number",
          "!doc": "Computes the distance from the given vector to this instance."
        },
        "distanceToSquared": {
          "!type": "fn(v: +THREE.Vector3) -> number",
          "!doc": "Computes the squared distance from the given vector to this instance. If you are just comparing the distance with another distance, you should compare the distance squared instead as it is slightly more efficient to calculate."
        },
        "divide": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Divides this instance by the given vector."
        },
        "divideScalar": {
          "!type": "fn(scalar: number) -> +THREE.Vector3",
          "!doc": "Divides this vector by the given scalar."
        },
        "dot": {
          "!type": "fn(v: +THREE.Vector3) -> number",
          "!doc": "Calculates the dot product of the given vector with this instance."
        },
        "equals": {
          "!type": "fn(v: +THREE.Vector3) -> bool",
          "!doc": "Returns true if this vector is equal with the given one."
        },
        "floor": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "The components of this vector are rounded down to the nearest integer value."
        },
        "fromArray": {
          "!type": "fn(array, offset: number) -> +THREE.Vector3",
          "!doc": "Sets this vector's x value to be array[ offset ], y value to be array[ offset + 1 ] and z value to be array[ offset + 2 ]."
        },
        "fromBufferAttribute": {
          "!type": "fn(attribute: +THREE.BufferAttribute, index: number) -> +THREE.Vector3",
          "!doc": "Sets the components of this vector from the given buffer attribute."
        },
        "getComponent": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the value of the vector component which matches the given index."
        },
        "length": {
          "!type": "fn() -> number",
          "!doc": "Computes the Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z)."
        },
        "lengthSq": {
          "!type": "fn() -> number",
          "!doc": "Computes the square of the Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should compare the length squared instead as it is slightly more efficient to calculate."
        },
        "lerp": {
          "!type": "fn(v: +THREE.Vector3, alpha: number) -> +THREE.Vector3",
          "!doc": "Linearly interpolates between the given vector and this instance, where alpha is the percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be the given one."
        },
        "lerpVectors": {
          "!type": "fn(v1: +THREE.Vector3, v2: +THREE.Vector3, alpha: number) -> +THREE.Vector3",
          "!doc": "Linearly interpolates between the given vectors, where alpha is the percent distance along the line - alpha = 0 will be first vector, and alpha = 1 will be the second one. The result is stored in this instance."
        },
        "manhattanDistanceTo": {
          "!type": "fn(v: +THREE.Vector3) -> number",
          "!doc": "Computes the Manhattan distance from the given vector to this instance."
        },
        "manhattanLength": {
          "!type": "fn() -> number",
          "!doc": "Computes the Manhattan length of this vector."
        },
        "max": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "If this vector's x, y or z value is less than the given vector's x, y or z value, replace that value with the corresponding max value."
        },
        "min": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "If this vector's x, y or z value is greater than the given vector's x, y or z value, replace that value with the corresponding min value."
        },
        "multiply": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Multiplies the given vector with this instance."
        },
        "multiplyScalar": {
          "!type": "fn(scalar: number) -> +THREE.Vector3",
          "!doc": "Multiplies the given scalar value with all components of this instance."
        },
        "multiplyVectors": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Multiplies the given vectors and stores the result in this instance."
        },
        "negate": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "Inverts this vector - i.e. sets x = -x, y = -y and z = -z."
        },
        "normalize": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "Converts this vector to a unit vector - that is, sets it equal to a vector with the same direction as this one, but with a vector length of 1."
        },
        "project": {
          "!type": "fn(camera: +THREE.Camera) -> +THREE.Vector3",
          "!doc": "Projects this vector from world space into the camera's normalized device coordinate (NDC) space."
        },
        "projectOnPlane": {
          "!type": "fn(planeNormal: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Projects this vector onto a plane by subtracting this vector projected onto the plane's normal from this vector."
        },
        "projectOnVector": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Projects this vector onto the given one."
        },
        "random": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "Sets each component of this vector to a pseudo-random value between 0 and 1, excluding 1."
        },
        "randomDirection": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "Sets this vector to a uniformly random point on a unit sphere."
        },
        "reflect": {
          "!type": "fn(normal: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Reflects this vector off a plane orthogonal to the given normal vector."
        },
        "round": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "The components of this vector are rounded to the nearest integer value"
        },
        "roundToZero": {
          "!type": "fn() -> +THREE.Vector3",
          "!doc": "The components of this vector are rounded towards zero (up if negative, down if positive) to an integer value."
        },
        "set": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.Vector3",
          "!doc": "Sets the vector components."
        },
        "setComponent": {
          "!type": "fn(index: number, value: number) -> +THREE.Vector3",
          "!doc": "Allows to set a vector component with an index."
        },
        "setFromColor": {
          "!type": "fn(c: +THREE.Color) -> +THREE.Vector3",
          "!doc": "Sets the vector components from the RGB components of the given color."
        },
        "setFromCylindrical": {
          "!type": "fn(c: +THREE.Cylindrical) -> +THREE.Vector3",
          "!doc": "Sets the vector components from the given cylindrical coordinates."
        },
        "setFromCylindricalCoords": {
          "!type": "fn(radius: number, theta: number, y: number) -> +THREE.Vector3",
          "!doc": "Sets the vector components from the given cylindrical coordinates."
        },
        "setFromEuler": {
          "!type": "fn(e: +THREE.Euler) -> +THREE.Vector3",
          "!doc": "Sets the vector components from the given Euler angles."
        },
        "setFromMatrix3Column": {
          "!type": "fn(m: +THREE.Matrix3, index: number) -> +THREE.Vector3",
          "!doc": "Sets the vector components from the specified matrix column."
        },
        "setFromMatrixColumn": {
          "!type": "fn(m: +THREE.Matrix4, index: number) -> +THREE.Vector3",
          "!doc": "Sets the vector components from the specified matrix column."
        },
        "setFromMatrixPosition": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector3",
          "!doc": "Sets the vector components to the position elements of the given transformation matrix."
        },
        "setFromMatrixScale": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector3",
          "!doc": "Sets the vector components to the scale elements of the given transformation matrix."
        },
        "setFromSpherical": {
          "!type": "fn(s: +THREE.Spherical) -> +THREE.Vector3",
          "!doc": "Sets the vector components from the given spherical coordinates."
        },
        "setFromSphericalCoords": {
          "!type": "fn(radius: number, phi: number, theta: number) -> +THREE.Vector3",
          "!doc": "Sets the vector components from the given spherical coordinates."
        },
        "setLength": {
          "!type": "fn(length: number) -> +THREE.Vector3",
          "!doc": "Sets this vector to a vector with the same direction as this one, but with the specified length."
        },
        "setScalar": {
          "!type": "fn(scalar: number) -> +THREE.Vector3",
          "!doc": "Sets the vector components to the same value."
        },
        "setX": {
          "!type": "fn(x: number) -> +THREE.Vector3",
          "!doc": "Sets the vector's x component to the given value."
        },
        "setY": {
          "!type": "fn(y: number) -> +THREE.Vector3",
          "!doc": "Sets the vector's y component to the given value."
        },
        "setZ": {
          "!type": "fn(z: number) -> +THREE.Vector3",
          "!doc": "Sets the vector's z component to the given value."
        },
        "sub": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Subtracts the given vector from this instance."
        },
        "subScalar": {
          "!type": "fn(s: number) -> +THREE.Vector3",
          "!doc": "Subtracts the given scalar value from all components of this instance."
        },
        "subVectors": {
          "!type": "fn(a: +THREE.Vector3, b: +THREE.Vector3) -> +THREE.Vector3",
          "!doc": "Subtracts the given vectors and stores the result in this instance."
        },
        "toArray": {
          "!type": "fn(array, offset: number)",
          "!doc": "Writes the components of this vector to the given array. If no array is provided, the method returns a new instance."
        },
        "transformDirection": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector3",
          "!doc": "Transforms the direction of this vector by a matrix (the upper left 3 x 3 subset of the given 4x4 matrix and then normalizes the result."
        },
        "unproject": {
          "!type": "fn(camera: +THREE.Camera) -> +THREE.Vector3",
          "!doc": "Unprojects this vector from the camera's normalized device coordinate (NDC) space into world space."
        }
      },
      "!doc": "Constructs a new 3D vector.",
      "!type": "fn(x: number, y: number, z: number)"
    },
    "Vector4": {
      "!url": "https://threejs.org/docs/#api/en/math/Vector4",
      "prototype": {
        "height": {
          "!type": "number",
          "!doc": "Alias for Vector4."
        },
        "w": {
          "!type": "number",
          "!doc": "The w value of this vector."
        },
        "width": {
          "!type": "number",
          "!doc": "Alias for Vector4."
        },
        "x": {
          "!type": "number",
          "!doc": "The x value of this vector."
        },
        "y": {
          "!type": "number",
          "!doc": "The y value of this vector."
        },
        "z": {
          "!type": "number",
          "!doc": "The z value of this vector."
        },
        "add": {
          "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "Adds the given vector to this instance."
        },
        "addScalar": {
          "!type": "fn(s: number) -> +THREE.Vector4",
          "!doc": "Adds the given scalar value to all components of this instance."
        },
        "addScaledVector": {
          "!type": "fn(v: +THREE.Vector4, s: number) -> +THREE.Vector4",
          "!doc": "Adds the given vector scaled by the given factor to this instance."
        },
        "addVectors": {
          "!type": "fn(a: +THREE.Vector4, b: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "Adds the given vectors and stores the result in this instance."
        },
        "applyMatrix4": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector4",
          "!doc": "Multiplies this vector with the given 4x4 matrix."
        },
        "ceil": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "The components of this vector are rounded up to the nearest integer value."
        },
        "clamp": {
          "!type": "fn(min: +THREE.Vector4, max: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "If this vector's x, y, z or w value is greater than the max vector's x, y, z or w value, it is replaced by the corresponding value. If this vector's x, y, z or w value is less than the min vector's x, y, z or w value, it is replaced by the corresponding value."
        },
        "clampLength": {
          "!type": "fn(min: number, max: number) -> +THREE.Vector4",
          "!doc": "If this vector's length is greater than the max value, it is replaced by the max value. If this vector's length is less than the min value, it is replaced by the min value."
        },
        "clampScalar": {
          "!type": "fn(minVal: number, maxVal: number) -> +THREE.Vector4",
          "!doc": "If this vector's x, y, z or w values are greater than the max value, they are replaced by the max value. If this vector's x, y, z or w values are less than the min value, they are replaced by the min value."
        },
        "clone": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "Returns a new vector with copied values from this instance."
        },
        "copy": {
          "!type": "fn(v: +THREE.Vector3) -> +THREE.Vector4",
          "!doc": "Copies the values of the given vector to this instance."
        },
        "divide": {
          "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "Divides this instance by the given vector."
        },
        "divideScalar": {
          "!type": "fn(scalar: number) -> +THREE.Vector4",
          "!doc": "Divides this vector by the given scalar."
        },
        "dot": {
          "!type": "fn(v: +THREE.Vector4) -> number",
          "!doc": "Calculates the dot product of the given vector with this instance."
        },
        "equals": {
          "!type": "fn(v: +THREE.Vector4) -> bool",
          "!doc": "Returns true if this vector is equal with the given one."
        },
        "floor": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "The components of this vector are rounded down to the nearest integer value."
        },
        "fromArray": {
          "!type": "fn(array, offset: number) -> +THREE.Vector4",
          "!doc": "Sets this vector's x value to be array[ offset ], y value to be array[ offset + 1 ], z value to be array[ offset + 2 ], w value to be array[ offset + 3 ]."
        },
        "fromBufferAttribute": {
          "!type": "fn(attribute: +THREE.BufferAttribute, index: number) -> +THREE.Vector4",
          "!doc": "Sets the components of this vector from the given buffer attribute."
        },
        "getComponent": {
          "!type": "fn(index: number) -> number",
          "!doc": "Returns the value of the vector component which matches the given index."
        },
        "length": {
          "!type": "fn() -> number",
          "!doc": "Computes the Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w)."
        },
        "lengthSq": {
          "!type": "fn() -> number",
          "!doc": "Computes the square of the Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should compare the length squared instead as it is slightly more efficient to calculate."
        },
        "lerp": {
          "!type": "fn(v: +THREE.Vector4, alpha: number) -> +THREE.Vector4",
          "!doc": "Linearly interpolates between the given vector and this instance, where alpha is the percent distance along the line - alpha = 0 will be this vector, and alpha = 1 will be the given one."
        },
        "lerpVectors": {
          "!type": "fn(v1: +THREE.Vector4, v2: +THREE.Vector4, alpha: number) -> +THREE.Vector4",
          "!doc": "Linearly interpolates between the given vectors, where alpha is the percent distance along the line - alpha = 0 will be first vector, and alpha = 1 will be the second one. The result is stored in this instance."
        },
        "manhattanLength": {
          "!type": "fn() -> number",
          "!doc": "Computes the Manhattan length of this vector."
        },
        "max": {
          "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "If this vector's x, y, z or w value is less than the given vector's x, y, z or w value, replace that value with the corresponding max value."
        },
        "min": {
          "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "If this vector's x, y, z or w value is greater than the given vector's x, y, z or w value, replace that value with the corresponding min value."
        },
        "multiply": {
          "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "Multiplies the given vector with this instance."
        },
        "multiplyScalar": {
          "!type": "fn(scalar: number) -> +THREE.Vector4",
          "!doc": "Multiplies the given scalar value with all components of this instance."
        },
        "negate": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w."
        },
        "normalize": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "Converts this vector to a unit vector - that is, sets it equal to a vector with the same direction as this one, but with a vector length of 1."
        },
        "random": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "Sets each component of this vector to a pseudo-random value between 0 and 1, excluding 1."
        },
        "round": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "The components of this vector are rounded to the nearest integer value"
        },
        "roundToZero": {
          "!type": "fn() -> +THREE.Vector4",
          "!doc": "The components of this vector are rounded towards zero (up if negative, down if positive) to an integer value."
        },
        "set": {
          "!type": "fn(x: number, y: number, z: number, w: number) -> +THREE.Vector4",
          "!doc": "Sets the vector components."
        },
        "setAxisAngleFromQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.Vector4",
          "!doc": "Sets the x, y and z components of this vector to the quaternion's axis and w to the angle."
        },
        "setAxisAngleFromRotationMatrix": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector4",
          "!doc": "Sets the x, y and z components of this vector to the axis of rotation and w to the angle."
        },
        "setComponent": {
          "!type": "fn(index: number, value: number) -> +THREE.Vector4",
          "!doc": "Allows to set a vector component with an index."
        },
        "setFromMatrixPosition": {
          "!type": "fn(m: +THREE.Matrix4) -> +THREE.Vector4",
          "!doc": "Sets the vector components to the position elements of the given transformation matrix."
        },
        "setLength": {
          "!type": "fn(length: number) -> +THREE.Vector4",
          "!doc": "Sets this vector to a vector with the same direction as this one, but with the specified length."
        },
        "setScalar": {
          "!type": "fn(scalar: number) -> +THREE.Vector4",
          "!doc": "Sets the vector components to the same value."
        },
        "setW": {
          "!type": "fn(w: number) -> +THREE.Vector4",
          "!doc": "Sets the vector's w component to the given value"
        },
        "setX": {
          "!type": "fn(x: number) -> +THREE.Vector4",
          "!doc": "Sets the vector's x component to the given value"
        },
        "setY": {
          "!type": "fn(y: number) -> +THREE.Vector4",
          "!doc": "Sets the vector's y component to the given value"
        },
        "setZ": {
          "!type": "fn(z: number) -> +THREE.Vector4",
          "!doc": "Sets the vector's z component to the given value"
        },
        "sub": {
          "!type": "fn(v: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "Subtracts the given vector from this instance."
        },
        "subScalar": {
          "!type": "fn(s: number) -> +THREE.Vector4",
          "!doc": "Subtracts the given scalar value from all components of this instance."
        },
        "subVectors": {
          "!type": "fn(a: +THREE.Vector4, b: +THREE.Vector4) -> +THREE.Vector4",
          "!doc": "Subtracts the given vectors and stores the result in this instance."
        },
        "toArray": {
          "!type": "fn(array, offset: number)",
          "!doc": "Writes the components of this vector to the given array. If no array is provided, the method returns a new instance."
        }
      },
      "!doc": "Constructs a new 4D vector.",
      "!type": "fn(x: number, y: number, z: number, w: number)"
    },
    "VectorKeyframeTrack": {
      "!url": "https://threejs.org/docs/#api/en/animation/VectorKeyframeTrack",
      "prototype": {
        "!proto": "THREE.KeyframeTrack.prototype",
        "DefaultInterpolation": {
          "!type": "+THREE.InterpolateLinear",
          "!doc": "The default interpolation type of this keyframe track."
        },
        "TimeBufferType": {
          "!type": "+TypedArray",
          "!doc": "The time buffer type of this keyframe track."
        },
        "ValueBufferType": {
          "!type": "+TypedArray",
          "!doc": "The value buffer type of this keyframe track."
        },
        "ValueTypeName": {
          "!type": "string",
          "!doc": "The value type name."
        },
        "name": {
          "!type": "string",
          "!doc": "The track's name can refer to morph targets or bones or possibly other values within an animated object. See PropertyBinding for the forms of strings that can be parsed for property binding."
        },
        "times": {
          "!type": "+Float32Array",
          "!doc": "The keyframe times."
        },
        "values": {
          "!type": "+Float32Array",
          "!doc": "The keyframe values."
        },
        "InterpolantFactoryMethodBezier": {
          "!type": "fn(result: +TypedArray) -> +THREE.BezierInterpolant",
          "!doc": "Factory method for creating a new Bezier interpolant. The Bezier interpolant requires tangent data to be set via the settings property on the track before creating the interpolant. The settings should contain: - inTangents: Float32Array with [time, value] pairs per keyframe per component - outTangents: Float32Array with [time, value] pairs per keyframe per component"
        },
        "InterpolantFactoryMethodDiscrete": {
          "!type": "fn(result: +TypedArray) -> +THREE.DiscreteInterpolant",
          "!doc": "Factory method for creating a new discrete interpolant."
        },
        "InterpolantFactoryMethodLinear": {
          "!type": "fn(result: +TypedArray) -> +THREE.LinearInterpolant",
          "!doc": "Factory method for creating a new linear interpolant."
        },
        "InterpolantFactoryMethodSmooth": {
          "!type": "fn(result: +TypedArray) -> +THREE.CubicInterpolant",
          "!doc": "Factory method for creating a new smooth interpolant."
        },
        "clone": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Returns a new keyframe track with copied values from this instance."
        },
        "getInterpolation": {
          "!type": "fn() -> +THREE.InterpolateLinear",
          "!doc": "Returns the current interpolation type."
        },
        "getValueSize": {
          "!type": "fn() -> number",
          "!doc": "Returns the value size."
        },
        "optimize": {
          "!type": "fn() -> +THREE.KeyframeTrack",
          "!doc": "Optimizes this keyframe track by removing equivalent sequential keys (which are common in morph target sequences)."
        },
        "scale": {
          "!type": "fn(timeScale: number) -> +THREE.KeyframeTrack",
          "!doc": "Scale all keyframe times by a factor (useful for frame - seconds conversions)."
        },
        "setInterpolation": {
          "!type": "fn(interpolation: +THREE.InterpolateLinear) -> +THREE.KeyframeTrack",
          "!doc": "Defines the interpolation factor method for this keyframe track."
        },
        "shift": {
          "!type": "fn(timeOffset: number) -> +THREE.KeyframeTrack",
          "!doc": "Moves all keyframes either forward or backward in time."
        },
        "trim": {
          "!type": "fn(startTime: number, endTime: number) -> +THREE.KeyframeTrack",
          "!doc": "Removes keyframes before and after animation without changing any values within the defined time range. Note: The method does not shift around keys to the start of the track time, because for interpolated keys this will change their values"
        },
        "validate": {
          "!type": "fn() -> bool",
          "!doc": "Performs minimal validation on the keyframe track. Returns true if the values are valid."
        }
      },
      "!doc": "Constructs a new vector keyframe track.",
      "!type": "fn(name: string, times, values, interpolation: +THREE.InterpolateLinear)"
    },
    "VideoFrameTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/VideoFrameTexture",
      "prototype": {
        "!proto": "THREE.VideoTexture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure the flip on bitmap creation instead."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Overwritten and set to false by default."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image object holding the texture data."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel."
        },
        "mipmaps": {
          "!doc": "An array holding user-defined mipmaps."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries)."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setFrame": {
          "!type": "fn(frame: +THREE.VideoFrame)",
          "!doc": "Sets the current frame of the video. This will automatically update the texture so the data can be used for rendering."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "update": {
          "!type": "fn()",
          "!doc": "This method overwritten with an empty implementation since this type of texture is updated via setFrame()."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new video frame texture.",
      "!type": "fn(mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, format: number, type: number, anisotropy: number)"
    },
    "VideoTexture": {
      "!url": "https://threejs.org/docs/#api/en/textures/VideoTexture",
      "prototype": {
        "!proto": "THREE.Texture.prototype",
        "anisotropy": {
          "!type": "number",
          "!doc": "The number of samples taken along the axis through the pixel that has the highest density of texels. By default, this value is 1. A higher value gives a less blurry result than a basic mipmap, at the cost of more texture samples being used."
        },
        "center": {
          "!type": "+THREE.Vector2",
          "!doc": "The point around which rotation occurs. A value of (0.5, 0.5) corresponds to the center of the texture. Default is (0, 0), the lower left."
        },
        "channel": {
          "!type": "number",
          "!doc": "Lets you select the uv attribute to map the texture to. 0 for uv, 1 for uv1, 2 for uv2 and 3 for uv3."
        },
        "colorSpace": {
          "!type": "string",
          "!doc": "Textures containing color data should be annotated with SRGBColorSpace or LinearSRGBColorSpace."
        },
        "depth": {
          "!doc": "The depth of the texture in pixels."
        },
        "flipY": {
          "!type": "bool",
          "!doc": "If set to true, the texture is flipped along the vertical axis when uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure the flip on bitmap creation instead."
        },
        "format": {
          "!type": "number",
          "!doc": "The format of the texture."
        },
        "generateMipmaps": {
          "!type": "bool",
          "!doc": "Whether to generate mipmaps (if possible) for a texture. Overwritten and set to false by default."
        },
        "height": {
          "!doc": "The height of the texture in pixels."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the texture."
        },
        "image": {
          "!type": "object",
          "!doc": "The image object holding the texture data."
        },
        "internalFormat": {
          "!type": "string",
          "!doc": "The default internal format is derived from Texture and Texture and defines how the texture data is going to be stored on the GPU. This property allows to overwrite the default format."
        },
        "magFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers more than one pixel."
        },
        "mapping": {
          "!type": "+THREE.UVMapping",
          "!doc": "How the texture is applied to the object. The value UVMapping is the default, where texture or uv coordinates are used to apply the map."
        },
        "matrix": {
          "!type": "+THREE.Matrix3",
          "!doc": "The uv-transformation matrix of the texture."
        },
        "matrixAutoUpdate": {
          "!type": "bool",
          "!doc": "Whether to update the texture's uv-transformation Texture from the properties Texture, Texture, Texture, and Texture. Set this to false if you are specifying the uv-transform matrix directly."
        },
        "minFilter": {
          "!type": "+THREE.NearestFilter",
          "!doc": "How the texture is sampled when a texel covers less than one pixel."
        },
        "mipmaps": {
          "!doc": "An array holding user-defined mipmaps."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the texture."
        },
        "needsPMREMUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the PMREM must be regenerated."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the texture must be updated in the next render. This triggers a texture upload to the GPU and ensures correct texture parameter configuration."
        },
        "offset": {
          "!type": "+THREE.Vector2",
          "!doc": "How much a single repetition of the texture is offset from the beginning, in each direction U and V. Typical range is 0.0 to 1.0."
        },
        "onUpdate": {
          "!type": "fn()",
          "!doc": "A callback function, called when the texture is updated (e.g., when Texture has been set to true and then the texture is used)."
        },
        "pmremVersion": {
          "!type": "number",
          "!doc": "Indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)."
        },
        "premultiplyAlpha": {
          "!type": "bool",
          "!doc": "If set to true, the alpha channel, if present, is multiplied into the color channels when the texture is uploaded to the GPU. Note that this property has no effect when using ImageBitmap. You need to configure premultiply alpha on bitmap creation instead."
        },
        "renderTarget": {
          "!type": "+THREE.RenderTarget",
          "!doc": "An optional back reference to the textures render target."
        },
        "repeat": {
          "!type": "+THREE.Vector2",
          "!doc": "How many times the texture is repeated across the surface, in each direction U and V. If repeat is set greater than 1 in either direction, the corresponding wrap parameter should also be set to RepeatWrapping or MirroredRepeatWrapping to achieve the desired tiling effect."
        },
        "rotation": {
          "!type": "number",
          "!doc": "How much the texture is rotated around the center point, in radians. Positive values are counter-clockwise."
        },
        "source": {
          "!type": "+THREE.Source",
          "!doc": "The data definition of a texture. A reference to the data source can be shared across textures. This is often useful in context of spritesheets where multiple textures render the same data but with different texture transformations."
        },
        "type": {
          "!type": "number",
          "!doc": "The data type of the texture."
        },
        "unpackAlignment": {
          "!type": "number",
          "!doc": "Specifies the alignment requirements for the start of each pixel row in memory. The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8 (rows start on double-word boundaries)."
        },
        "updateRanges": {
          "!doc": "This can be used to only update a subregion or specific rows of the texture (for example, just the first 3 rows). Use the addUpdateRange() function to add ranges to this array."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the texture. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the texture."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Texture is set to true."
        },
        "width": {
          "!doc": "The width of the texture in pixels."
        },
        "wrapS": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *U* in UV mapping."
        },
        "wrapT": {
          "!type": "+THREE.RepeatWrapping",
          "!doc": "This defines how the texture is wrapped horizontally and corresponds to *V* in UV mapping."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addUpdateRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Adds a range of data in the data texture to be updated on the GPU."
        },
        "clearUpdateRanges": {
          "!type": "fn()",
          "!doc": "Clears the update ranges."
        },
        "clone": {
          "!type": "fn() -> +THREE.Texture",
          "!doc": "Returns a new texture with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.Texture) -> +THREE.Texture",
          "!doc": "Copies the values of the given texture to this instance."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "Sets this texture's properties based on values."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes the texture into JSON."
        },
        "transformUv": {
          "!type": "fn(uv: +THREE.Vector2) -> +THREE.Vector2",
          "!doc": "Transforms the given uv vector with the textures uv transformation matrix."
        },
        "update": {
          "!type": "fn()",
          "!doc": "This method is called automatically by the renderer and sets Texture to true every time a new frame is available. Only relevant if requestVideoFrameCallback is not supported in the browser."
        },
        "updateMatrix": {
          "!type": "fn()",
          "!doc": "Updates the texture transformation matrix from the from the properties Texture, Texture, Texture, and Texture."
        }
      },
      "!doc": "Constructs a new video texture.",
      "!type": "fn(video: +THREE.HTMLVideoElement, mapping: number, wrapS: number, wrapT: number, magFilter: number, minFilter: number, format: number, type: number, anisotropy: number)"
    },
    "VolumeNodeMaterial": {
      "!url": "https://threejs.org/docs/#api/en/materials/VolumeNodeMaterial",
      "prototype": {
        "!proto": "THREE.NodeMaterial.prototype",
        "allowOverride": {
          "!type": "bool",
          "!doc": "Whether it's possible to override the material with Scene or not."
        },
        "alphaHash": {
          "!type": "bool",
          "!doc": "Enables alpha hashed transparency, an alternative to Material or Material. The material will not be rendered if opacity is lower than a random threshold. Randomization introduces some grain or noise, but approximates alpha blending without the associated problems of sorting. Using TAA can reduce the resulting noise."
        },
        "alphaTest": {
          "!type": "number",
          "!doc": "Sets the alpha value to be used when running an alpha test. The material will not be rendered if the opacity is lower than this value."
        },
        "alphaTestNode": {
          "!doc": "The alpha test of node materials is by default inferred from the alphaTest property. This node property allows to overwrite the default and define the alpha test with a node instead. If you don't want to overwrite the alpha test but modify the existing value instead, use materialAlphaTest."
        },
        "alphaToCoverage": {
          "!type": "bool",
          "!doc": "Whether alpha to coverage should be enabled or not. Can only be used with MSAA-enabled contexts (meaning when the renderer was created with *antialias* parameter set to true). Enabling this will smooth aliasing on clip plane edges and alphaTest-clipped edges."
        },
        "aoNode": {
          "!doc": "The lighting of node materials might be influenced by ambient occlusion. The default AO is inferred from an ambient occlusion map assigned to aoMap and the respective aoMapIntensity. This node property allows to overwrite the default and define the ambient occlusion with a custom node instead. If you don't want to overwrite the diffuse color but modify the existing values instead, use materialAO."
        },
        "backdropAlphaNode": {
          "!doc": "This node allows to modulate the influence of backdropNode to the outgoing light."
        },
        "backdropNode": {
          "!doc": "This node can be used to implement a variety of filter-like effects. The idea is to store the current rendering into a texture e.g. via viewportSharedTexture(), use it to create an arbitrary effect and then assign the node composition to this property. Everything behind the object using this material will now be affected by a filter. ``js const material = new NodeMaterial() material.transparent = true; // everything behind the object will be monochromatic material.backdropNode = saturation( viewportSharedTexture().rgb, 0 ); `` Backdrop computations are part of the lighting so only lit materials can use this property."
        },
        "blendAlpha": {
          "!type": "number",
          "!doc": "Represents the alpha value of the constant blend color. This property has only an effect when using custom blending with ConstantAlpha or OneMinusConstantAlpha."
        },
        "blendColor": {
          "!type": "+THREE.Color",
          "!doc": "Represents the RGB values of the constant blend color. This property has only an effect when using custom blending with ConstantColor or OneMinusConstantColor."
        },
        "blendDst": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination factor."
        },
        "blendDstAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending destination alpha factor."
        },
        "blendEquation": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation."
        },
        "blendEquationAlpha": {
          "!type": "+THREE.AddEquation",
          "!doc": "Defines the blending equation of the alpha channel."
        },
        "blendSrc": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source factor."
        },
        "blendSrcAlpha": {
          "!type": "+THREE.ZeroFactor",
          "!doc": "Defines the blending source alpha factor."
        },
        "blending": {
          "!type": "+THREE.NoBlending",
          "!doc": "Defines the blending type of the material. It must be set to CustomBlending if custom blending properties like Material, Material or Material should have any effect."
        },
        "castShadowNode": {
          "!doc": "This node can be used to influence how an object using this node material casts shadows. To apply a color to shadows, you can simply do: ``js material.castShadowNode = vec4( 1, 0, 0, 1 ); ` Which can be nice to fake colored shadows of semi-transparent objects. It is also common to use the property with Fn function so checks are performed per fragment. `js materialCustomShadow.castShadowNode = Fn( () => { hash( vertexIndex ).greaterThan( 0.5 ).discard(); return materialColor; } )(); ``"
        },
        "castShadowPositionNode": {
          "!doc": "Allows to overwrite the geometry position used for shadow map projection which is by default positionLocal, the vertex position in local space."
        },
        "clipIntersection": {
          "!type": "bool",
          "!doc": "Changes the behavior of clipping planes so that only their intersection is clipped, rather than their union."
        },
        "clipShadows": {
          "!type": "bool",
          "!doc": "Defines whether to clip shadows according to the clipping planes specified on this material."
        },
        "clippingPlanes": {
          "!doc": "User-defined clipping planes specified as THREE.Plane objects in world space. These planes apply to the objects this material is attached to. Points in space whose signed distance to the plane is negative are clipped (not rendered). This requires WebGLRenderer to be true."
        },
        "colorNode": {
          "!doc": "The diffuse color of node materials is by default inferred from the color and map properties. This node property allows to overwrite the default and define the diffuse color with a node instead. ``js material.colorNode = color( 0xff0000 ); // define red color ` If you don't want to overwrite the diffuse color but modify the existing values instead, use materialColor. `js material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint ``"
        },
        "colorWrite": {
          "!type": "bool",
          "!doc": "Whether to render the material's color. This can be used in conjunction with Object3D to create invisible objects that occlude other objects."
        },
        "contextNode": {
          "!type": "+THREE.ContextNode",
          "!doc": "This node can be used as a global context management component for this material."
        },
        "depthFunc": {
          "!type": "+THREE.NeverDepth",
          "!doc": "Defines the depth function."
        },
        "depthNode": {
          "!doc": "Allows to overwrite depth values in the fragment shader."
        },
        "depthTest": {
          "!type": "bool",
          "!doc": "Whether to have depth test enabled when rendering this material. When the depth test is disabled, the depth write will also be implicitly disabled."
        },
        "depthWrite": {
          "!type": "bool",
          "!doc": "Whether rendering this material has any effect on the depth buffer. When drawing 2D overlays it can be useful to disable the depth writing in order to layer several things together without creating z-index artifacts."
        },
        "dithering": {
          "!type": "bool",
          "!doc": "Whether to apply dithering to the color to remove the appearance of banding."
        },
        "envNode": {
          "!doc": "The environment of node materials can be defined by an environment map assigned to the envMap property or by Scene.environment if the node material is a PBR material. This node property allows to overwrite the default behavior and define the environment with a custom node. ``js material.envNode = pmremTexture( renderTarget.texture ); ``"
        },
        "fog": {
          "!type": "bool",
          "!doc": "Whether this material is affected by fog or not."
        },
        "forceSinglePass": {
          "!type": "bool",
          "!doc": "Whether double-sided, transparent objects should be rendered with a single pass or not. The engine renders double-sided, transparent objects with two draw calls (back faces first, then front faces) to mitigate transparency artifacts. There are scenarios however where this approach produces no quality gains but still doubles draw calls e.g. when rendering flat vegetation like grass sprites. In these cases, set the forceSinglePass flag to true to disable the two pass rendering to avoid performance issues."
        },
        "fragmentNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the fragment shader. Assigning a node will replace the built-in material logic used in the fragment stage."
        },
        "geometryNode": {
          "!type": "fn()",
          "!doc": "This node property is intended for logic which modifies geometry data once or per animation step. Apps usually place such logic randomly in initialization routines or in the animation loop. geometryNode is intended as a dedicated API so there is an intended spot where geometry modifications can be implemented. The idea is to assign a Fn definition that holds the geometry modification logic. A typical example would be a GPU based particle system that provides a node material for usage on app level. The particle simulation would be implemented as compute shaders and managed inside a Fn function. This function is eventually assigned to geometryNode."
        },
        "hardwareClipping": {
          "!type": "bool",
          "!doc": "Whether this material uses hardware clipping or not. This property is managed by the engine and should not be modified by apps."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the material."
        },
        "lights": {
          "!type": "bool",
          "!doc": "Whether this material is affected by lights or not."
        },
        "lightsNode": {
          "!type": "+THREE.LightsNode",
          "!doc": "Node materials which set their lights property to true are affected by all lights of the scene. Sometimes selective lighting is wanted which means only _some_ lights in the scene affect a material. This can be achieved by creating an instance of LightsNode with a list of selective lights and assign the node to this property. ``js const customLightsNode = lights( [ light1, light2 ] ); material.lightsNode = customLightsNode; ``"
        },
        "maskNode": {
          "!doc": "Discards the fragment if the mask value is false."
        },
        "maskShadowNode": {
          "!doc": "This node can be used to implement a shadow mask for the material."
        },
        "mrtNode": {
          "!type": "+THREE.MRTNode",
          "!doc": "MRT configuration is done on renderer or pass level. This node allows to overwrite what values are written into MRT targets on material level. This can be useful for implementing selective FX features that should only affect specific objects."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the material."
        },
        "needsUpdate": {
          "!type": "bool",
          "!doc": "Setting this property to true indicates the engine the material needs to be recompiled."
        },
        "normalNode": {
          "!doc": "The normals of node materials are by default inferred from the normalMap/normalScale or bumpMap/bumpScale properties. This node property allows to overwrite the default and define the normals with a node instead. If you don't want to overwrite the normals but modify the existing values instead, use materialNormal."
        },
        "offsetNode": {
          "!doc": "Offsets the distance a ray has been traveled through a volume. Can be used to implement dithering to reduce banding."
        },
        "opacity": {
          "!type": "number",
          "!doc": "Defines how transparent the material is. A value of 0.0 indicates fully transparent, 1.0 is fully opaque. If the Material is not set to true, the material will remain fully opaque and this value will only affect its color."
        },
        "opacityNode": {
          "!doc": "The opacity of node materials is by default inferred from the opacity and alphaMap properties. This node property allows to overwrite the default and define the opacity with a node instead. If you don't want to overwrite the opacity but modify the existing value instead, use materialOpacity."
        },
        "outputNode": {
          "!doc": "This node can be used to define the final output of the material. TODO: Explain the differences to fragmentNode."
        },
        "polygonOffset": {
          "!type": "bool",
          "!doc": "Whether to use polygon offset or not. When enabled, each fragment's depth value will be offset after it is interpolated from the depth values of the appropriate vertices. The offset is added before the depth test is performed and before the value is written into the depth buffer. Can be useful for rendering hidden-line images, for applying decals to surfaces, and for rendering solids with highlighted edges."
        },
        "polygonOffsetFactor": {
          "!type": "number",
          "!doc": "Specifies a scale factor that is used to create a variable depth offset for each polygon."
        },
        "polygonOffsetUnits": {
          "!type": "number",
          "!doc": "Is multiplied by an implementation-specific value to create a constant depth offset."
        },
        "positionNode": {
          "!doc": "The local vertex positions are computed based on multiple factors like the attribute data, morphing or skinning. This node property allows to overwrite the default and define local vertex positions with nodes instead. If you don't want to overwrite the vertex positions but modify the existing values instead, use positionLocal. ``js material.positionNode = positionLocal.add( displace ); ``"
        },
        "precision": {
          "!type": "+THREE.highp",
          "!doc": "Override the renderer's default precision for this material."
        },
        "premultipliedAlpha": {
          "!type": "bool",
          "!doc": "Whether to premultiply the alpha (transparency) value."
        },
        "receivedShadowNode": {
          "!type": "fn()",
          "!doc": "This node can be used to influence how an object using this node material receive shadows. ```js const totalShadows = float( 1 ).toVar(); material.receivedShadowNode = Fn( ( [ shadow ] ) => { totalShadows.mulAssign( shadow ); //return float( 1 ); // bypass received shadows return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color } );"
        },
        "receivedShadowPositionNode": {
          "!doc": "Allows to overwrite the position used for shadow map rendering which is by default positionWorld, the vertex position in world space."
        },
        "scatteringNode": {
          "!type": "fn()",
          "!doc": "Node used for scattering calculations."
        },
        "shadowSide": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces cast shadows. If null, the side casting shadows is determined as follows: - When Material is set to FrontSide, the back side cast shadows. - When Material is set to BackSide, the front side cast shadows. - When Material is set to DoubleSide, both sides cast shadows."
        },
        "side": {
          "!type": "+THREE.FrontSide",
          "!doc": "Defines which side of faces will be rendered - front, back or both."
        },
        "stencilFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns false."
        },
        "stencilFunc": {
          "!type": "+THREE.NeverStencilFunc",
          "!doc": "The stencil comparison function to use."
        },
        "stencilFuncMask": {
          "!type": "number",
          "!doc": "The bit mask to use when comparing against the stencil buffer."
        },
        "stencilRef": {
          "!type": "number",
          "!doc": "The value to use when performing stencil comparisons or stencil operations."
        },
        "stencilWrite": {
          "!type": "bool",
          "!doc": "Whether stencil operations are performed against the stencil buffer. In order to perform writes or comparisons against the stencil buffer this value must be true."
        },
        "stencilWriteMask": {
          "!type": "number",
          "!doc": "The bit mask to use when writing to the stencil buffer."
        },
        "stencilZFail": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true but the depth test fails."
        },
        "stencilZPass": {
          "!type": "+THREE.ZeroStencilOp",
          "!doc": "Which stencil operation to perform when the comparison function returns true and the depth test passes."
        },
        "steps": {
          "!type": "number",
          "!doc": "Number of steps used for raymarching."
        },
        "toneMapped": {
          "!type": "bool",
          "!doc": "Defines whether this material is tone mapped according to the renderer's tone mapping setting. It is ignored when rendering to a render target or using post processing or when using WebGPURenderer. In all these cases, all materials are honored by tone mapping."
        },
        "transparent": {
          "!type": "bool",
          "!doc": "Defines whether this material is transparent. This has an effect on rendering as transparent objects need special treatment and are rendered after non-transparent objects. When set to true, the extent to which the material is transparent is controlled by Material."
        },
        "type": {
          "!type": "string",
          "!doc": "Represents the type of the node material."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the Material. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the material."
        },
        "version": {
          "!type": "number",
          "!doc": "This starts at 0 and counts how many times Material is set to true."
        },
        "vertexColors": {
          "!type": "bool",
          "!doc": "If set to true, vertex colors should be used. The engine supports RGB and RGBA vertex colors depending on whether a three (RGB) or four (RGBA) component color buffer attribute is used."
        },
        "vertexNode": {
          "!doc": "This node property can be used if you need complete freedom in implementing the vertex shader. Assigning a node will replace the built-in material logic used in the vertex stage."
        },
        "visible": {
          "!type": "bool",
          "!doc": "Defines whether 3D objects using this material are visible."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "build": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Builds this material with the given node builder."
        },
        "clone": {
          "!type": "fn() -> +THREE.Material",
          "!doc": "Returns a new material with copied values from this instance."
        },
        "copy": {
          "!type": "fn(source: +THREE.NodeMaterial) -> +THREE.NodeMaterial",
          "!doc": "Copies the properties of the given node material to this instance."
        },
        "customProgramCacheKey": {
          "!type": "fn() -> string",
          "!doc": "Allows to define a custom cache key that influence the material key computation for render objects."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "onBeforeCompile": {
          "!type": "fn(shaderobject: object, renderer: +THREE.WebGLRenderer)",
          "!doc": "An optional callback that is executed immediately before the shader program is compiled. This function is called with the shader source code as a parameter. Useful for the modification of built-in materials. This method can only be used when rendering with WebGLRenderer. The recommended approach when customizing materials is to use WebGPURenderer with the new Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language)."
        },
        "onBeforeRender": {
          "!type": "fn(renderer: +THREE.WebGLRenderer, scene: +THREE.Scene, camera: +THREE.Camera, geometry: +THREE.BufferGeometry, object: +THREE.Object3D, group: object)",
          "!doc": "An optional callback that is executed immediately before the material is used to render a 3D object. This method can only be used when rendering with WebGLRenderer."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "setDefaultValues": {
          "!type": "fn(material: +THREE.Material)",
          "!doc": "Most classic material types have a node pendant e.g. for MeshBasicMaterial there is MeshBasicNodeMaterial. This utility method is intended for defining all material properties of the classic type in the node type."
        },
        "setValues": {
          "!type": "fn(values: object)",
          "!doc": "This method can be used to set default values from parameter objects. It is a generic implementation so it can be used with different types of materials."
        },
        "setup": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the vertex and fragment stage of this node material."
        },
        "setupClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.ClippingNode",
          "!doc": "Setups the clipping node."
        },
        "setupDepth": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the depth of this material."
        },
        "setupDiffuseColor": {
          "!type": "fn(builder: +THREE.NodeBuilder, geometry: +THREE.BufferGeometry)",
          "!doc": "Setups the computation of the material's diffuse color."
        },
        "setupEnvironment": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the environment node from the material."
        },
        "setupFog": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setup the fog."
        },
        "setupHardwareClipping": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the hardware clipping if available on the current device."
        },
        "setupLightMap": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the light map node from the material."
        },
        "setupLighting": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the outgoing light node."
        },
        "setupLightingModel": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightingModel",
          "!doc": "This method should be implemented by most derived materials since it defines the material's lighting model."
        },
        "setupLights": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.LightsNode",
          "!doc": "Setups the lights node based on the scene, environment and material."
        },
        "setupModelViewProjection": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position in clip space."
        },
        "setupNormal": {
          "!type": "fn()",
          "!doc": "Setups the normal node from the material."
        },
        "setupObserver": {
          "!type": "fn(builder: +THREE.NodeBuilder) -> +THREE.NodeMaterialObserver",
          "!doc": "Setups a node material observer with the given builder."
        },
        "setupOutgoingLight": {
          "!type": "fn()",
          "!doc": "Setups the outgoing light node variable"
        },
        "setupOutput": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups the output node."
        },
        "setupPosition": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the computation of the position in local space."
        },
        "setupPositionView": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the position node in view space. This method exists so derived node materials can modify the implementation e.g. sprite materials."
        },
        "setupPremultipliedAlpha": {
          "!type": "fn(builder: +THREE.NodeBuilder, outputNode)",
          "!doc": "Setups premultiplied alpha."
        },
        "setupVariants": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Abstract interface method that can be implemented by derived materials to setup material-specific node variables."
        },
        "setupVertex": {
          "!type": "fn(builder: +THREE.NodeBuilder)",
          "!doc": "Setups the logic for the vertex stage."
        },
        "toJSON": {
          "!type": "fn(meta: object) -> object",
          "!doc": "Serializes this material to JSON."
        }
      },
      "!doc": "Constructs a new volume node material.",
      "!type": "fn(parameters: object)"
    },
    "WireframeGeometry": {
      "!url": "https://threejs.org/docs/#api/en/geometries/WireframeGeometry",
      "prototype": {
        "!proto": "THREE.BufferGeometry.prototype",
        "attributes": {
          "!doc": "This dictionary has as id the name of the attribute to be set and as value the buffer attribute to set it to. Rather than accessing this property directly, use setAttribute() and getAttribute() to access attributes of this geometry."
        },
        "boundingBox": {
          "!type": "+THREE.Box3",
          "!doc": "Bounding box for the geometry which can be calculated with computeBoundingBox()."
        },
        "boundingSphere": {
          "!type": "+THREE.Sphere",
          "!doc": "Bounding sphere for the geometry which can be calculated with computeBoundingSphere()."
        },
        "drawRange": {
          "!type": "object",
          "!doc": "Determines the part of the geometry to render. This should not be set directly, instead use setDrawRange()."
        },
        "groups": {
          "!doc": "Split the geometry into groups, each of which will be rendered in a separate draw call. This allows an array of materials to be used with the geometry. Use addGroup() and clearGroups() to edit groups, rather than modifying this array directly. Every vertex and index must belong to exactly one group  groups must not share vertices or indices, and must not leave vertices or indices unused."
        },
        "id": {
          "!type": "number",
          "!doc": "The ID of the geometry."
        },
        "index": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "Allows for vertices to be re-used across multiple triangles; this is called using \"indexed triangles\". Each triangle is associated with the indices of three vertices. This attribute therefore stores the index of each vertex for each triangular face. If this attribute is not set, the renderer assumes that each three contiguous positions represent a single triangle."
        },
        "indirect": {
          "!type": "+THREE.BufferAttribute",
          "!doc": "A (storage) buffer attribute which was generated with a compute shader and now defines indirect draw calls. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "indirectOffset": {
          "!type": "number",
          "!doc": "The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset. Can only be used with WebGPURenderer and a WebGPU backend."
        },
        "morphAttributes": {
          "!type": "object",
          "!doc": "This dictionary holds the morph targets of the geometry. Note: Once the geometry has been rendered, the morph attribute data cannot be changed. You will have to call dispose(), and create a new geometry instance."
        },
        "morphTargetsRelative": {
          "!type": "bool",
          "!doc": "Used to control the morph target behavior; when set to true, the morph target data is treated as relative offsets, rather than as absolute positions/normals."
        },
        "name": {
          "!type": "string",
          "!doc": "The name of the geometry."
        },
        "parameters": {
          "!type": "object",
          "!doc": "Holds the constructor parameters that have been used to generate the geometry. Any modification after instantiation does not change the geometry."
        },
        "userData": {
          "!type": "object",
          "!doc": "An object that can be used to store custom data about the geometry. It should not hold references to functions as these will not be cloned."
        },
        "uuid": {
          "!type": "string",
          "!doc": "The UUID of the geometry."
        },
        "addEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Adds the given event listener to the given event type."
        },
        "addGroup": {
          "!type": "fn(start: number, count: number, materialIndex: number)",
          "!doc": "Adds a group to this geometry."
        },
        "applyMatrix4": {
          "!type": "fn(matrix: +THREE.Matrix4) -> +THREE.BufferGeometry",
          "!doc": "Applies the given 4x4 transformation matrix to the geometry."
        },
        "applyQuaternion": {
          "!type": "fn(q: +THREE.Quaternion) -> +THREE.BufferGeometry",
          "!doc": "Applies the rotation represented by the Quaternion to the geometry."
        },
        "center": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Center the geometry based on its bounding box."
        },
        "clearGroups": {
          "!type": "fn()",
          "!doc": "Clears all groups."
        },
        "clone": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Returns a new geometry with copied values from this instance."
        },
        "computeBoundingBox": {
          "!type": "fn()",
          "!doc": "Computes the bounding box of the geometry, and updates the boundingBox member. The bounding box is not computed by the engine; it must be computed by your app. You may need to recompute the bounding box if the geometry vertices are modified."
        },
        "computeBoundingSphere": {
          "!type": "fn()",
          "!doc": "Computes the bounding sphere of the geometry, and updates the boundingSphere member. The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling. You may need to recompute the bounding sphere if the geometry vertices are modified."
        },
        "computeTangents": {
          "!type": "fn()",
          "!doc": "Calculates and adds a tangent attribute to this geometry. The computation is only supported for indexed geometries and if position, normal, and uv attributes are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by BufferGeometryUtils instead."
        },
        "computeVertexNormals": {
          "!type": "fn()",
          "!doc": "Computes vertex normals for the given vertex data. For indexed geometries, the method sets each vertex normal to be the average of the face normals of the faces that share that vertex. For non-indexed geometries, vertices are not shared, and the method sets each vertex normal to be the same as the face normal."
        },
        "copy": {
          "!type": "fn(source: +THREE.BufferGeometry) -> +THREE.BufferGeometry",
          "!doc": "Copies the values of the given geometry to this instance."
        },
        "deleteAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferGeometry",
          "!doc": "Deletes the attribute for the given name."
        },
        "dispatchEvent": {
          "!type": "fn(event: object)",
          "!doc": "Dispatches an event object."
        },
        "dispose": {
          "!type": "fn()",
          "!doc": "Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app."
        },
        "getAttribute": {
          "!type": "fn(name: string) -> +THREE.BufferAttribute",
          "!doc": "Returns the buffer attribute for the given name."
        },
        "getIndex": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the index of this geometry."
        },
        "getIndirect": {
          "!type": "fn() -> +THREE.BufferAttribute",
          "!doc": "Returns the indirect attribute of this geometry."
        },
        "hasAttribute": {
          "!type": "fn(name: string) -> bool",
          "!doc": "Returns true if this geometry has an attribute for the given name."
        },
        "hasEventListener": {
          "!type": "fn(type: string, listener: fn()) -> bool",
          "!doc": "Returns true if the given event listener has been added to the given event type."
        },
        "lookAt": {
          "!type": "fn(vector: +THREE.Vector3) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry to face a point in 3D space. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "normalizeNormals": {
          "!type": "fn()",
          "!doc": "Ensures every normal vector in a geometry will have a magnitude of 1. This will correct lighting on the geometry surfaces."
        },
        "removeEventListener": {
          "!type": "fn(type: string, listener: fn())",
          "!doc": "Removes the given event listener from the given event type."
        },
        "rotateX": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the X axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateY": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Y axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "rotateZ": {
          "!type": "fn(angle: number) -> +THREE.BufferGeometry",
          "!doc": "Rotates the geometry about the Z axis. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "scale": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Scales the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        },
        "setAttribute": {
          "!type": "fn(name: string, attribute: +THREE.BufferAttribute) -> +THREE.BufferGeometry",
          "!doc": "Sets the given attribute for the given name."
        },
        "setDrawRange": {
          "!type": "fn(start: number, count: number)",
          "!doc": "Sets the draw range for this geometry."
        },
        "setFromPoints": {
          "!type": "fn(points) -> +THREE.BufferGeometry",
          "!doc": "Defines a geometry by creating a position attribute based on the given array of points. The array can hold 2D or 3D vectors. When using two-dimensional data, the z coordinate for all vertices is set to 0. If the method is used with an existing position attribute, the vertex data are overwritten with the data from the array. The length of the array must match the vertex count."
        },
        "setIndex": {
          "!type": "fn(index) -> +THREE.BufferGeometry",
          "!doc": "Sets the given index to this geometry."
        },
        "setIndirect": {
          "!type": "fn(indirect: +THREE.BufferAttribute, indirectOffset: number) -> +THREE.BufferGeometry",
          "!doc": "Sets the given indirect attribute to this geometry."
        },
        "toJSON": {
          "!type": "fn() -> object",
          "!doc": "Serializes the geometry into JSON."
        },
        "toNonIndexed": {
          "!type": "fn() -> +THREE.BufferGeometry",
          "!doc": "Return a new non-index version of this indexed geometry. If the geometry is already non-indexed, the method is a NOOP."
        },
        "translate": {
          "!type": "fn(x: number, y: number, z: number) -> +THREE.BufferGeometry",
          "!doc": "Translates the geometry. This is typically done as a one time operation, and not during a loop. Use Object3D for typical real-time mesh rotation."
        }
      },
      "!doc": "Constructs a new wireframe geometry.",
      "!type": "fn(geometry: +THREE.BufferGeometry)"
    }
  }
}
    };
  });
});
